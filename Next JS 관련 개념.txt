- 프론트엔드 기반의 '풀스택 프레임워크'들의 등장 배경 타임라인 및 이유

   1. client-side rendering (CSG)의 단점부각
       -> 첫 페이지 진입시 로딩이 상대적으로 엄청 오래 걸림 + 검색엔진의 노출이 좀 많이 어려움
           -> 웹서비스 트래픽 늘리기가 상대적으로 어렵고, 결국 수입지표적으로 어려움이 많이 생김 

   2. server-side rendering (SSG)의 장점이 다시 주목되고 다시 대세가 변하는 중
       -> client-side rendering (CSG)의 기능 및 성능향상의 최적화를 위해 알아야 했던, 프론트엔드의 전문성이라고 부르던 것들이 별로 필요함
          (= server-side rendering (SSG)을 사용하면, 결과적으로 그 딴거 쓸 이유가 사라지고, 상대적으로 프론트엔드 개발의 복잡성이 많이 줄어듬)

   3. NodeJS로 이제는 백엔드 개발도 JS로 가능해진 시대가 되었음
       -> CSG를 안 쓴다면, 그 CSG에 특화된 복잡한 개발력이 필요없어지니, 그만큼 백엔드를 만질 수 있는것도 중요
    
   4. 프론트엔드와 백엔드를 JS를 중심으로 통합된 개발환경을 제공할 수 있다면 엄청 유용할거 같음
       -> 가장 점유율이 높은 react 기반으로 각종 프론트엔드 기반의 풀스택 프레임워크('렌더링 프레임워크', 'meta 프레임워크'라고 불림)들이 등장하기 시작함
          (= Next.js 도 그 중 하나)

          ex) GatsBY, nuxt, sveltekit, remix, Next.js


- Next.js
   : react 라이브러리 기반의 '풀스택 프레임워크'로 이걸로 JS기반으로 화면과 웹서버 전부를 통합적으로 개발 가능하고, 쉽게 서버 및 화면에 대한 설정이나 기능 또한 도입이 가능함
      -> 웹서버 개발에 대한 수요가 반영 = 상대적으로 client에 많이 역할을 떠넘긴 CSG보단, JS만으로 SSG 기반 웹서비스를 상정하고 개발된 프레임워크


    # Next.JS를 배우는게 유리한 이유 + 장점

       @ Next.JS 장점
          1. GPT의 템플릿 기능이 나날이 발전하고 있기에, 점점 노가다성 개발력은 사라져가고 낮은 수준의 업무 장벽은 많이 줄어든 상태니, 개발자로서 풀스택적으로 범용성이 넓어 나쁠건 없음
 
          2. 프론트엔드 기반 통합 프레임워크들의 사용방법도 나날히 쉬워지기에, 미래의 개발환경의 점유율이 높아질 수 있기에 대비해서 나쁠건 없음
  
              ex) 회원인증 기능도 Next-auth 라이브러리를 끌어다 쓰면 10초면 구현 가능
 
          3. react기반이기에 react 문법을 사용하여, 특히나 쉽게 입문 가능
 
          4. GatsBY, nuxt, sveltekit, remix, Next.js 중 Next.js가 가장 꾸준하게 많이 쓰고, 만족도 수준과 유지력도 좋다는 점에서, 나중에 미래는 이 녀석이 될 확률이 높음
 
          5. 14버전 부터는 각종 편의성이 매우 증가함
              1) 폴더 기반 자동 라우팅으로 폴더와 JS파일만 만들면, 자동으로 잡아내서 HTML페이지를 생성해 줌
              2) 서버API 기능이 개선
              3) 더 쉬운 DB연결
              4) 직관적으로 rendering 전략 선택할 수 있는 기능이 존재 = SSG, CSG를 선택 가능하며 JS 없는거도 개발 가능 
              5) hydration 없는 server-side rendering
              6) 파워풀하고 쉬운 캐싱
              7) 이미지와 폰트 최적화
    
       @ Next.JS 단점
          1. react 라이브러리의 신문법인 client component, server component의 구분을 적극적으로 하는데, 이를 구분해서 코드를 짜는게 프로젝트 커지면 복잡할 수 있음
   
          2. WebSocket, WebRTC 같은 기능은 제대로 지원하지 않음 
             (= 직접 Nodejs + express 서버를 하나 더 만드는게 나음)
   
          3. HTML 랜더링에 기능이 집중되어 있고, 서버기능 쪽은 아직 상대적으로 갈 길이 멀다는 점
   
          4. 14버전인데 아직도 프레임워크 자체 버그가 종종 보임
              -> react 라이브러리를 적극 반영한건 좋은데, 아직 react가 구현하지 않은 미완성 기능들까지 도입해놓은 것 포함
   
          5. 14버전부터 폴더 기반 자동 라우팅 기능이 강화된 덕분에, 프로젝트 커지면 관련 예약 파일들이 많아져 복잡도가 올라갈 수는 있음


    # Next.js 기반 프로젝트를 배포하는 방법
      1. AWS에다가 zip파일 올려서 배포해라
      2. (강추) Next.js를 개발하는 vercel.com 들어가서 시키는데로해서 프로젝트를 배포하기
           : Github repo에 코드 올릴 때 마다 그걸 자동으로 Elastic Beanstalk 스럽게 배포해주는 식으로 동작하기에 참 간편함!

          @ 장점
             1) 월 100GB 트래픽까지 무료계정으로 해결 가능! 작은 사이트 운영할 땐 편리합니다. 
                (월 20달러에 월 트래픽 1TB 까지 사용가능)

             2) 간편하기로는 으뜸가며, Github과 연동이 되는 방식

          @ 단점
             : 서버에서 하드디스크 사용이 불가능하여, 이미지 파일 같은 걸 따로 스토리지에 저장한다면 힘들 수 있음


    # Next.js 프로젝트 생성 (= 서버까지 생성)
      1. nodejs 설치
      2. 작업폴더만들고 에디터로 오픈
      3. 터미널에 npx create-next-app@latest 입력
          -> (참고) 이 명령어가 'npm init -y'로 대표되는 node 서버의 초기화 기능까지 담당해 줌

      4. 프로젝트 설정을 결정해야 하는데, App Router는 사용한다 체크하고 나머지는 적절히 체크

         ex) 프로젝트 이름, App Router 사용할 건지, Typescript 사용여부, ES lint 사용여부, Tailwind CSS 사용여부, src 폴더 사용 여부, import alias 사용시 어떤 문자를 쓸건지 등

      5. page.js에 존재하는 기본 예시 화면에 대한 코드인 return 부분 다 지우고 <div></div>만 적고 코딩 시작
      6. global.css의 내용도 전부 지우기
      7. 터미널에 npm run dev 를 입력 = 서버 미리보기 띄우기 (page.js가 메인페이지)
      8. http://localhost:3000 으로 접속


    # 프로젝트 파일들
       1. app 폴더 : react와 비슷하게 화면 관련 코드들이 들어있는 핵심 폴더

          1) page.js  
              : 메인 페이지에 해당하는 JS파일
                 -> (참고) URL을 통한 웹페이지 Router 기능을 구현
                      : app 폴더 안에 다른 폴더를 만드는 식으로 단계별로 폴더를 만들고, 그 안에 page.js를 제작하면 됨  

          2) layout.js
              : 메인 페이지를 감싸는 용도로 제작된 JS파일
                 -> 참고사항
                     a. RootLayout({ children })라는 functional component로 구성
                         : parameter인 js객체 children은 각 폴더 위치 및 url에 대응하는 page.js를 의미하며, {}내 배치는 그 녀석이 위치할 곳을 의미 
                           (= 가장 바깥쪽의 layout.js의 함수 RootLayout({ children })의 children은 가장 바깥에 작성한 page.js에 해당하는 react의 App 컴포넌트 역할)

                     b. 동작방식
                        : app 폴더 안에 다른 폴더를 만드는 Router 기능을 구현 시 최상위의 layout.js를 가장 바깥, app 폴더를 기준으로 layout.js를 가장 마지막에 적용하는 양파같은 구조로 웹페이지 조립을 해줌
                          (= app 폴더를 기준으로 layout.js는 모든 하위 웹페이지들에 모두 적용됨)
                              -> (중요) js의 이벤트버블링이 작동하는 방식과 유사함을 명심하자... 대상 page.js 자기가 닿지 못한 폴더의 layout.js는 적용 못한다고 생각하면 이해가 편함

                                  ex) <head> 태그의 내용들을 여기다 담기도 함 
                                  ex) 페이지 간 공용으로 사용하는 component들의 경우
                                       -> 상단 navigation 같은 녀석들

          3) globals.css
              : 모든 페이지에 적용되는 전역 style들을 적는 css파일

          4) js파일명.node_modules.css
              : 특정 js파일명을 가진 JS 페이지에만 적용되는 style들을 적는 css파일

          5) api 폴더
              : node JS 본연의 기능인 웹서버 관련 기능을 담당하는 JS코드들이 모여 있는 app 폴더 내부의 폴더
 
          6) public 폴더
              : 이미지, 폰트 static 파일들을 보관하는 app 폴더 내부의 폴더 

       2. 그 밖에 존재하는 파일/폴더들

          1) next.config.js   
              : nextjs 설정 파일

          2) node_modules 폴더
              : 프로젝트 구동에 필요한 node JS 기반 라이브러리 보관용 폴더 
                 -> npm을 통해 다운받은 내용들을 다 여기 보관

          3) package.json     
              : npm 명령어 내용과 설치한 라이브러리 버전 기록용 파일.. 
                 -> 이거 하나면, 나중에 npm install 한 방으로 모든 라이브러리를 npm에서 다시 다운로드 가능

 
    # React 라이브러리의 JSX 문법(functional component를 기반으로 설명) 대략 정리
       -> React 기반의 프레임워크 Next.js에서 페이지 layout작성을 위한 문법.. 
          (심화된 내용을 내용을 원한다면, react 쪽 문서 참고)

          1. functional component 관련 
          
            @ component 만드는 과정

              1) 컴포넌트 만들고 싶으면 우선 function을 만들고 작명 (관습적으로 영어 대문자)
              2) function의 return () 안에 해당 component 단위를 구성하는 HTML 기반의 코드에 대한 내용이 기입되어야 함
              3) 원하는 곳에서 <작명/> 을 사용
 
                 ex) <작명> 이라는 임의의 component를 정의해서 사용
                 
                     export default function Cart() {
                       return (
                         <div>
                           <h4>Cart</h4>
                           <작명></작명>
                           <작명></작명>
                         </div>
                       )
                     }
                     
                     function 작명(){
                       return(
                         <div className="cart-item">
                           <p>상품명</p>
                           <p>$40</p>
                           <p>1개</p>
                         </div>
                       )
                     } 

            @ component 장/단점

               (장점)
                 a. component 들을 쉽게 재사용 가능 
                     -> (보통 배열명.map(콜백함수) 이거랑 조합)

                 b. 해당 component에서 통용되는 state 객체의 데이터들은 캡슐화가 되어 있음
                    (= 다른 component로 부터 값을 보호 가능하며, 자신의 값은 자신들만 조작이 가능한 구조)

                 c. component의 state객체가 변하는 부분에 한해서, 해당 영역의 component 부위만 다시 랜더링 가능
                    (= 페이지 재랜더링을 딱 변화가 필요한 부분만 하니 작업 효율과 성능이 올라감)

               (단점)
                 a. component 간 state 객체의 값을 전달받는 방법은 자기 후손들에게 일일히 props 객체를 구성해서 전달하는 방법 뿐이 없음 
                    (= 형제 component간 값을 주고받을 수 없고, 부모에게 값을 주는 방법도 없고, 오로지 받기만 해야함)

            @ functional component 작성시 주의사항
               1) (중요!) 각 component를 구성하는 최상위 HTML 태그에 해당하는 녀석은 '반드시' 1개만 허용됨

                   ex) 최상위 태그가 2개 (X)

                       return (
                         <div></div>
                         <div></div>
                       )

                   ex) 굳이 하고 싶다면, 다른 최상위 태그로 감싸자 (O)

                       return (
                         <> 
                           <div></div>
                           <div></div>
                         </>
                       )

               2) HTML 기반의 코드 = HTML 문법과 유사하나, 결과적으로는 HTML과 유사할 뿐, 여러 부분에서 JSX에서만 통용되는 유사 HTML 문법이라고 보면 됨
  
                   ex) JS변수의 값을 {}를 통해 넣거나, 각종 속성명이 HTML 원본의 그것과는 다르게 설계, style 속성값 작성법이 js객체 형식으로 작성되어야 함

               3) functional component의 HTML영역 작성시 함수 {} 내의 JSX변수 값을 넣고 싶을때는 어디서든 { JSX변수명 }을 사용하자
                   -> (중요) className, id, href 이런 HTML 속성에 해당하는 값에도 사용이 가능
                       -> (참고) ES6 이후 백틱(``)을 통한 문자열 작성시 JS에서도 `문자열어쩌고 ${JS변수명} 끝`과 같은 식으로 변수의 값을 문자열 도중에 끌어들일 수 있음

                           ex) HTML 속성에 해당되는 값이라도 상관없이 {}를 쓰면 함수 내부의 지역변수명을 사용 가능

                               export default function Home() {

                                 let name = 'park';
                                 let link = 'https://naver.com';

                                 return (
                                   <div>
                                     <h4 className="title">애플후레시</h1>
                                     <p className="title-sub">by dev {name}</p>
                                     <a href={link}>링크</a>
                                   </div>
                                 )
                               }

            @ functional component 작성시 HTML 속성넣기

               1) HTML에서의 class 속성 -> className으로 기입
                   : JS의 class라는 예약어가 class 문법과 관련해서 이미 존재하고 있기 때문
                     (= 작성하는 JSX파일의 functional component도 따지고보면, JS영역이라고 볼 수 있음) 
     
                     ex) JSX에서는 class (X) -> className (O)
     
                         export default function Home() {
                           return (
                             <div>
                               <h4 className="title">애플후레시</h4>
                               <p className="title-sub">by dev kim</p>
                             </div>
                           )
                         }
     
               2) functional component의 HTML영역 작성시 inline style 형식으로 style 값을 넣고 싶으면, 'JS객체 자료형' 형식으로 작성해야 함 
                  (주로 동적으로 component에 style 변경이 필요한 경우 쓰이곤 함)
     
                   ex) JSX에서의 component의 style 작성 형식 
                        : {{ style속성명1 : '값1', ... , style속성명N : '값N' }}
        
                          export default function Home() {
                            return (
                              <div>
                                <h4 className="title" style={{ color : 'red', fontSize : '20px' }}>애플후레시</h4>
                                <p className="title-sub">by dev {name}</p>
                              </div>
                            )
                          }
     
               3) (주의) style 속성 작성시 주의사항
                  : '-'이 들어간 style속성명의 경우, camalCase 형식으로 작성해 줘야 함
                      -> 'JS객체' 형식 내부에 입력되는 style 속성명은 '-'을 인식할 수 없기 때문임 
     
                          ex) font-size -> fontSize

               4) (주의) <input> 안의 value 속성의 경우 react에서도 쓰는 상황이고, 이는 CSR방식으로 state객체의 변수를 초기값으로 <input>에 두고, react의 onChange 이벤트핸들러 속성과 setter함수로 state객체를 통제하고 싶을 때 사용
                   : Next.JS에서 SSR방식으로 <input>태그의 value속성을 쓰고 싶은 경우, defaultValue 속성을 쓰도록 하자
                      -> (중요) 구분해서 써야 할 이유는 value쪽을 쓰려면, CSR방식으로 <input>과 state객체의 요소가 관련된 특별한 용도에 맞는 기능이 추가되는 만큼 성능도 더 많이 잡아먹기 때문...

               5) react의 CSR 방식의 Routing기능을 만들고 싶다면, component 반환값 html 레이아웃을 작성시, <a>태그 대신 Link를 import하고 대신 쓰면 됨
                   -> (중요) server component에서도 사용가능하나, CSR방식을 사용하여 새로고침없이 부드럽게 페이지 이동이 가능한 soft Refresh 기능을 사용..

                       ex) import Link from "next/link";
                  
                            <body>
                              <div className="navbar">
                                <Link href="/">Home</Link>
                                <Link href="/list">List</Link>
                              </div>
                              {children}
                            </body>

                   -> (NEXT.JS의 <Link> 태그와 prefetch()의 관계)
                        : <Link> 태그는 서버에서는 랜더링만 해주고, client 측의 JS런타임에서 useRouter().perfetch()에 해당하는 기능을 수행가능하기에 CSR임에도 server component 환경에서 쓸수 있게 설계됨 
                           -> 만약 <Link> 태그가 보이면, URL에 해당하는 페이지를 미리 로딩해주는 prefetch() 기능을 써서 CSR방식으로 동작하는 것을 원하지 않는다면? 
                               -> prefetch 속성값 = false로 변경하기
   
                                  ex) <Link href={'/어쩌구'} prefetch={false}>링크</Link> 
   
                        a. <Link> 태그
                            : react hooks의 useRouter()함수의 perfetch() 메서드를 사용하는 components에 해당하는 NEXT.JS의 component
                               -> perfetch()
                                   : 해당 코드가 화면에 보이는 즉시 'URL명'에 해당하는 웹페이지를 먼저 로딩하는 성능 향상을 위해 필요할 때만 동작하는 client측의 코드
                                     (= perfetch()는 클라이언트 측의 JavaScript 런타임이 처리하는 함수라는 것)
                               
                        b. perfetch()의 기능은 client 측의 JS런타임이 담당 = <Link>는 웹서버 측에서는 단순히 HTML로서의 <Link>를 랜더링만 해줄뿐
                           (= 서버측에서는 <Link> 랜더링을 다 해놓고, client측의 JS런타임이 이를 처리할 수 있게 보냄으로서, <Link> 태그 처리를 이행한다는 것)
                                -> 그래서 perfetch()를 통해, CSR 방식임에도 server component에서도 사용이 가능한 태그라는 것
                        
                        c. client측의 JS런타임은 화면에 <Link>가 보이는 상황이 감지되고, 성능적으로 필요한 상황을 감지하여 perfetch() 기능이 필요할 때 <Link> 태그에서 실행함
                            -> IntersectionObserver라는 API가 해당 기능을 담당함
                                               
            @ functional component 고유의 이벤트속성 문법 (= react 전용 JSX 이벤트헨들러 문법)
               : functional component의 HTML영역 작성시, HTML의 이벤트속성과 유사한 이벤트핸들러 문법으로 CSR방식으로 동작하는 이벤트를 작성 가능함
                  -> CSR방식으로 동작하게 설계되어 있는 문법이니, Client component에서만 사용가능
                     (= page.js 맨 위에 'use client'를 적어놔야 함) 

                (JSX 이벤트헨들러 사용법)
                  : functional component의 HTML영역 작성 중, camalCase이벤트속성명 = {콜백함수} 형식으로 이벤트 수행시 내용을 작성
                      -> 이와 component의 상태값을 관리하는 state객체와 연계되어, state객체의 변경이 감지되면 해당되는 component 부분에 한해서 비동기적으로 화면을 실시간으로 변경
                         (= 사실상 CSR방식으로 동작하는 react의 사용목적을 생각하면, 사실상 이벤트핸들러는 해당 방식으로 강제되는 셈이나 다름없음)

                          ex) onClick, onMouseOver, onChange 등등이 존재함...
                          
                             <button onClick={()=>{ 이름변경('park') }}>버튼</button> 

          2. useEffect(무명콜백함수, [component명, ...])
              : 해당 무명콜백함수의 내용에는 우선순위가 떨어지는 무거운 코드들인 'side efferct'들이 모여있고, 모든 컴포넌트들이 다 로딩된 이후를 기준으로 해당 코드들을 어떤 순서로직으로 실행할 것인지의 용도의 react hooks 함수

                ex) 보통 서버로 DB데이터 요청하는 코드도 예상 시간이 오래 걸리고, 우선순위가 떨어지는 작업이기에 useEffect를 사용함)
                     -> 하단의 코드는 count라는 component의 재랜더링에 한해서, cleanup 함수 -> 실행부 함수가 순차적으로 실행됨

                        useEffect(() => {
    
                          // 실행부 (시작때 무조건 실행)
                          console.log("useEffect");
                          const interval = setInterval(() => console.log(count), count);
                        
                          // cleanup 함수 (종료때 무조건 실행)
                          return () => {
                            clearInterval(interval);
                            console.log("clearInterval");
                          };
                        }, [count]);

               @ (참고) useEffect()를 사용하게 되면, 알아야 할 내용들

                  1) 1번째 parameter인 무명콜백함수의 return문에 위치한 무명inline함수
                      : useEffect() 함수의 뒷정리 함수인 cleanup 함수 반환
                        (= return문의 내용은 해당 component가 사라질 때(= dismount) 되었을 때 무조건 실행되는 함수)
                            <-> return 이전의 함수의 내용은 해당 component가 처음 랜더링(= mount) 되었을 때 무조건 실행

                  2) 2번째 paramter [... component명]
                      : [배열] 안에 적힌 component들이 새로고침에 따른 재랜더링(rerendering)이 일어난다면, return문의 무명inline콜백함수가 존재한다면 그것부터 시작해서 useEffect()의 콜백함수의 내용부를 수행
   
                         a. useEffect(무명콜백함수) = useEffect(무명콜백함수, [모든 component명들]) 
                             : 해당 화면이 새로고침에 따른 재랜더링(rerendering)이 일어날 때마다, return문의 무명inline콜백함수가 존재한다면 그것부터 시작해서 useEffect()의 콜백함수의 내용부를 수행
   
                         b. useEffect(무명콜백함수, [])
                             : 해당 화면이 처음으로 랜더링 될 때만, return문의 무명inline콜백함수가 존재한다면 그것부터 시작해서 useEffect()의 콜백함수의 내용부를 수행
   
                         c. useEffect(무명콜백함수, [component명 , ... ]) 
                             : 해당 화면에서 특정 component와 관련된 부분만 재랜더링(rerendering)이 일어날 때마다,  return문의 무명inline콜백함수가 존재한다면 그것부터 시작해서 useEffect()의 콜백함수의 내용부를 수행

                  3) 원칙적으로는 useEffect(콜백함수, [compoenent...])의 콜백함수 부분의 본문에는 async, await구문을 사용불가
                     (= 비동기 함수인 fetch API를 사용할 때, then, catch, finally를 사용하게 될 수 밖에 없음)
                         -> (중요) But! 이를 1번째 parameter인 무명콜백함수의 내용부{}에(그 외부 {}에서도 상관없음) async를 사용하여 내부에 비동기 함수를 쓰는 함수를 선언하고, await를 사용하여 호출하는건 가능

                            ex1) useEffect()의 1번째 paramter 내부에 async를 사용한 비동기 함수로 내용이 채워진 함수가 선언되고, 이를 바로 콜백 내부에서 호출
                        
                                 useEffect(() => {
                                     async function fetchData() {
                                         try {
                                             const response = await fetch('/api/data'); // 실제 API 엔드포인트 사용
                                             const data = await response.json();
                                             setResult(data);
                                         } catch (error) {
                                             console.error('Error fetching data:', error);
                                         }
                                     }
                                     fetchData();
                                 }, []);

                            ex2) useEffect() 외부에 async를 사용한 비동기 함수로 내용이 채워진 함수가 선언되고, 이를 바로 콜백 내부에서 호출
                        
                                 // API 호출을 통해 데이터를 가져오는 함수
                                 const fetchItems = async () => {
                                     try {
                                         const response = await fetch('https://api.example.com/items');
                                         const data = await response.json();
                                         setItems(data); // 새로운 데이터로 상태를 업데이트
                                     } catch (error) {
                                         console.error('Error fetching items:', error);
                                     }
                                 };
                             
                                 // 컴포넌트가 처음 렌더링될 때 fetchItems를 호출
                                 useEffect(() => {
                                     fetchItems();
                                 }, []); 

               @ (중요) useEffect() 함수의 component 랜더링 상황에 따른 코드 실행흐름
                  1) compoenent 처음 랜더링 시
                      : 1번째 parameter인 무명콜백함수 내용부 실행

                  2) compoenent 재랜더링 시
                      -> (주의) 재랜더링이 2번째 parameter [... component명]에 적힌 component들과 관련이 있는 경우만 실행

                      a. return문의 무명inline함수 존재
                          : 1번째 parameter인 무명콜백함수의 return의 무명inline함수 ->  1번째 parameter인 무명콜백함수 내용부 실행

                      b. return문의 무명inline함수 X
                          : 1번째 parameter인 무명콜백함수 내용부 실행

                  3) compoenent가 사라질 시
                      : 1번째 parameter인 무명콜백함수의 return의 무명inline함수 실행

          3. props/state 객체
              : CSR(client side rendering) 방식으로 component에서 새로고침되지 않고, 웹서버의 응답과 별개로 비동기적으로 통신하며 실시간으로 화면의 값을 변경하여 재랜더링 해주는데 필요한 component들의 값과 관련된 대한 객체
                (= react에서 CSR(client side rendering) 방식을 구현하는 핵심 개념이기에, server component 사용시에는 사용 불가)

             @ (중요!) CSR 방식에서의 component의 특징 (= react에서의 component의 특징)
                : 개별 component는 자신을 실시간으로 변경하고 저장하는데 있어 필요한 값들을 state라는 하나의 객체에 '캡슐화'해서 관리
                  (= 자기 {}에서만 작동하는 지역객체인 state객체를 통해, 다른 component에 영향을 주지 않고, 영향도 받지않는 폐쇄성 유지)
                      -> 다른 component에 값을 전달할 필요가 있다면? 부모 component -> 자식 component 1방향으로 props 객체로 필요한 값들을 parameter형식으로 통해 전달
                          -> (참고) But..? 자식 component도 fetch를 통해 서버에 필요한 데이터를 요청할 수 있다는 점은 편의성 증진에 도움이 됨  

             @ props 객체
                : 부모 component -> 자식 component로 연계에 필요한 값들을 보낼 목적으로 사용되는 JS객체
                   -> 자식 component에 1번째 parameter 형식으로 보내지며, {1번째parmeter명.멤버변수명} 형식으로 꺼내쓸 수 있음

                 (props 객체를 통해 자식 component에 값을 전달하는 법)
                  a. (중요) CSR방식으로 동작하는 기능의 코드를 짜는 것이므로, 'use client'; 를 작성
                  b. 부모 component의 HTML 반환값 부분에 가서 <자식component명 = {전해줄데이터} or "원시값" /> 이런식으로 작성
                  c. 자식 component의 함수 정의 영역으로 가서 props라는 parameter를 등록 후 {props.멤버변수명} 이런식으로 호출 

                     ex) props 객체에 '상품'이란 멤버변수를 담아 CartItem 컴포넌트로 보내면, 해당 컴포넌트는 'props.상품'으로 해당 값을 꺼내쓸 수 있음

                         export default function Cart() {
                           let 장바구니 = ['Tomatoes', 'Pasta']
                           return (
                             <div>
                               <h4>Cart</h4>
                               <CartItem 상품={장바구니[0]}/>
                               <CartItem 상품={장바구니[1]}/>
                             </div>
                           )
                         }
                         
                         function CartItem(props){
                           return(
                             <div className="cart-item">
                               <p>{props.상품}</p>
                             </div>
                           )
                         }  

                 (props 객체 주의사항) 
                   a. 오직 부모 component-> 자식 component 간 1방향 전송만 가능
                      (= '자식 -> 부모' or '형제간 전송' or '선조 -> X대' 직계 전달 다 해당 안 됨)

                   b. X대 자손 component에 선조 component가 props객체를 보내려면, 귀찮아도 X번 props객체를 통해 값을 되물림해야 함

                   c. props 객체로 부모 component가 보낼수 있는 멤버변수의 갯수는 제한X
                     
                      ex) <CartItem 이런거={이런거}  저런거={저런거} ..... 캡틴={하루종일도가능해}> 이렇게 많이 전송 가능

                   d. props객체 : functional component = parameter : function 의 관계라는 점은 중복의 최소화를 유도 가능

             @ state 객체
                : component를 구성하는 값들을 관리하는 객체
                   -> 실시간으로 state 객체값의 변동이 감시되면? 변화한 state변수를 사용하는 component에 한해서만, 서버의 응답과 상관없이 먼저 비동기적으로 재랜더링을 해줘서 사용자 경험을 높히는 핵심 JS객체
                
                 (state 객체에 멤버변수를 선언하고 초기화하고, setter함수 선언하기)
                   a. (중요) CSR방식으로 동작하는 기능의 코드를 짜는 것이므로, 'use client'; 를 작성
                   b. 상단에 import {useState} from 'react'를 작성해서 import 준비
                   c. (중요) react 18버전 이후, state객체에 멤버변수와 setter함수를 선언할 때는 useState(초기값)함수로 구조분해 할당 문법을 사용함
                        -> useState(초기값) 함수는 [어떤 state의 초기값, 해당 state의 setter함수]를 반환하는데, 이를 구조분해구문을 통해 각각 [state변수명, 해당setter함수명]에 대입

                           ex) let [state멤버변수명, 해당setter함수명] = useState(초기화값 or [초기화배열] or {초기화 객체} );

                   d. 해당 state객체가 속한 component의 HTML 반환값 부분에 가서, {state멤버변수명}으로 해당 state객체멤버값이 위치할 곳을 정해주고, 이벤트핸들러의 {콜백함수}의 내용에 {해당setter함수명(값)}을 넣어줘서 setter사용
                      (= setter함수가 존재하는 JSX 이벤트핸들러가 작동하는 순간, 해당 state객체변수를 사용하는 component의 부분에 한해서만 바로 재랜더링이 완료됨)

                      ex) 'use client';
                          import { useState } from 'react'
                          
                          export default function List() {
                          
                              let [수량, 수량변경] = useState([0, 0, 0]);
                          
                              return (
                                  <div> 
                                      <h4 className="title">상품목록</h4>
                                        <div className="food" key={인덱스}> 
                                            <button onClick = { () => { 
                                                let copy = [...수량];
                                                copy[인덱스]--;
                                                copy[인덱스] < 0 ? null : 수량변경(copy) } }>-</button>
                                        </div>
                                  </div>
                              );
                          }


                 (state 객체 사용시 주의사항) 
                   a. 'state멤버변수명' 변수의 초기값은 useState의 parameter에 넣은대로고, 해당 멤버변수를 수정하고 싶으면 '해당setter함수명(수정값)'을 기입하면 됨
                      
                      ex) '이름'이란 state멤버변수의 초기값은 'kim'이고, 이를 바꾸려면 '이름변경('변경 이름')'을 호출하여 HTML 영역에 채움
                      
                          let [이름, 이름변경] = useState('kim');

                          <h4>{이름}</h4>
                          <button onClick={()=>{ 이름변경('park') }}>버튼</button> 

                   b. state멤버변수를 만드는 이유는 서버에 변경된 값을 전하는 것과 별개로 state객체의 멤버변수의 변화가 감지되면 실시간으로 비동기적 랜더링 로직이 해당 state변수를 사용하는 부분에 한해서만 작동
                      (= CSR의 목적 자체가 사용자의 웹서비스 경험을 증진시키는데 있음)
                          -> But.. 그런만큼 모든 변수를 다 state변수로 처리하면, 그건 자원낭비와 성능의 저하로 이어진다는걸 기억하자

                   c. useState(초기값) 함수의 초기값 부분에는 여러 변수의 값이 들어있는 [배열] 기입이 가능함
                       -> BUT! 해당setter함수명()을 통해 state객체의 멤버변수값의 변화는 '부분적인 요소값'은 안 되고, [배열] 전체를 바꿔야 변경됨
                          (= 배열명.map(콜백함수)를 통해, 데이터들의 반복적인 부분을 component로 작성해도 setter함수(배열명[인덱스]) 이런식으로 써봐야 해당 부분의 state객체의 멤버배열요소가 수정되지 않음)

                          ex) 초기값이 [배열]인데 setter함수에 paramter로 배열요소를 지정해봐야 수정은 일어나지 않음
                          
                              let [이름, 이름변경] = useState(['Tomatoes', 'Pasta', 'Coconut']);

                              <button onClick={()=>{ let copy = 이름[인덱스]
                                                      copy[0]++
                                                      수량변경(copy)
                                                     }}>+</button>

                   d. '해당setter함수명(수정값)'를 호출하면, 반환된  기존state객체값 === 신규state객체값인지 확인 후, 같은게 확인되어 component에 재랜더링할 부분이 없다면 굳이 새로 랜더링하지 않음
                       -> (중요) c의 경우와 같이 state객체변수 = [배열]이 초기값이면, [배열]이 참조 자료형인걸 모르고 '깊은 복사'를 안하고 '얕은 복사'를 하는 경우 당황하기 마련인데 그러지 말자

                          ex) 참조 자료형을 '얕은복사' 하는 예시
                               -> [1,2,3]이 위치한 주소값을 저장하는 arr을 arr2에 대입하면, 둘은 사실상 같은 값을 공유하는 셈

                              let arr = [1,2,3]
                              let arr2 = arr
                              arr2[0]++
                              console.log(arr2 == arr)

                          ex) state객체변수값을 '얕은복사(shallow copy)' 한 뒤 수정하면?
                               -> 'copy'와 '수량' 변수는 사실상 같은 값을 공유함 

                              let copy = 수량
                              수량[0]++
                              수량변경(copy)      <-  state변경함수를 써도 기존state == 신규state라서 state변경을 안해 줌

                   e. (c, d의 사례가 있기에) state객체변수의 초기값으로 [배열]을 둔 경우, 해당 [배열]을 수정하고 이를 component 재랜더링까지 가게하기 위해서는?
                       -> 이벤트헨들러의 콜백함수의 내용 영역에 [배열]값을 spread operator문법( [...], {...} )을 통한 '깊은복사'를 한 뒤에 setter함수를 사용하자
                           -> (참고) spread operator문법( [...], {...} )
                                : 대상 변수가 가리키는 메모리 영역에 위치한 컨테이너 데이터의 캡슐화를 해제하고 개별 데이터들을 각각 다른 영역에 복사한 뒤, 이들을 다시 독립적인 컨테이너 자료형으로 캡슐화하고 그 포인터값을 참조로 반환하라는 이야기

                          ex) 참조 자료형을 spread operator문법( [...], {...} )을 통해 '깊은복사(deep copy)' 하는 예시
                               -> spread operator문법( [...], {...} )를 통해 요소나 멤버의 값 자체가 복사된 컨테이너 데이터는 원본 컨테이너 데이터와 완전히 독립적인 데이터

                              let arr = [1,2,3]
                              let arr2 = [...arr]
                              console.log(arr2 == arr);  // false

                              let obj = {멤버1 : a, 멤버2 : b}
                              let obj2 = {...obj}
                              console.log(obj2 == obj);  // false

                          ex) state객체변수값을 spread operator문법( [...], {...} )을 통해 '깊은복사' 한 뒤 수정하고, setter함수를 통해 수정하면
                               -> 'copy'와 '수량' 변수는 아예 각각 다른 [배열]을 참조하고 있기에, '수량' 변수의 [배열]이 수정되고, 이것이 setter함수에 들어가면 state객체값인 [배열]이 다른 것으로 확인되어 state객체가 변하고 화면의 재랜더링이 이뤄짐

                              let copy = 수량
                              수량[인덱스]++
                              수량변경(copy)      <-  수량 != copy라서 다른 배열값으로 판정되어 state변경을 이행하여 component 영역의 변경된 부분에 재랜더링이 일어남

          4. '배열명.map( (요소값, 인덱스) => { 요소값, 인덱스 사용 내용 return 문 } )' 함수를 통해, functional component의 return값을 반환하는 HTML 안에서 반복문 사용 가능!
               -> js에도 배열명.map이 있고, JSX에도 있지만, 반환되는 HTML 내부에는 JSX의 map구문이 사용된다고 보면 됨

             @ 왜 for, if문을 문법 안 쓰나?
                : JSX의 functional component의 return값을 반환하는 HTML 안에는 for, if문(그 대신 '조건문 ? 참 : 거짓'의 '삼항연산자'를 사용)을 문법을 사용할 수 없음
                  (= return값을 반환하는 HTML밖에서는 얼마든지 JS의 문법을 사용해도 전혀 문제가 없음)

             @ (주의) 배열명.map( (요소값, 인덱스) => { 요소값, 인덱스 사용 내용 return 문 } ) 사용시 주의사항
             
                1) JSX 문법으로서 배열명.map(콜백함수) 함수를 쓰고 싶다면, component의 HTML layout의 반환문 내에 {}를 적고 그 안에 작성하면 됨       
                2) (중요) map(콜백함수) 함수는 parameter인 콜백함수를 통해 요소값, 인덱스를 사용하여 순차적으로 반환된 요소를 통한 배열을 반환함

                    ex) console.log(newArray); 로 [20, 30, 40] 반환
                    
                        var 어레이 = [2,3,4];
                        var newArray = 어레이.map((a)=>{
                          return a * 10
                        });
                        
                3) return문은 필수는 아니나, 이게 없으면 map(콜백함수)함수를 통해 가공하여 생성되는 배열은 없음 
                   (= 연산은 해주기에 console.log 같은거로 값을 보여는 주지만, 함수 {}를 넘어가면 거기서 끝이라는 이야기)

                    ex) return이 없어서 console.log(newArray); 해봐야 빈 배열 반환
                    
                        var 어레이 = [2,3,4];
                        var newArray = 어레이.map((a)=>{
                          a * 10
                        });

                4) 배열명.map(콜백함수)함수의 콜백함수의 1번째 parameter는 뭘 넣어도 각 '배열요소의 값'이며, 2번째 parameter는 뭘 넣어도 각 '배열의 인덱스'를 의미
                    -> (참고) 이 parameter들은 콜백함수 작성시 없어도 됨 (= 얘들이랑 관계없는 값을 반환해도 된다는 것)

                    ex) return이 없어서 console.log(newArray); 해봐야 [10, 10, 10] 배열 반환
                    
                        var 어레이 = [2,3,4];
                        var newArray = 어레이.map((a, i)=>{
                          return 10
                        });

                5) return값으로 component의 HTML layout을 반환해도 react는 JSX 형식으로 작성된 component를 잘 파싱하고 rendering함  
                    -> (참고) 배열명.map(콜백함수)를 사용 시, 각 반복된 component를 구분하기 위해 react는 고유값으로 key 속성을 넣을 것을 권장하는데, 보통은 index값을 넣음                  

                        ex) [ <div></div>, <div></div>, <div></div> ] 이런 구조의 배열이 반환되고, 이것이 List라는 component의 일부로서 반환되고 rendering 됨
                        
                            export default function List() {
                            
                                let 상품 = ['Tomatoes', 'Pasta', 'Coconut'];
                            
                                return (
                                    <div> 
                                    <h4 className="title">상품목록</h4>
                                    { 
                                        상품.map((개별상품)=>{
                                            return ( 
                                                <div className="food" key={인덱스}> 
                                                    <h4>{ 개별상품 } $40</h4>
                                                </div>
                                            )
                                        })
                                    }
                                    </div>
                                );
                            }

                6) JS의 for문으로 이를 구현하고 싶다면?
                    : HTML영역 바깥쪽에서 array를 for문을 통해 만들고, 이를 JSX의 배열명.map(콜백함수)를 통해 rendering 할 수 밖에 없음 
                       -> 다른 내용을 다루지만, 대상 배열과 같은 수의 index를 가지고, 대상 배열의 요소 값을 입력 가능하면 더 좋음

                           ex) 상품 문자의 갯수가 가격과 연관된 경우의 구현
                           
                               export default function List() {

                                   let 상품 = ['Tomatoes', 'Pasta', 'Coconut'];
                                   let 가격 = [];
                               
                                   for(var i = 0; i < 상품.length; i++){
                                     가격[i] = 상품[i].length * 10;
                                   }
                               
                                   return (
                                       <div> 
                                       <h4 className="title">상품목록</h4>
                                       { 
                                           상품.map((개별상품, 인덱스)=>{
                                               return ( 
                                                   <div className="food"> 
                                                       <h4>{ 상품[인덱스] } $ { 가격[인덱스] }</h4>
                                                   </div>
                                               )
                                           })
                                       }
                                       </div>
                                   );
                               }


    # Next.js의 URL에 따른 웹페이지 자동 라우팅(auto routing) 기능 구현법

      1. app 폴더 내부에 폴더를 하나 만들고 작명

      2. (중요) 원하는 폴더 내부에 page.js 파일을 생성하고, 그 파일 내부에 component를 이루는 html 레이아웃을 반환값으로 가지는 functional component 작성
          -> 1) functional component는 무조건 작성해야 하며, 함수명은 맘대로 작명 가능하나, 보통 폴더명이랑 비슷하게 함
             2) (참고) 새로고침없이 부드럽게 페이지 이동이 가능한 react의 CSR 방식의 Routing기능을 만들고 싶다면?
                 : component 반환값 html 레이아웃을 작성시, <a>태그 대신 Link를 import하고 대신 쓰면 됨

                   ex) import Link from "next/link";
                       import './globals.css';
                       
                       export default function RootLayout({ children }) {
                         return (
                           <html lang="en">
                             <head />
                             <body>
                               <div className="navbar">
                                 <Link href="/">Home</Link>
                                 <Link href="/list">List</Link>
                               </div>
                               {children}
                             </body>
                           </html>
                         )
                       }

      3. '도메인/폴더명'을 url로 작성하면, 해당 웹페이지 출력 완료
          -> (참고) '/app/폴더1/폴더2/page.js' 이런식으로 page.js를 형성하면, '도메인/폴더1/폴더2'를 url로 입력하면 해당 page.js 출력 가능 

        @ 웹페이지 Routing 기능
           : url로 웹페이지를 나누고, 사용자의 url명 호출에 따라 웹서버던 클라이언트 측이건 다른 웹페이지를 보여주는 기능

        @ 일반적인 Routing 기능 구현 방식
           : 특정 url을 사용자가 입력하고, 어디에 위치하는 어떤 파일명에 해당하는 HMTL을 보여줄지를 구체적으로 지시
             (= 그러니까, 참 사용자를 귀찮게 한다 이거임) 
                 -> BUT! Next.JS 에서는 사용자를 아주 편하게 만들어 줌 ㅇㅇ
  
                    ex) '도메인/list'라는 url을 사용자가 호출하면, /app/list/에 위치한 '상품목록.js'을 rendering 해주세요 로직

      4. 동적 라우트(dynamic route) 기능
          : '폴더위치 = url' 구조로 치환되는 Next.JS에서 '특정 데이터의 상세페이지'처럼 url이 '도메인/폴더명/pk값'과 같은 URL을 Next.JS의 방식으로도 라우팅을 구현할 수 있도록 지원하는 기능
      
        @ dynamic route를 지원하는 폴더와 page.js파일, 그리고 component 만드는 법

           1) 폴더 or 파일을 만들 때 []을 씌우기
              (= '이 부분에 해당하는 URL에는 아무거나 입력하면 됨'과 같은 의미)
                   -> (중요!) 이렇게 구성해놓으면, []부분에 해당하는 수많은 폴더들을 직접 만들 필요가 없음

              ex) [폴더명]
                    -> 예를 들어, '/photo/[폴더명]/page.js'에 해당하는 웹페이지를 호출하려면, 'https://도메인/photo/아무문자'로 URL을 입력하면, 웹서버가 아무문자에 해당하는 부분의 정보를 잘 URL parameter로 받아서 원하는 데이터를 가져와서 페이지를 랜더링해줌

              ex) [페이지명],js
                    -> 예를 들어, '/photo/[폴더명].js'에 해당하는 웹페이지를 호출하려면, 'https://도메인/photo/아무문자'로 URL을 입력하면, 웹서버가 아무문자에 해당하는 부분의 정보를 잘 URL parameter로 받아서 원하는 데이터를 가져와서 페이지를 랜더링해줌

           2) dynamnic route에 해당하는 URL요청에 웹서버가 응답하여 랜더링(rendering)을 할 대상인 page.js를 생성하고, 해당하는 functional component를 작성함
               -> (중요) dynamic route의 [폴더명]에 해당하는 URL parameter에 해당하는 부분을 가져오고 싶으면?
                    : page.js의 functional component의 parameter 기입 항목에 props를 작성하고, component {}안에 'props.params.원하는parameter명' 출력하면 됨

                      ex) '/app/detail/[id]/page.js'에 해당하는 파일 경로을 통해, Next.JS는 해당 component를 'https://도메인/detail/id명'이란 URL에서 id명에 따른 동적 라우트(dynamnic route)를 쓰는 component로 인식
                            -> 'https://도메인/detail/id명'의 'id명'은 [id]폴더에 대응되며, 'props.params.id'로 꺼내쓸 수 있음
                                (= 페이지 redirect시 입력된 id명에 해당하는 값의 전달은 props객체를 통한 부모 - 자식 간의 값 교환으로 구현)

                                import { ObjectId } from "mongodb";
                                import { connectDB } from "@/util/database.js"
                                
                                export default async function Detail(props) {
                                    let db = (await connectDB).db('forum')
                                    let result = await db.collection('post').findOne({_id : new ObjectId(props.params.id)});
                                
                                    return (
                                      <div>
                                          <h4>상세페이지임</h4>
                                          <h4>{result.title}</h4>
                                          <p>{result.content}</p>
                                      </div>
                                    )
                                }


    # Next.JS의 navigation모듈
       : navigation 모듈을 통해 Next.JS는 React hooks 함수 중 useRouter, usePathname, useSearchParams, useParam를 사용할 수 있게 해줌
         (= 이를 통해, NestJS에서도 CSR방식의 페이지 간 다용도의 route 기능을 쉽게 구현하게 하는 useRouter나, URL과 연관된 각 정보들의 Getter함수에 해당하는 usePathname, useSearchParams, useParam을 사용할 수 있게 됨)
             -> a태그에 해당하는 <Link> 태그나 window.location.href 속성값을 변경시키는 이벤트핸들러를 제작하지 않더라도, CSR방식으로 웹페이지간 이동이 가능함
                (= react 라이브러리의 기능을 사용하니, Virtual DOM을 통한 효율적 화면 전환에 해당하는 로직이 내장되어 있음을 알 수 있음)

        @ (중요) navigation모듈 사용시 주의사항
           : react hooks에 해당하는 기능 = 'use client'를 써서 client component로 작성했을 때, 제대로 작동하게 되어있음

        @ navigation 모듈의 react hooks 함수들

           1. useRouter()
               : 손쉽게 웹페이지 간 route 기능을 수행해줄 수 있는 react의 router 관련 JSX객체를 생성해주는 JSX함수
                 (= react 라이브러리의 기능을 사용하니, Virtual DOM을 통한 효율적 화면 전환에 해당하는 로직이 내장되어 있음을 알 수 있음)
                   -> 추후 해당 JSX객체의 메서드( push(url명), back(), forward(), refresh(), perfetch(url명) )들을 실행

                      ex) useRouter()를 통한 기능 예시코드
                      
                          'use client'

                          import { useRouter } from "next/navigation"
                          
                          export default function DetailLink(){
                              let router = useRouter();
                              return(
                                  <div>
                                      <button onClick={()=> { router.back() } }>뒤로가기</button>
                                      <button onClick={()=> { router.forward() } }>앞으로가기</button>
                                      <button onClick={()=> { router.refresh() } }>react식 새로고침</button>
                                      <button onClick={()=> { router.push('/write') } }>글쓰기</button>
                                      <button onClick={()=> { router.prefetch('/practice') } }>임시 회원가입</button>
                                  </div>
                              )
                          }
 
                      1) useRouter().back()
                          : 현재 페이지를 기준으로 '뒤로가기' 기능을 CSR방식으로 수행
                           
                            ex) <button onClick={()=>{ router.back() }}>버튼</button> 
 
                      2) useRouter().forward()
                          : 현재 페이지를 기준으로 '앞으로가기' 기능을 CSR방식으로 수행

                            ex) <button onClick={()=>{ router.forward() }}>버튼</button> 

                      3) useRouter().refresh()
                          : 현재 페이지를 기준으로 '새로고침' 기능을 CSR방식으로 수행
                             -> Virtual DOM을 사용한 로직을 통해, 이전과 바뀐점을 분석해서 바뀐부분만 새로고침하는 soft refresh 사용

                                ex) <button onClick={()=> { router.refresh() } }>react식 새로고침</button>
 
                      4) useRouter().push(url명)
                          : react 라이브러리를 통한 CSR 방식의 route 기능을 수행하여, 작성한 url명에 해당하는 웹페이지로 이동이 가능해짐
                             -> Virtual DOM을 사용한 로직을 통해, 변경된 요소만 변경

                                ex) <button onClick={()=> { router.push('/write') } }>글쓰기</button>

                      5) useRouter().perfetch(url명)
                          : 해당 메서드가 화면에 보이게 된다면, 해당 url의 페이지에 해당하는 내용을 미리 로드하여 사용자가 이를 클릭시 하여금 빠르게 방문이 가능해짐
                            (= react hooks의 component가 렌더링된 후에 component의 생애상태에 따라 실행되는 사이드 이펙트 코드들을 처리하는 useEffect와 연관)

                            ex) import { useEffect } from 'react';
                                import { useRouter } from 'next/router';
                                
                                export default function MyComponent() {
                                    const router = useRouter();
                                
                                    useEffect(() => {
                                        router.prefetch('/some-page');
                                    }, []); // 빈 배열을 사용하여 컴포넌트가 마운트될 때 한 번만 실행
                                
                                    return <div>My Component</div>;
                                }
                          
                             -> (perfetch 참고사항)
                                  a. 링크가 많은 게시판의 경우 모든 링크를 다 읽을게 아니기에, 이를 사용하여 굳이 모든걸 미리 로드하는건 자원낭비기에 상황 봐가며 사용해야 함
                                  b. server component의 <Link> 태그 또한 perfetch 메서드처럼 해당 코드가 화면에 보이는 즉시 'URL명'에 해당하는 웹페이지를 먼저 로딩
                                     ( <Link> 태그는 서버에서는 랜더링만 해주고, client 측의 JS런타임에서 useRouter().perfetch()에 해당하는 기능을 수행가능하기에 CSR임에도 server component 환경에서 쓸수 있게 설계됨 )
                                  c. 만약 <Link> 태그가 보이면, URL에 해당하는 페이지를 미리 로딩해주는 prefetch() 기능을 써서 CSR방식으로 동작하는 것을 원하지 않는다면? 
                                       -> prefetch 속성값 = false로 변경하기
                                          (자세한 내용은 <Link> 부분에서 참고)

                                          ex) <Link href={'/어쩌구'} prefetch={false}>링크</Link> 

           2. usePathname()
               : 현재 URL 출력해주는 Getter 함수

           3. useSearchParams()
               : 현재 URL의 search parameter (query string)에 해당하는 부분 출력해주는 Getter 함수

           4. useParams()
               : 현재 URL의 [dynamic route] 부분에 해당하는 URL 파라미터를 부분 출력해주는 Getter에 해당하는 함수

                 ex) usePathname(),  useSearchParams(), useParams()를 통한 기능 예시코드
                      : 이들의 의의는 복잡하게 window 객체를 통하지 않더라도, URL정보를 도출이 가능하다는거 

                        import {usePathname, useSearchParams, useParams} from 'next/navigation'
                        
                        export default function DetailLink(){
                          let a = usePathname()
                          let b = useSearchParams()
                          let c = useParams()
                          console.log(a)
                        }


    # (layout.js 사용) Next.JS에서 간 공용으로 사용하는 component 공용 layout 만드는 과정 (ex : 상단 navigation) 
       : Next.js는 page.js를 보여줄 때, 그 옆에 layout.js 파일이 있으면 layout.js 내용 안에 page.js 내용을 담아서 보여줌
         (= url과 매칭되는 위치의 layout.js를 기준, 가장 안쪽 폴더의 layout은 가장 먼저 적용, app폴더의 layout은 가장 나중에 적용)

          1. 원하는 url의 component에 해당하는 page.js가 위치하는 곳을 가장 바깥 layout으로 간주하고, 단계별로 layout.js 생성
              -> (중요) js의 이벤트버블링이 작동하는 방식과 유사함을 명심하자... 대상 page.js 자기가 닿지 못한 폴더의 layout.js는 적용 못한다고 생각하면 이해가 편함

              @ app 폴더의 layout.js
                 : 가장 나중에 적용될 layout
                   (= app 폴더를 기준으로 layout.js는 모든 하위 웹페이지들에 모두 적용됨)

                   ex) <head> 태그의 내용들을 여기다 담기도 함 

              @ url과 폴더구조를 기준으로 가장 안쪽부터 바깥쪽인 app 폴더로 올라오는 layout.js들
                 : 가장 안쪽의 layout.js는 가장 먼저 적용될 layout에 적용될 layout

          2. 각 layout.js의 functional component에 해당하는 RootLayout({ children }) 함수의 return영역에 html 레이아웃을 작성하면 됨
      
             ex) import Link from "next/link";
                 import './globals.css';
                 
                 export default function RootLayout({ children }) {
                   return (
                     <html lang="en">
                       <head />
                       <body>
                         <div className="navbar">
                           <Link href="/">Home</Link>
                           <Link href="/list">List</Link>
                         </div>
                         {children}
                       </body>
                     </html>
                   )
                 }

          3. global.css에 style 작성하면 끝
 
 
     # Next.js의 유틸리티성 페이지 loading.js, error.js, not-found.js
        : 웹페이지 이동 및 component 재랜더링(re-rendering)시 오류가 나거나 로딩 중인 상태가 감지될 때, 보여주는 compoenent에 해당하는 페이지들

         @ 유틸리티성 페이지 없이 해당 페이지들을 구현하고 싶다면?
            : 현재 페이지의 상태처리 값을 얻은 뒤, 그걸로 조건문 처리를 하거나... 아니면 try ~ catch로 덮는 방식이 존재

         @ 특이사항 (= 편의성)
            : 해당 페이지들이 필요할 때, 현재 페이지(page.js)가 위치한 폴더를 기준으로 해당 파일들이 있는지를 찾아보고, 없으면 app폴더를 향해 상위로 타고 올라가서 찾는 방식
              (= layout.js의 작동방식과 마찬가지라서, 특별한 페이지나 component가 아니면, 그냥 최상위 폴더인 app폴더에 만들어두면 됨)
                  -> (결론) 그러니까, 태그를 일일히 안 만들어도 된다는 의미

         @ 유틸리티성 페이지
            1. loading.js
                : component 이동이나 재랜더링(re-rendering) 과정에서 로딩 상황에 보여주는 component에 해당하는 페이지
                  
               (loading.js 사용법)
                 : 현재 page.js를 기준으로 '해당 파일이 위치한 폴더 ~ 최상위 app 폴더'에 loading.js를 만들어두고, component의 내용을 입력
                    -> 그렇게 작성해두면, 어떤 component가 로딩 중이라 필요할 때 해당 component의 위치를 기준으로 파일찾는 로직을 통해 loading.js를 찾아서 적용함 

                       ex) loading.js에 이런 식으로 component를 작성하면, 위치만 제대로 놓으면 로딩 중이라 필요할 때 알아서 찾아서 얘를 띄어줌 
                       
                           export default function Loading() {
                             return <h4>로딩중임</h4>
                           } 

               (loading.js 특이사항)
                 : loading.js의 해당 component가 server component인지 client component인지 상관하지 않으니 편한데로 써도 됨
                    -> 로딩은 server에서 랜더링된 페이지를 받는거나, client측에서 랜더링을 하는거나 어디서나 발생 가능하기 때문이라 추론

               (loading.js의 기술적 기원)
                 : react 라이브러리에도 목표 component들에 <Suspense> 라는 태그를 감싸는 형식으로 비슷한 기능을 지원
                    -> fallback이란 JSX속성에 내용을 입력하면, 해당 내용을 loading중 때 출력
                       (= fallback JSX속성값 = loading.js의 compoenent 내용)
                   
                    ex) react에서 사용 (상단의 예시의 Next.js에서는 해당 코드를 loading.js로 치환해서 동작하게 했다 보면 됨)

                         <Suspense fallback={<h4>로딩중</h4>}>
                           <app/>
                         </Suspense>

            2. error.js
                : component 이동이나 재랜더링(re-rendering) 과정에서 에러(error) 상황에 보여주는 component에 해당하는 CSR방식으로 동작하는 페이지
                  (= CSR방식이기에 client component를 사용하여 동작... use client를 반드시 써줄 것)
                  
               (error.js 사용법)
                 : 현재 page.js를 기준으로 '해당 파일이 위치한 폴더 ~ 최상위 app 폴더'에 error.js를 만들어두고, 'use client'를 상단에 작성하여 CSR방식의 component의 내용을 입력
                    -> 그렇게 작성해두면, 어떤 component가 에러라서 필요할 때 해당 component의 위치를 기준으로 파일찾는 로직을 통해 error.js를 찾아서 적용함 

                       ex) error.js에 이런 식으로 component를 작성하면, 위치만 제대로 놓으면 에러 중이라 필요할 때 알아서 찾아서 얘를 띄어줌 
                       
                           export default function Error({error, reset}){
                             return (
                               <div>
                                 <h4>오 이런 에러남</h4>
                                 <button onClick={()=>{ reset() }}>다시시도</button>
                               </div>
                             )
                           }

               (error.js 특이사항)
                 1) error.js의 해당 component는 반드시 clinet component 형식으로 작성되어야 하기에, use client를 반드시 써줘야 함
                    (= error.js는 출력시, VDOM 로직을 통해 page.js 부분의 compoenent 자리에 error.js의 component 내용이 재랜더링 되는 방식임을 알 수 있음)
                        -> error가 난다는 건, server와 연결이 끊길수도 있다는걸 의미하기에, 보수적으로는 유저 브라우저에서 처리가능한 CSR방식을 쓰는게 나음

                 2) component 작성시 props 객체에 해당하는 parameter를 작성하면, 해당 component 출력시 자동으로 error와 reset이란 props 요소를 받아오게 됨

                     - error
                        : error의 내용을 알려주는 props 객체의 요소 

                     - reset 
                        : 해당 페이지(page.js)를 다시 로드해주는 함수인 reset()을 사용하도록 해주는 props 객체의 요소
                          (함수 포인터나 표현식을 담은 변수를 가져왔다고 추론)

                 3) (중요!) global-error.js
                      : app폴더에 위치한 최상위 layout.js는 상위폴더라는게 존재하지 않아서, 에러가 났을 때 이를 대처하기 위해서는 app폴더에 global-error.js를 만들어두면 됨

                        ex) 마찬가지로 client compoenent에 error.js와 모든것을 공유하니, 내용은 원하는대로 작성하면 됨

                            'use client'

                            export default function Error({error, reset}){
                              return (
                                <div>
                                  <h4>오 이런 에러남</h4>
                                  <button onClick={()=>{ reset() }}>다시시도</button>
                                </div>
                              )
                            }

               (error.js의 기술적 내용)
                 : layout.js의 에러시에는 해당 파일의 상위폴더를 시작점으로 error.js를 찾음 
                    -> Next.js는 페이지를 만들 때, 같은 폴더의 component 서열을 <layout> - <error> - <loading> - <page> 같이 정하고 랜더링 하기 때문 
                  
                    ex) <Layout>이 가장 상위 component라... 같은 폴더의 Layout.js는 Error.js의 영향을 1도 받지 않음
                        (= 상위폴더의 error.js를 찾을 수 밖에 업음)

                        <Layout>
                          <Error fallback={자식들 내용이 에러시 보여줄 error.js 내용}>
                            <Loading fallback={자식들 내용이 로딩시 보여줄 loading.js 내용}>
                              page.js 내용~~
                            </Loading>
                          </Error>
                        </Layout>

            3. not-found.js
                : routing을 하여 웹서버에 없는 URL로 API를 호출했을 경우에, HTTP status가 404상태라서 해당하는 페이지가 없음을 알려주는 용도의 404페이지
                   -> loading.js, error.js와 다르게, notFound()라는 Next.js의 routing 관련 라이브러리인 navigation 모듈을 사용하여 임의로 호출도 가능

               (not-found.js 사용법)

                 1) 현재 page.js를 기준으로 '해당 파일이 위치한 폴더 ~ 최상위 app 폴더'에 not-found.js를 만들어두고, component의 내용을 입력
                    -> 그렇게 작성해두면, 추후 어떤 component가 404상태여서 필요할 때 해당 component의 위치를 기준으로 파일찾는 로직을 통해 not-found.js를 찾아서 적용함 

                       ex) not-found.js에 이런 식으로 component를 작성하면, 위치만 제대로 놓으면 에러 중이라 필요할 때 알아서 찾아서 얘를 띄어줌 
                       
                           export default function NotFound(){
                             return <h4>404 에러임 그건 없는 페이지인데요</h4>
                           } 

                 2) 만약 특정 상황에서 404페이지에 해당하는 component not-found.js를 보여주고 싶은 경우에는 조건문을 통해 notFound() 라는 함수를 실행

                    ex) DB로부터 불러온 데이터가 없는경우? 빈 페이지보단 404를 보여주고 싶은 경우... 조건문으로 notFound() 함수를 호출하게 가능
                    
                        import { notFound } from "next/navigation"

                        export default async function Detail(props){
                          const db = (await connectDB).db('forum')
                          let result = await db.collection('post').findOne({ _id: new ObjectId(props.params.id) })
                          
                          if (result == null) {
                            return notFound()
                          } else {
                            return (상세페이지)
                          }
                        
                        }

     # Next.js에서 이미지를 넣는 방법론 2가지

        1. JSX형식에 이미지 넣는 일반적인 방식 
            : <img src="/port1.png" alt="설명"/> 형식으로 img태그 삽입

          @ <img> 태그 사용시 주의사항
             1) 그냥 html 파일에선 <img> 이렇게 단독으로 써도 되지만, react에서 참고하는 JSX에선 <img></img> 이렇게 쓰거나 <img />로 반드시 태그를 받아줘야 작동함
             2) public 폴더에 있는 것들은 사이트 발행시 자동으로 사이트 root 경로로 이동함
                (= src 속성에 이미지 위치나 주소를 입력할 때, 가급적 public 폴더에 이미지를 넣으면 여러모로 쉬워짐)

        2. Next.js가 지원하는 성능과 속도 측면에서 최적화된 이미지 넣는 법 
            : <Image>라는 Next.js가 지원하는 모듈을 통해 고유의 태그를 사용

              @ <Image> 태그 장점
                  1) 이미지가 늦게 뜨는 lazy loading 방지
                      -> (참고) lazy loading 기능만 원하면 다른 라이브러리 찾아봐도 됨
                  2) 이미지가 늦게 뜰 시, 그 시간동안 화면구조가 지멋대로 변경되는 layout shift 방지
                  3) 사이즈 최적화에 유용함
                      -> (중요!) 최적화는 사이트 다 만들고나서 하는게 좋은 관습이니, 초장부터 여기 집중할 필요 없음

              @ (참고) <Image> 단점
                  1) map(콜백함수)를 통한 반복문 처리시, 다른 이미지 보여주기 좀 난감
                      -> 이미지 주소가 index랑 관계없는 무작위인 경우, src 속성값에 require 같은 함수를 이용해야 할 때도 있음

                  2) 외부 이미지 넣는 조건이 좀 많아서 귀찮음

              @ <Image> 태그 사용 방법
                 1) Image라는 변수로 Next.js의 image 모듈을 import 문법으로 상단에 추가
                     : import Image from 'next/image'

                 2) 넣고 싶은 이미지 또한 상단에 import 문법으로 상단에 모듈로서 추가
                     : import 이미지명 from '이미지경로명(현재 위치 기준)'
                        -> (참고) ''를 쓰기 싫으면 @이미지경로명을 써도 됨

                           ex) import Image from 'next/image'
                               import 이미지 from @./food0.png
                               
                               export default function Home() {
                                 return(
                                   <div>
                                     <Image src={이미지} alt="설명"/>
                                   <div/>
                               )} 

              @ 만약 <Image> 태그로 타 웹페이지의 이미지를 절대경로로 집어넣고 싶다면?
                  -> (결론) 여러모로 귀찮으니, 이럴 때는 img태그 대충 사용하도록 하자

                      1) <Image> 태그 안에 width, height 속성을 집어넣어야 함
                          -> (대안) <Image> 태그 안에 fill="true" 이거 대신 넣고, 부모 <div>가 width, height를 대신 조절

                             ex) import Image from 'next/image'

                                 export default function Home() {
                                   return(
                                     <div width="500" height="500">
                                       <Image src="https://placehold.co/500" fill="true" />
                                     <div/>
                                 )} 

                      2) next.config.js에 images 관련 세팅이 추가로 필요함

                         ex) 이런식으로 images관련 속성을 세팅해줘야 해당 사이트의 이미지 사용가능
                         
                             module.exports = {
                               images: {
                                 remotePatterns: [
                                   {
                                     protocol: 'https',
                                     hostname: '도메인주소',
                                     port: '',
                                     pathname: '/my-bucket/**',
                                   },
                                 ],
                               },
                             }


     # Next.js에서 Presigned URL을 사용하는 방법
        : AWS에서 이미지를 업로드 시 제공하는 기능인 Presigned URL을 사용하는 방법에 대해, vercel에서 올려둔 예제에 대한 내용 정리

         @ AWS S3 이용시 참고사항
           : AWS S3 콘솔에서 버킷의 권한설정을 설정 시, ACL은 쓰지 않는다면?
              -> '임의(= 모든)의 ACL로 부여된 액세스 차단' 을 체크해서 차단해두는게 안전성이 높음
                   -> 2개의 권한이 겹치는 경우 최대한 느슨한 쪽으로 결정되기 때문에, 보안을 위한다면 그런 면에서 안정성이 낮은 ACL은 차단하자

         @ Presigned URL방식 (= 미리 주어진 URL방식)
            : AWS에서 제공하는 이미지 업로드 방식
               -> client가 화면에서 이미지를 고르면 자동으로 직접 AWS 스토리지에 업로드 + AWS측에서 client 측에 시한부 URL를 할당해서 해당 이미지를 바로 볼 수 있게 함 
                  (= clinet -> AWS로 이미지 즉시 업로드 + 즉시 해당되는 기간제 URL을 보내줘서 당장 확인 가능하게 해주니 편리)

         @ Presigned URL의 이점
            1. client 측에서 이미지를 바로 확인가능하여 편의성이 좋아짐
            2. client 측에서 제시한 이미지를 웹서버에 업로드 하지 않고, AWS S3에 업로드를 직빵으로 하니 부하도 적어짐
                -> 만약? 개발자 측에서 S3의 용량 낭비를 극혐하여, Presigned URL을 쓰지 않고 client가 선택한 이미지를 화면에 보여주려면?
                    : createObjectURL() 함수를 사용하면, client측에서 선택한 이미지만 바로 보여주는게 가능하며 S3에 업로드는 시키지 않음
                      (= 과거에는 다 이런 방법으로 이미지를 화면에서 client 측에 미리 보여줌)

         @ Presigned URL 사용 과정 
           (어차피 vercel측에서 제공해 레퍼런스라 복붙해서 쓰는 경우가 대부분.. 하지만 원리 정도는 알아두면 좋음)

            1. client측에서 이미지 업로드 시, server측에 Presigned URL을 요청
                : <input>에서 사용자가 이미지 고르는 순간, 웹서버에게 Presigned URL을 요청하는 API의 GET요청에 해당하는 코드를 작성하기

                  ex) <input>의 내용이 변하는 걸, JSX 이미지핸들러 속성으로 포착하면, 바로 Presigned URL을 요청하는 GET요청을 수행하도록 코드를 짬

                      'use client'

                      export default function Write(){ 
                        return (
                          <div className="p-20">
                            <h4>글작성</h4>
                              <form action="/api/post/new" method="POST"> 
                              <input name="title" placeholder="글제목"/> 
                              <input name="content" placeholder="글내용"/> 
                              <button type="submit">전송</button> 
                            </form>
                      
                            <input type="file" accept="image/*" onChange={ 
                              async (e)=>{
                                let file = e.target.files[0]
                                let filename = encodeURIComponent(file.name)          <-  encodeURIComponent(문자열) : URI형식에 맞게 해당 문제열을 인코딩해주고 그 결과물을 반화하는 함수
                                let res = await fetch('/api/post/image?file=' + filename)
                                res = await res.json()
                              }
                            } />
                            <img />
                      
                          </div>
                        )
                      } 

            2. server측은 client측의 신원 관련 검증을 수행 후, Presigned URL을 만들어서 보내줌

                1) npm install aws-sdk 해서 AWS 다룰 수 있는 라이브러리 하나 설치 후

                2) AWS S3 연결에 필요한 설정값을 aws.config.update({JS객체}) 형식으로 적어줌
                    -> {JS객체} parameter인 S3 연결값 속성
                        a. accessKeyId      : S3에 접속할 AWS측에서 제공한 ID (.env 이용 추천)
                        b. secretAccessKey  : S3에 접속할 AWS측에서 제공한 PW (.env 이용 추천)
                        c. region           : 접속할 지역설정 (ap-northeast-2이 보통)
                        d. signatureVersion : 버전 (v4로 해두는게 좋음)

                3) PresignedURL 생성에 필요한 설정객체를 parameter로 넣은 createPresignedPost({JS객체}) 함수를 호출하면, AWS S3서버로부터 PresignedURL를 반환받을 수 있음
                    -> {JS객체} parameter인 PresignedURL 생성 객체 속성

                        a. Bucket
                            : 접속할 S3 버킷명 (.env 이용 추천)

                        b. Fields
                            : S3측에 제공할 파일에 대한 정보를 담은 {JS객체} 
                               -> 보통 key라는 프로퍼티 값 1개에, client측에서 보낸 request객체에서 file에 해당하는 정보를 통째로 담아서 보냄

                        c. Expires   
                            : 생성된 Presigned URL이 적용되는 기간을 (초) 단위로 설정 

                        d. Conditions
                            : S3측에서 수용할 파일에 대한 조건 설정을 담은 [배열]..  
                               -> 보통은 ['content-length-range', 0, 숫자]라는 내부 배열을 씀 (= 파일용량 숫자bit 까지 제한함()

                ex) client로부터 PresignedURL을 달라는 API 요청을 받으면, aws sdk 라이브러리를 통해 S3에 접속한 뒤, createPresignedPost({파일정보 객체}) 함수를 통해 PresignedURL을 AWS S3에게서 받음

                    import aws from 'aws-sdk'
                    
                    export default async function handler(요청, 응답){
                        aws.config.update({
                          accessKeyId: process.env.ACCESS_KEY,
                          secretAccessKey: process.env.SECRET_KEY,
                          region: 'ap-northeast-2',
                          signatureVersion: 'v4',
                        })
                    
                        const s3 = new aws.S3();
                        const url = await s3.createPresignedPost({
                          Bucket: process.env.BUCKET_NAME,
                          Fields: { key : 요청.query.file },
                          Expires: 60, // seconds
                          Conditions: [
                            ['content-length-range', 0, 1048576], //파일용량 1MB 까지 제한
                          ],
                        })
                    
                        응답.status(200).json(url)
                    }  

            3. server가 S3로부터 받아온 Presigned URL을 이용해서, client측은 브라우저에서 AWS S3 서버로 이미지를 POST요청해서 바로 업로드 함
                : PresignedURL을 받았으면, 그것을 이용하여 S3측에 업로드를 하겠다는 API요청을 하고, 성공시 PresignedURL을 통해 업로드 된 이미지를 띄워달라는게 예시코드의 내용
                   -> 단지, server로부터 받은 PresignedURL을 여기서는 임의의 <form>태그를 생성하고 거기에 데이터를 보관함
                   

            4. S3로의 업로드가 성공한다면..? 해당 이미지의 URL을 state 객체요소를 이용해서 받은뒤, <img src=" ">에 박아서 이미지 업로드된 걸 보여 줌 

                ex) 1번의 예시를 완성시킴.. 정확히는 Presigned URL을 받은 뒤의 로직을 완성시켜 3번과 4번을 해결

                   'use client'

                   import { useState } from "react";
                   
                   export default function Write(){ 
                     let [src, setSrc] = useState('')
                   
                     return (
                       <div className="p-20">
                         <h4>글작성</h4>
                           <form action="/api/post/new" method="POST"> 
                           <input name="title" placeholder="글제목"/> 
                           <input name="content" placeholder="글내용"/> 
                           <button type="submit">전송</button> 
                         </form>
                   
                         <input type="file" accept="image/*" onChange={
                           async (e) => {
                             let file = e.target.files[0]
                             let filename = encodeURIComponent(file.name)
                             let res = await fetch('/api/post/image?file=' + filename)
                             res = await res.json()
                             
                             // --------------3번에 해당하는 부분, S3 업로드---------------------------
                             const formData = new FormData()
                             Object.entries({ ...res.fields, file }).forEach(([key, value]) => {
                               formData.append(key, value)
                             })
                             let 업로드결과 = await fetch(res.url, {
                               method: 'POST',
                               body: formData,
                             })
                             console.log(업로드결과)
                   
                             if (업로드결과.ok) {
                               setSrc(업로드결과.url + '/' + filename)
                             } else {
                               console.log('실패')
                             }
                             
                           }
                         } />

                         //----------4번에 해당하는 부분--------------
                         <img src={src} />
                   
                       </div>
                     )
                   } 


     # Next.js에서 다중 rendering(SSR, CSR 양쪽 방식 모두 사용 가능)을 지원하는 방법
        : component 종류를 2가지로 지원하여, 개발자가 원하는 방식으로 해당 component 작성 가능
           -> (추천) 웹페이지의 틀은 SSR의 server component로, react적 기능이 필요한 component에 한해서 CSR의 client component 방식으로 제작하면?
                : SSR을 쓰는 부모 component에 붙히는 방식으로, CSR과 SSR의 장점만 혼합하는 식으로 사용 가능

           1. server component (Uncontrolled Components)
               : SSR(Server Side rendering) 방식으로 동작하는 component 단위
                 (= react가 아닌 HTML, CSS, JS만을 사용하겠다는 것을 의미)
  
                @ server component 만드는 법
                   : page.js, layout.js 등 Next.js가 기본적으로 편의성으로 제공해주는 component는 전부 server component라고 생각하면 됨
  
                @ server component 장/단점
                   -> (장점)
                       1) 웹서버에서 미리 웹페이지를 랜더링해서 보내주는 고전적인 방식으로 성능적으로 속도가 빠름
                         (= 웹페이지 로드시 react에서 처럼 랜더링시 비동기적인 JS코드를 쓸 일이 없으니, 작동 최적화를 생각할 필요가 없기 때문)
  
                       2) SEO(Search Engine Optimization)에 유리하여, 검색엔진에 노출이 쉬움
  
                   -> (단점)
                       : component의 반환되는 html 안에 react에서 통용되는 JSX문법을 사용할 수 없음 
                         (= 쉽게말해 react를 전혀 쓸 수 없으므로, useState, useEffect, onClick 이런 거 사용X)
  
                @ (참고) server conponent에서 console.log()를 입력한다면?
                    : 해당 코드를 실행하는 주체는 서버의 JS 런타임 환경인 node.js이니, 터미널에서 확인이 가능함
                       (= NEXT.JS에서 작성한 API route의 경우도 같은 원칙을 공유하는 server component 기반이라는거 기억해야..)

           2. client component (Controlled Components)
               : CSR(Server Side rendering) 방식으로 동작하는 component 단위
                 (= react 라이브러리의 방식을 쓰겠다는 의미)
  
                @ client component 만드는 법
                   : component 제작시 'use client' 라는 코드를 넣으면 OK
  
                @ client component 장/단점
                   -> (장점)
                       : component의 반환되는 html 안에 자유롭게 react에서 통용되는 JSX문법을 사용 가능
                         (= react를 사용할 수 있음) 
  
                          1) JSX의 이벤트핸들러 함수를 사용 가능
                              : DOM을 직접 조작하는게 아닌, VDOM 로직으로 다른 부분만 다시 랜더링하는 react 기반 프론트엔드 라이브러리에서 사실상 이벤트핸들러 사용법은 이게 유일
  
                          2) 새로고침이 강제되지 않는 페이지를 만드는 것이 가능하기에, Ajax 방식의 API호출과 시너지가 우수한 편
  
                   -> (단점)
                       : 웹페이지 상의 모든 동작과 이벤트를 Client 측에서 새로고침 없이 비동기적으로 처리하는 CSR 방식의 근본적인 문제에 직면
  
                          1) 웹페이지 용량이 커지게 됨
                              : react의 JSX문법에 해당하는 JS코드가 늘어남 + CSR을 위해서는 모든 조작에 반응해야 하므로 다운로드 받을 HTML, CSS, JS 파일이 많을 수 밖에 없음
  
                          2) 웹페이지 로딩속도도 약간 느려질 수 있음
                              a. Client 측에서 초기에 필요한 정보들을 서버에 API로 호출하고, 이를 직접 랜더링해야 하기 때문
                              b. JS로 구현된 React 문법을 적용하는 과정에서, JS로 html을 읽고 분석하는 과정인 hydration에 소요되는 시간도 추가로 발생

                          3) client component에 적은 코드는 데이터를 캡슐화해주는 react의 요소 없이는 유저들이 볼 수 있기에 보안에 문제가 됨
                              : state객체변수나 useEffect와 같은 react hook함수를 사용하는 것이 거의 강제됨

                          4) 페이지 로딩에 있어, 모든 경우의 수를 상정하여 코드를 짜야함
                              : 어떤 데이터를 가져오는 API를 호출할지부터, 데이터가 없는 경우의 component의 구조들도 작성해야 하는 등.. 개발자가 손봐야 할 내용이 적지 않음 

                          5) (중요) DB에서 데이터를 요청할 때, server에서와 같이 바로 DB에 요청을 거는 방식이 아니라, server 측의 API로 필요한 요청을 해야 함
                              -> CSR 방식의 원칙은 이미 정적으로 만들어진 페이지를 client 측에서 받아서 그 뒤 랜더링을 하는 방식
                                 (= 당연한 거지만, server쪽에서 랜더링에 관여하지 않으며, 원래부터 client측에서 DB에 접속할 수 있는 환경변수가 있는거도 아니니, server측에 필요한게 있으면 요청하는게 당연함)

                @ (참고) client conponent에서 console.log()를 입력한다면?
                    : 해당 코드를 실행하는 주체는 브라우저의 JS 런타임 환경이니, 디버깅 모드에서 확인이 가능함


     # Next.js에서 다중 rendering(SSR, CSR 양쪽 방식 모두 사용)을 사용하는 component에서 DB데이터를 받고 처리하고 가공하는 방식 
        : '[부모] : [자식] = server component (Uncontrolled Components) : client component (Controlled Components)' 경우 DB데이터를 어느쪽에서 호출해야 하는지에 대한 딜레마
            -> (참고) server - clinet compoenent 간 데이터 이동 검증에 console.log()를 사용한다면, 사용한 compoenent에 따라 로그가 찍혀나오는 위치가 서버 터미널 or 브라우저 디버깅 모드창으로 바뀔 수 있음

          1. [부모] 측의 server component가 DB 서버로부터 데이터를 받고, 이를 [자식] 측의 client component에 props 객체를 통해 넘겨주기
              : (추천) 일반적으로 SSO에 띄기 위한 SSR기법의 장점과 component의 동작 측면에서 좋은 성능을 보이는 CSR의 장점까지 두루두루 활용 가능하기에 자주 쓰임

                ex) (/list/page.js)
                    
                    <ListItem result={result} />
                    
                ex) 구조분해(structure destruction) 문법을 활용하면, {props객체변수}로 parameter를 채워도 props.멤버변수가 아니라 멤버변수만 써도 알잘딱하게 알아먹음
                
                    (/list/ListItem.js)
                    
                    'use client'
                    
                    export default async function ListItem({result}) {
                      return (
                        <div>
                          { result.map((a,i)=>
                              <div className="list-item" key={i}>
                                <Link href={'/detail/' + result[i]._id}>{result[i].title}</Link>
                                <Link href={'/edit/' + result[i]._id} className="list-btn">✏️</Link>
                                <button>🗑️<button>
                                <p>1월 1일</p>
                              </div>
                           ) }
                        </div>
                      )
                    }

             @ (참고) [부] server - [자] client 관계의 component 구조는 Next.js에서 허용하는 구조고, 이렇게 하면 client component도 DB 데이터를 미리 채워서 보내주게 로직이 짜여서 가능
                 -> 크롬 개발자도구에서 Javascript disable 해놓고 페이지 방문해서 잘 보이나 테스트해보면, 바로 JS를 통해 해당 로직이 구현되었음을 알 수 있음
              
          2. [자식] 측의 client component가 직접 DB서버로부터 데이터를 받는 방안
              : 가능하고, 괜찮은 방안이지만 꽤 단점이 많아서 써야하는 경우를 잘 상정하는게 중요함
                (= 사실 그 단점이라는게, 근본적으로 검색엔진 노출이 힘들어서 서비스가 유저들에게 노출이 잘 안 된다는 비즈니스적인 측면에 있음)
              
                ex) 'use client'
                    
                    export default function ListItem(){

                      const [result, setResult] = useState([]);
                    
                      useEffect(() => {

                        async function fetchData() {

                          try {
                            const db = (await connectDB).db('forum');
                            let data = await db.collection('post').find().toArray();
                            setResult(data);

                          } catch (error) {
                            console.error("Failed to fetch data:", error);
                          }
                        }

                        fetchData();
                      }, []);
                    
                      return (
                        <div>{result}</div>
                      )
                      
                    }

             @ (단점)
                1) 유저가 코드를 볼 수 있는 보안 문제로 캡슐화를 통한 접근제한이 보장되는 state객체변수와 useEffect와 같은 react hook함수를 통해 DB에 호출하는 코드를 작성하는 것이 좋음
                2) 처음부터 component에 초기화 된 데이터가 들어가 있는 것이 아님
                   (= 검색엔진 BOT들은 이걸 보면 기다리지 않고 해당 웹페이지는 내용이 텅 비었다고 판단함 = 검색엔진에 웹페이지가 노출되는 것이 느려지기에 SSO 측면에서 좋지 않음)


     # Next.js로 제작된 페이지들의 rendering 종류와 개념 (static rendering / dynamic rendering )
        : 정적 렌더링(static rendering)과 동적 렌더링(dynamic rendering)으로 나뉘어져 있음 
            -> 구체적으로 어떤 페이지들이 어떤 렌더링(rendering)으로 동작하는지 알고 싶다면, npm run build 명령어를 통해 complie이 완료된 후 파일에 λ (람다) 표시와 ㅇ표시로 이를 구분 가능
               (Controlled / Uncontrolled component와 같은 영역이 아니라.. 조금이라도 페이지가 다르게 랜더링되냐 마냐로 더 엄격하게 구분됨)
                 -> λ로 표시되는 페이지 = dynamic rendering으로 동작
                    ㅇ로 표시되는 페이지 = static rendering으로 동작

          1. 정적 렌더링(static rendering)
              : 어떤 유저라도 해당 URL에 접속하게 되면, 매번 npm run build시 생성한 html을 아무런 변동없이 그대로 보내주는 방식의 웹페이지 랜더링
                 -> 웹 페이지 안에 별 기능이 없기에, 매번 html 페이지를 새로 만들 필요가 없기 때문

                    ex) 100명이 들어와도 언제나 똑같은 웹페이지 복붙하는 '로그인' 페이지 같은거가 여기 해당
              
             @ 정적 렌더링(static rendering) 특징
                : ㅇ로 표시되는 페이지 = static rendering으로 동작

                  (장점)
                    : 유저가 100명 들어와도 페이지를 새로 만들지 않기에 성능에 유리
                      (= 애초에 cashing이 필요 없음)

                  (단점)
                    1) 복잡한 서비스랑은 당연히 거리가 먼 편 
                    2) cashing(캐싱) 기능을 이용하면, 동적 랜더링(dynamic rendering) 페이지도 효율적인 재사용으로 성능적으로 뒤쳐지지 않을 수 있음

             @ 강제로 정적 렌더링(static rendering)을 쓰도록 고정하는 방법
                : 원하는 페이지에 해당하는 component의 js파일에 dynamic이란 예약어 변수를 선언하고, 'force-static'을 입력
                   -> 'auto'가 기본값이며, 이는 알아서 시스템이 판단해줌

                      ex) export const dynamic = 'force-static' 
    
                          export default function 페이지(){
                            (생략)
                          }

          2. 동적 렌더링(dynamic rendering)
              : 해당 URL에 접속하게 되면, 접속하는 유저나 상황에 따라 html에 변동사항이 들어가기에, 페이지에 들어갈 때마다 html 페이지를 서버에서 다시 그려주는 방식의 웹페이지 랜더링
                 -> 변화하는 내용에 영향을 줄 수 있는 fetch('/URL', { cache: 'no-store' }),  useSearchParams(), cookies(), headers(), [dynamic route] 같은걸 사용하는 페이지들이 해당

                    ex) 상세 페이지, 회원정보와 같은 대다수의 페이지들이 여기 해당
              
             @ 동적 렌더링(dynamic rendering) 특징
                : λ로 표시되는 페이지 = dynamic rendering으로 동작

                (장점)
                  : DB 입출력 기능에 대응할 수 있는 복잡한 서비스에 유리하며, 구현 가능한 영역이 많음
                
                (단점)
                  : cashing(캐싱) 기능을 이용해도, 정적 랜더링(static rendering)에 비해서 성능은 어쩔수 없이 밀림

             @ 강제로 동적 렌더링(dynamic rendering)을 쓰도록 고정하는 방법
                : 원하는 페이지에 해당하는 component의 js파일에 dynamic이란 예약어 변수를 선언하고, 'force-dynamic'을 입력한 뒤 export처리 
                   -> 'auto'가 기본값이며, 이는 알아서 시스템이 판단해줌

                      ex) export const dynamic = 'force-dynamic' 
    
                          export default function 페이지(){
                            (생략)
                          }

             @ cashing(캐싱)
                : 데이터를 잠깐 몰래 저장해두고 그걸 재사용하여 비용절약 + 속도향상을 노린다는 개념

                  ex) Next.js에선 페이지 캐싱, GET요청결과 캐싱 이런 것들이 존재 

                  1) 페이지 cashing(캐싱) 기능 사용 방법 = (구) ISR
                     : 원하는 페이지에 해당하는 component의 js파일에 revalidate 이란 예약어 변수를 선언하고, 원하는 초단위 숫자를 입력한 뒤 export처리
                         -> 특정 페이지를 원하는 시간(초) 만큼 캐싱해두고 재활용을 할 수 있음 
     
                           ex) 60초가 지나면, 해당 페이지를 재생성 하여 또 60초간 캐싱해서 유저측에 보여줌
                               (= 60초마다 static rendering 페이지 하나 생성해주는 식이므로, 과거에는 ISR로 부름)
                           
                               export const revalidate = 60;
                               
                               export default function Page() {
     
                                 DB입출력하는코드~~
     
                                 return (
                                   <div>어쩌구</div>
                                 )
                               } 

                       ((구) ISR 중요사항) 
                         [1] 방문자가 있어야 페이지를 시간에 맞게 재생성
                         [2] on-demand revalidation 을 사용하면, 특정 이벤트가 발생시 입력된 시간을 무시하고, 페이지 캐싱을 새로 생성이 가능함

                  2) fetch API에서 사용가능한 GET요청데이터 cashing(캐싱) 기능
                     : (Next.js 13버전부터) server component에 한해, dynamic rendering 사용 페이지에서 fetch API의 option 파라미터에 cache, revalidate라는 멤버변수를 통해 캐싱을 통한 비용절약 + 속도향상 가능
     
                       (cashing 연관 fetch API 멤버변수)
                         [1] cache
                              : GET요청 결과값 cashing(캐싱)기능 on/off을 위한 fetch API의 option 파라미터 객체의 멤버변수
                                (= 시간에 따른 조건부 캐싱이 불가능 -> next라는 option 파라미터 객체의 멤버변수의 객체의 프로퍼티인 revalidate의 존재 이유)
                                
                                   a. (기본값) fetch('/URL명', { cache: 'force-cache' }) 
                                       : fetch()로 요청하면 한 번 가져온 결과를 어딘가에 몰래 저장해두고 웹사이트 다시 npm run build 하기 전까지 계속 가져와 줌
          
                                          ex) let result = await fetch('/api/어쩌구', { cache: 'force-cache' })
      
                                   b. fetch('/URL명', { cache: 'no-store' }) 
                                       : fetch()로 요청하면 매번 새로 서버로 요청해서 데이터를 새로 가져옴
                                         (= 재사용 X, 데이터의 갱신여부가 중요한 경우 사용)
          
                                          ex) let result = await fetch('/api/어쩌구', { cache: 'no-store' })
     
                         [2] next: { revalidate: 숫자 }
                              : GET요청 결과값 cashing(캐싱)결과를 얼마나 보관할지를 초 단위 정하기 위한 fetch API의 option 파라미터 객체의 멤버변수와 내부 객체의 프로퍼티
                                 -> (참고)  웹서버의 API를 작성할 때도 fetch API의 revalidate 옵션기입이 가능

                                    ex) 60초가 지나면 다시 /URL로 새로 요청해서 결과를 가져오고 캐싱
 
                                        let result = await fetch('/api/어쩌구', { next: { revalidate: 60 } })
     
                       (fetch API와 관련된 cashing 기능의 중요사항) 
                         [1] (중요) server component에 한해서만 fetch API의 cashing기능 사용 가능
                               -> 이것이 server component에서 ajax 사용시 fetch를 계속 쓸 이유라고 할 수 있겠음 

                         [2] (중요) 여러 component에서 동시다발적으로 같은 /url로 fetch하는 경우 중복은 알아서 제거되며, 변수나 state 공유문제도 마찬가지로 데이터 캐싱으로 해결됨
                                    (= 같은 /url로 요청하는 fetch() 잔뜩 사용해도 비효율 문제가 딱히 없는 이유)

                         [3] 로직 자체는 Next.js에서 바닐라 JS의 fetch() 기본함수를 업그레이드해놔서 사용 가능
                         [4] 웹서버의 API를 작성할 때도 fetch API의 revalidate 옵션기입이 가능


     # Next.js의 module(작게 분리한 프로그램 개별 파일) 시스템
        : 일반적인 JS와 전혀 다를 것이 없으니, ES6 이후로 공식화 된 ES모듈의 import/export 방식 그대로 쓰면 됨
          (= 물론 require로 대표되는 CommonJS 문법도 사용은 가능함)

          1. export
              : 특정 변수, 함수 등을 외부 파일에서 가져다 쓸 수 있는 모듈로서 내보내는 모듈화를 시킬 떄 쓰는 문법.. 파일별로 1개만 사용 가능
                 -> (중요!) But 변수나 함수나 선언할 때마다 export를 붙이는건 제한이 없고, 선언된 게 1개면 당연히 default도 사용가능

                    1) export default 변수명 or 함수명
                        : 단일 변수, 함수만 모듈로 내보낼 경우 사용하는 문법
                           -> default 자체가 '해당 모듈엔 개체가 하나만 있다'는 사실을 암시하며, import로 모듈을 가져올 때 {}가 필요없게 함 

                    2) export {변수명, ... , 함수명} 
                        : 여러 함수나 변수를 모듈로 내보낼 경우 사용하는 문법

          2. import
              : export된 모듈을 외부 파일에서 가져다 쓸 때 쓰는 문법 
                 -> 보통 파일 가장 최상단에 사용

                    1) import 변수명 or 함수명 from '모듈경로명'
                        : default export 된 변수나 함수를 모듈로서 가져올때 사용하는 문법
                           -> default가 들어갔으니, {}를 쓰면 안되며, as는 필요없이 꼴리는 변수명을 붙이면 됨

                              ex) import 꼴리는변수 from "./data.js"

                    2) import {변수명, ... , 함수명} from '모듈경로명'
                        : 여러 함수나 변수를 모듈로 가져오는 경우 사용하는 문법
                           -> as 별칭을 통해, 변수명처럼 쓸 수도 있음

                    3) import * from '모듈경로명'
                        : 해당 모듈에서 export한 모든 함수나 변수를 모듈로 가져오는 경우 사용하는 문법
                           -> But 이렇게 하면 어떤 변수나 함수를 사용하는지 알 수 없고, 불필요한 내용까지 가져오는 경우가 있어 성능이나 코드 구조 파악이나 모두 힘듦


    # Next.js를 사용한 웹서비스 베포과정

       1. 터미널에 npm run build 입력 
           : react기반의 Next.js를 사용하여 개발한 코드들을 브라우저 친화적인 html, js, css 파일로 complie해 바꿔주는 작업

       2. 서버로 사용한 물리적인 컴퓨터 및 AWS같은 클라우드의 터미널에 해당 소스를 복사해두고 터미널에서 npm run start 입력
           : 이를 통해 실제로 유저 요청을 처리할 수 있는 Next.js 서버가 완성됨
              -> 단! 도메인 같은건 따로 처리를 해둬서, DNS서버에서 도메인을 보고 해당 서버로 연결되도록 처리할 수 있게 해줘야함


    # Next.JS와 MongoDB 관련 특수지식들

       1. MongoDB 세팅은 일반적으로 Node.js에 하는 것과 차이 없음
           -> DB연결용 보일러플레이트 코드도 new MongoClient(url, options).connect()의 값을 모듈분리하여 export 시켜도 전혀 문제없음

       2. Next.JS에서 MongoDB를 사용한다는건, React 라이브러리와 DB를 같이 쓰는 것이라고 볼 수 있음
          (= import한 모듈화된 연결변수와 DB호출함수는 component 안에 지역변수처럼 해줘야 component내에서 정상동작하는데 유리함)

       3. (중요) DB입출력하는 코드는 server component 안에서만 사용해야 함 (async await 방식으로 쓰려면, component에 async 붙여주기)
           -> client component 안에 적은 코드는 유저들도 쉽게 볼 수 있음!!

       4. Next.Js에서 작성을 권하는 DB연결변수를 분리 모듈로서 관리하는 database.js의 MongoDB 관련 보일러플레이트 코드는 다음과 같음
           -> Nextjs의 경우 개발환경에서 JS파일을 작성 중이라 갱신할 때마다 JS파일들을 다시 읽어들이고 코드를 재실행함
              (= DB연결 객체인 MongoClient.connect()가 동시에 여러 개 실행될 수 있고, DB의 성능낭비가 심해지는 문제 발생)
                  -> 방지 차원에서 개발중임이 확인되면 Next.JS에서 가지고 있는 global이라는 전역변수 객체에 연결정보를 저장할 수 있음

                     ex) import { MongoClient } from 'mongodb'
                         const url = 'DB접속URL~~'
                         const options = { useNewUrlParser: true }
                         let connectDB
                         
                         if (process.env.NODE_ENV === 'development') {
                           if (!global._mongo) {
                             global._mongo = new MongoClient(url, options).connect()
                           }
                           connectDB = global._mongo
                         } else {
                           connectDB = new MongoClient(url, options).connect()
                         }
                         export { connectDB }

       5. 비동기코드이기에 promise문법으로 통제되는 DB연결로직이 선행되기에, DB호출코드들을 export 시키면 안정성이 떨어진다는 문제에 대한 Next.js 솔루션?
           -> Next.Js는 현재 next.config.js파일에서 실험단계인 top-level await 기능을 true/false로 해금할 수 있게해서, true시 DB호출코드까지 export해도 안정적으로 작동할 수 있도록 기능을 추가중임
               -> But! nodejs 버전이 낮으면 못쓰는 기능이라.. 클라우드를 쓰기라도 할 경우 서버가 지원안해주면 못 씀

                  ex) next.config.js 파일열어서 webpack(){} 부분을 참고
                  
                       /** @type {import('next').NextConfig} */
                      const nextConfig = {
                        experimental: {
                          appDir: true,
                        },
                        webpack(config) {
                          config.experiments = { ...config.experiments, topLevelAwait: true }
                          return config
                        }
                      }
                      module.exports = nextConfig


    # Next.js에서 서버 기능 제작 
       : 결론부터 말하자면 Node.js에서 server.js에 일일히 노가다로 제작하던 API들의 제작이 일종의 자동화가 되었다고 볼 수 있음
         (= URL명 제작 구조를 API라는 폴더와 그 안의 파일들로 단순화 시켜놓고, API의 실행내용은 그 안의 함수 component형식으로 유사하게 만듦)
 
         1. app 폴더 밖에 api 폴더를 만들고 거기에 API명에 해당하는 js 파일을 'API명.js'으로 만듦
             : /api 폴더 안에 위치한 폴더와 JS파일들은 자동으로 웹서버의 URL에 대응되며, js파일들의 functional component들은 API 호출의 결과로 실행됨 

               ex) /pages/api/test.js 파일은 'https://도메인/api/test' 라는 URL로 호출되는 API의 내용으로 그 내부의 component를 실행함
                    -> 요청 객체의 내용 가공 및 응답 객체를 통한 client로 보내는 내용 주목 
              
                       export default function handler(요청, 응답) {
                         if (요청.method == 'GET'){
                           응답.status(200).json({ name: '안녕' })
                         }
                         if (요청.method == 'POST'){
                           응답.status(200).json({ name: '바보' })
                         }
                       }
    
         2. 'API명.js' 파일 안에 functional component(이름은 뭘로 지어도 됨)를 제작하고, API의 구체적인 실행 내용(DB에 요청할 쿼리, 요청내용 가공, 응답 처리 등)을 작성함

              @ 참고사항
                 1. server component에 해당하기에 DB 입출력하는 코드를 작성해도 괜찮음 
                 2. find() 같은 조회 쿼리에 해당하는 메서드를 사용시, 그 결과값이 없다면 NULL로 반환
                     -> (중요) 만약, 후속코드에 'cursor명.멤버변수' 같은 걸 지정시, NULL에는 멤버가 없으므로 이를 찾을수 없어 바로 런타임 에러가 떠버리니 참고  

                 3. 유저 측에서 보낸 정보를 추측했을 때 DB에 전송을 원하지 않은 상황이 생길경우, 요청(request) 객체의 정보를 조건문에 사용해서 문제를 차단 가능  
                     -> (참고) 프론트엔드에 있는 모든건 위조가 가능하여 넘어갈 수 있기에, 보낸 값의 대조는 웹서버에서 직접하는게 좋음 

                 4. try, catch 구문을 통한 예외처리를 통해, 에러시의 대처 완성도를 높일 수 있음

                    ex) insert를 해야 하니, 유저가 <form>태그로 보낸 요청(request) 객체의 멤버객체 body를 통째로 넣어도 문제없음  
                    
                        import { connectDB } from "@/util/database"
                        
                        export default async function handler(요청, 응답) {
                          if (요청.method == 'POST'){
                            if (요청.body.title == '') {
                              return 응답.status(500).json('제목써라')
                            }
                            try {
                              let db = (await connectDB).db('forum')
                              let result = db.collection('post').insertOne(요청.body)
                              응답.redirect(302, '/list')
                            } catch (error) {
                              DB에러시 실행할코드~~
                            }
                            
                          }
                        } 

                    ex) delete할 데이터를 찾는 filters 객체를 paramter로 넣어야하니, 유저가 URL에 보낸 데이터인 요청(request) 객체의 멤버객체 query의 특정 멤버변수를 찾아서 기입해야 에러날 확률이 적음
                    
                        import { connectDB } from "@/util/database";
                        import { ObjectId } from "mongodb";
                        
                        export default async function handler(요청, 응답) {
                        
                            try{
                                console.log(요청.query);
                        
                                let client = await connectDB;
                                const db = client.db('forum');
                                let 데이터 = await db.collection('post').deleteOne( {_id : new ObjectId(요청.query.URL_parameter) } );
                        
                                console.log(데이터);
                        
                                응답.status(200).json('삭제완료');
                        
                            }catch(error){
                                응답.status(500).json('서버나 DB에 문제가 발생했나 봅니다..');
                            }
                        
                        }

              @ client -> server로 들어온 요청(request)에서 들어온 정보 가공하는 코드 작성법
                 : functional component의 1번째 parameter로 들어가는 요청(request)객체의 멤버변수나 메서드를 사용
                 
                    1) 요청.method
                        : API 호출시 URL말고 HTTP method 또한 알고 싶은 경우, functional component의 1번째 parameter로 들어가는 요청(request)객체의 멤버변수인 method를 호출하면 됨
                           -> (중요) 이를 이용하면, HTTP 메서드에 따른 조건문을 통해 같은 URL이라도 HTTP 메서드에 다를 경우에 대한 '동URL이API'들을 쉽게 구현가능 

                    2) 요청.body
                        : client측에서 <form>태그를 통해 데이터를 입력하여 전송하여 API를 호출하는 경우, 서버측에서 유저가 보낸 데이터를 조회하기 위한 요청(request)객체의 멤버객체 body 

                    3) 요청.query
                        : client측에서 URL paramter 방식이나 queryString 방식을 통해 API를 호출하는 경우, 서버측에서 유저가 보낸 데이터를 조회하기 위한 요청(request)객체의 멤버객체 query 
                           -> (참고) 웹서버에서 유저가 보냔 요청(request) 객체의 데이터를 쓰려면, props객체의 데이터 쓸 때처럼 멤버객체도 확실히 지정해주는게 좋음

                               ex) queryString 예시
                                    : https://www.mydomainxxx.co.kr/detail?id=33&pw=222

                               ex) URL 파라미터 예시
                                    : https://www.mydomainxxx.co.kr/detail/33/pw/222

              @ server -> client로 '응답(response)'을 보낼 때 필요한 코드 작성법
                 : functional component의 2번째 parameter로 들어가는 응답(response)객체의 멤버변수나 메서드를 사용
                    -> (중요) 사실 안해주는 client측은 무한으로 대기중인 상태에 빠질 수 있으므로 거의 필수라고 보면 됨 

                        1) 응답.json(JS원시값 or JS객체 or 배열)
                            : ()안의 값을 json 형식으로 변환하여 문자열의 형태로 client에 전달하는데 사용
    
                        2) 응답.status(status숫자값)
                            : client 측에 요청에 대한 응답 상태를 전송할 때 사용하며, 여전히 응답(response) 객체를 return하기에, 메서드 메이닝(method chaining)이 가능함
                        
                              ex) 응답.status(200).json({ name: '바보' })
                                   -> client 측에 {"name" : "바보"}가 보임
    
                        3) 응답.redirect(status숫자값, 'URL명')
                            : API를 호출한 client를 다른 페이지로 강제로 이동시키고 싶은 경우 사용하는 메서드
                               -> (중요) 이건 웹서버 측에서 사용자에게 다른 웹페이지를 랜더링해 보내는 SSR(server side rendering)에 포함
    
                                   ex) 응답.redirect(302, '/list');

         3. 'API명.js' 파일의 작성이 다 끝났다면, client의 화면에서 이를 호출해 봐서 잘 작동하는지 확인
              -> (참고) console.log()를 통해, 데이터 이동 검증을 할 시, 해당 코드를 사용한 주체가 서버인지 브라우저인지 따라서 로그가 찍히는 위치가 다르다는 것 명심해야 함 

              @ client 측의 서버 API 호출법
                (자세한 내용은 Node.js 측에도 적어둠)

                1) <form> 태그 사용
                    : HTML의 공식 태그 중 하나인 <form>태그에 <input>태그를 사용하여 정보를 입력하고, action속성 안의 URL주소의 API를 호출하여 서버가 이를 실행하는데 쓸 수 있도록 데이터를 보내는 방식  

                      ex) export default function Write(){
                            return (
                              <div>
                                <h4>글작성</h4>
                                <form action="/api/test" method="POST">
                                  <button type="submit">버튼</button>
                                </form>
                              </div>
                            )
                          }
                        
                      @ <form> 장/단점

                         (장점) 
                           a. html에서 공식으로 지원하는 형식이라 검증
                           b. 웹서버로 POST, GET요청을 쉽게 날릴 수 있음

                         (단점)
                           a. POST, GET요청 말고는 HTTP 메서드를 날릴 수 없음
                           b. 새로고침이 무조건 동반되는 SSR 방식
                              (= 전송을 끝날 때까지는 아무것도 못하는 동기적 작동 방식)

                2) ajax(Asynchronous JavaScript and XML) 기능 사용
                    : ajax는 새로고침 없이, 비동기 방식으로 웹서버의 API를 JS나 XML을 사용한 코드로 호출할 수 있는 기술적 개념에 가까운 기능을 의미함
                      (= ajax의 구현 방법은 정말 다양하지만, 현 시점에서는 ECMA 6버전 이후 promise객체 기반으로 제작된 fetch구문이나, 그 이전부터 높은 편의성과 역사로 이름을 떨친 axios가 존재   

                   @ ajax 장/단점

                      (장점) 
                        a. 웹서버에 내용을 전송해도 새로고침을 안해도 됨
                        b. 비동기적 데이터 교환이 이뤄짐 = 데이터 전송과 관련없이 화면이 유지되고 사용자는 조작이 가능
                            -> (참고!) 화면 전환없이 이뤄지는 요청과 리턴이기에 ajax를 통한 통신을 주고받는 기능에서는 다른 페이지로 연결하여 새로고침을 유발하는 redirect나 render 같은 함수를 API {}안에 써봐야 작동하지 않음.. 
                        c. Js를 사용하는 Runtime 환경이면, 서버나 화면에서나 같은 방식으로 데이터를 주고받기 쉽다
                        d. GET, POST 외의 다른 HTTP 메서드(PUT, DELETE, PATCH)도 받을 수 있음

                      (단점)
                        : 기본적으로 버튼을 지원하는 FORM 태그랑 다르게, JS의 이벤트리스너를 통해 스스로 버튼 동작과 기능을 연결시킬 줄 알아야 해서 좀 과정이 귀찮음
                          (= fetch API가 표준이니 이거는 사용할 줄 아는게 좋음)

                   @ (참고) JSON 객체의 메서드
                      : [배열] or {JS객체} -> JSON형태의 "문자열" 로 변환 or 역으로 JSON형태의 "문자열" -> [배열] or {JS객체} 로 파싱하는 역할의 도구들

                         a. JSON.stringify( {JS객체} or [배열] )
                             : parameter로 들어간 {JS객체} or [배열]을  JSON형태의 "문자열"로 변환하는 메서드
                                -> (주의) BUT! {JS객체}의 메서드는 파싱 및 변환 과정에서 복구가 불가능해지니 주의

                         b. JSON.parse ( JSON 형식의 "문자열" )
                             : parameter로 들어간 JSON 형식의 "문자열" 을  {JS객체} or [배열]로 파싱하여 복구해주는 메서드
                                -> {JS객체}의 메서드는 복구가 불가능

                   @ fetch('URL명', {method : 'HTTP 메서드', body : '본문' , ... } )
                      : ECMA 6에서 공식적으로 지원하는 Ajax API기능으로 promise 객체를 기반으로 만들어져, 수신성공/실패에 따른 콜백함수 처리를 쉽게 할 수 있음

                       (fetch 문법)
                         : promise객체를 기반으로 제작되었기에, URL에 따른 API호출을 시작으로 늘 성공/실패에 따른 콜백함수 처리를 해줘야함
                            
                           a. async / await 방식
                               : Ajax 방식의 API호출 과정을 async 함수화시킨 모듈로 처리하고, 비동기적으로 작도하는 코드에 기다림의 질서를 부여할 await 처리를 해줌  

                                 ex) async function submit() {
   
                                       // 1번째 await 포인트
                                       let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));
   
                                       // 2번째 await 포인트 : 웹서버에 API호출
                                       let response = await fetch('/article/fetch/post/image', {
                                         method: 'POST',
                                         body: blob
                                       });
                                 
                                       // 3번째 await 포인트 : 전송이 잘 되었다는 응답이 오고, 이미지 사이즈가 얼럿창에 출력됩니다.
                                       let result = await response.json();
                                       alert(result.message);
                                     }

                           b. then, catch, finally
                               : Ajax 방식의 API호출 과정을 고전적으로 promise 체이닝 메서드 형식으로 실행

                                 ex) function submit() {

                                       canvasElem.toBlob(function(blob) {

                                         fetch('/article/fetch/post/image', {
                                           method: 'POST',
                                           body: blob
                                         })
                                           .then(response => response.json())
                                           .then(result => alert( JSON.stringify(result, null, 2) ) )

                                       }, 'image/png');
                                     }

                       (fetch 사용법) 

                         [1] API 요청
                              : 사용할 fetch API의 방식을 정하고, 거기에 맞게 URL과 fetch 형식을 정함
                                 -> ({ option 객체 }를 적어야 하는 경우) 
                                      a. method  : GET 이외의 HTTP메서드를 쓸 경우
                                      b. headers : client 측에서 header 영역을 따로 설정하고 싶은 경우 사용
                                      c. body    : 웹서버로 데이터(문자열, Form객체, Blob이나 BufferSource, URLSearchParams)를 보내고 싶은 경우 
                                                    -> (주의) {JS객체}, [배열]을 보내려도 '문자열'로 보내야 하므로, 반드시 JSON 형식으로 변환하여 보낼 것

                         [2] API 응답
                              : API의 요청에 웹서버가 성공적으로 응답한다면, 데이터를 응답(response)객체 형식으로 보내줌
                                (async/await 형식에서는 변수가 이를 받는다면, then() catch() 형식은 무명콜백함수의 1번째 객체 parameter가 이를 받음)

                       (fetch 응답(response) 객체의 구조) 

                         [1] 멤버변수 (= properties)
                              : 주로 메타 데이터에 해당하는 데이터를 가지고 있는 객체의 멤버변수 영역

                                a. response.status  : 응답시의 HTTP 상태코드
                                b. response.ok      : 응답 상태가 200과 299 사이에 있는 경우 true
                                c. response.headers : 응답 데이터의 HTTP 헤더데이터가 담긴 변수

                         [2] 메서드 
                              : 웹서버의 API 응답에 대한 데이터의 본문을 파싱하기 위한 메서드
                                (= 보통은 json으로 변환하게 될 것)
                                   -> (주의사항)
                                        1. fetch API에서는 응답을 받았으면, 반드시 해당 메서드들을 써서 서버가 보낸 응답객체의 body데이터를 파싱해줘야 client측이 알아먹을 수 있음
                                        2. 단! 한번만 사용이 가능함 
                                           (= 가장 먼저 실행한 메서드로 데이터는 파싱됨)

                                a. response.text()        : 응답객체 body 본문을 텍스트 형태로 반환함
                                b. response.json()        : 응답객체 body 본문을  파싱해 JSON 객체로 변경함
                                c. response.formData()    : 응답객체 body 본문을 FormData 객체 형태로 반환
                                d. response.blob()        : 응답객체 body 본문을  Blob(타입이 있는 바이너리 데이터) 형태로 반환
                                e. response.arrayBuffer() : 응답을 ArrayBuffer(바이너리 데이터를 로우 레벨로 표현한 것) 형태로 반환

                         ex) 이런식으로 응답객체의 프로퍼티와 메서드를 사용

                             fetch('/URL')
                             .then((응답)=>{
                               if(응답.status == 200) {
                                 return 응답.json()
                               } else {
                                 //서버가 에러코드 전송시 실행할코드
                               }
                             }).then((응답)=>{ 
                               // 성공시 실행할코드
                             })
                             .catch((실패)=>{
                               // 인터넷문제 등으로 실패시 실행할코드
                               console.log(error)
                             })

                       (fetch 주의사항 모음)
                         [1] fetch 요청시 {JS객체}, [배열]을 보내려도 '문자열'로 보내야 하므로, 반드시 JSON 형식으로 변환하여 보낼 것
                         [2] fetch 요청시, option에 body속성을 넣어야 한다면, 반드시 데이터를 넣어야 함
                         [3] fetch 요청시, POST 요청을 보낼 때 body속성값이 문자열이면 Content-Type 헤더가 text/plain;charset=UTF-8로 기본 설정됨
                         [4] fetch 요청시, URL을 적을 때 URL parameter와 queryString 형식까지 포함해서 데이터를 보내는 거도 가능은 함
                         [5] fetch API에서는 응답을 받았으면, 반드시 해당 메서드들을 써서 서버가 보낸 응답객체의 body데이터를 파싱해줘야 client측이 알아먹을 수 있음
                         [6] fetch API에서는 응답 변환 메서드는 단! 한번만 사용이 가능함
                             (= 가장 먼저 실행한 메서드로 데이터는 파싱됨)
                         [7] server component를 사용한다면, fetch API를 사용할 것이 Nextjs 13부터는 권장됨 
                              -> fetch에 특별한 기능이 추가되어 있기에 때문


                3) URL의 일부로 데이터를 포함해서 href 속성값으로 url를 작성하여, 웹서버의 API를 호출해 무식하게 보냄..
                    : 말 그대로 브라우저의 주소창에 해당하는 window.location.href의 속성값을 변경하는 방법으로 웹서버에 무식하게 호출을 보냄
                       -> (중요) fetch API나 <form> 태그를 쓸 때도 GET형식을 쓴다는 가정하에 URL을 해당 형식에 맞춰 적는다면, 데이터를 보내는게 가능함

                          ex) URL 파라미터 예시
                               : https://www.mydomainxxx.co.kr/detail/33/pw/222
       
                          ex) queryString 예시
                              : https://www.mydomainxxx.co.kr/detail?id=33&pw=222

                   @ URL 직접사용 장/단점
   
                      (장점) 
                        a. 추가적인 라이브러리 따위 없이, 간편하게 데이터를 보낼 수 있음
                        b. (URL 파라미터의 경우) 그나마 보내는 데이터가 어떤 칼럼에서 나오는지를 가리기에 보안적인 면에서 나을수는 있음
   
                      (단점)
                        a. 이를 통해서는 GET방식의 호출 밖에 할 수 없음
                        b. 새로고침이 무조건 동반되는 SSR 방식
                        c. (라이브러리에 따라서는) POST 방식을 쓸 수도 있지만, 기본적으로 URL에 데이터를 포함해서 보내기에 보안이 씹망


    # Next.js에서 미들웨어(middleware) 기능 제작 



- Auth.js (Next-Auth 라이브러리)
   : Next.JS 프레임워크 사용시, 회원기능을 구현함에 있어 JWT또는 OAuth를 매우 쉽게 만들 수 있게 도와주는 라이브러리
      -> 라이브러리 설치 + 코드만 복사 붙여넣기 하면 여러가지 회원기능을 쉽게 구현 가능 

         ex) OAuth 소셜 로그인, 아이디/비번 로그인, JWT, session 방식
              -> DB adapter 기능을 이용하면, DB에 session을 저장해두는 식의 전통적인 유저 관리 


    # Auth.js의 장/단점

       (장점)
         : 그냥 개발자 입장에서 쓰기 매우 쉬움

       (단점) 
         1) 기본적으로 모든 방식이 JWT로 동작하게 설계됨
         2) 심지어 ID/PW로 로그인하는 옵션을 켜둔 경우?
             -> 제작팀에서는 보안이슈를 이유로 JWT 방식을 강제로 사용하게 제약을 걸어둠
                (= session 방식은 사용 불가능)


    # Auth.js 라이브러리 세팅
      1. node.js와 Next.js는 당연히 필수
      2. 작업폴더만들고 에디터로 오픈
      3. 터미널에 npm install next-auth  입력
      4. 'pages/api/auth/[...nextauth].js' 라는 경로에 [...nextauth].js 파일을 만들고, 보일러플레이트 코드를 작성해 둠
           -> authOptions이란 JS객체는 로그인 정보를 담고 있는 객체로서, 다른 component에서 열람가능

              ex) [...nextauth].js 파일의 보일러 플레이트 코드
              
                  import NextAuth from "next-auth";
                  import GithubProvider from "next-auth/providers/github";
                  
                  export const authOptions = {
                    providers: [
                      플렛폼1명Provider({
                        clientId: '플렛폼1에서 발급받은ID',
                        clientSecret: '플렛폼1에서 발급받은Secret',
                      }),
              
                      ... ,
              
                      플렛폼n명Provider({
                        clientId: '플렛폼n에서 발급받은ID',
                        clientSecret: '플렛폼n에서 발급받은Secret',
                      }),
                    ],
                    secret : 'jwt생성시쓰는암호'
                  };
     
                  export default NextAuth(authOptions); 


    # component에서 로그인 된 유저의 정보를 출력해야 하는 경우
       : (주의) 유저정보 또한 server component에서 유저정보 가져와서 client component로 전송해주는게 나을 수 있음
           -> 다른 외부서버에 API를 호출하는 경우와 마찬가지로, side effect와 로딩의 우선순위를 고려해야 하는 CSR 환경에서 동작하는 useSession() 함수 또한 html 다 보여주고나서 한 박자 늦게 실행될 수 있기 때문

              ex) Github의 경우는 유저정보를 조회하면 다음과 같은 user객체를 응답객체에 보내줌
                   -> (참고) DB adapter를 사용하여, session 로그인 기능을 쓰는 경우 expire라는 멤버변수도 포함

                      {
                        user: {
                          name: '유저명',
                          email: '이메일id@도메인.com',
                          image: '이미지주소'
                        }
                        
                        // session 로그인 사용시
                        expire : '만료 날짜'
                      }

              1. server component의 경우
                  : 비동기 함수코드 getServerSession()를 사용하나, parameter로 들어가는 내용이 JS파일 종류마다 변경
                    (= 사용시 async, await 필수)

                  1) component JS파일 내부에서 유저의 정보를 출력해야 하는 경우
                      : getServerSession(authOptions) 방식으로 호출
                         -> (중요) next-auth 라이브러리에서 getServerSession() 함수를 모듈로 가져옴 + [...nextauth].js 파일에서 로그인 정보를 담는 authOptions객체를 모듈로 가져오는 작업 선행
                      
                            ex) import { authOptions } from "@/pages/api/auth/[...nextauth].js"
                                import { getServerSession } from "next-auth"
 
                                export default function Page(){

                                  // session 정보를 가져옴
                                  let session = await getServerSession(authOptions)

                                  if (session) {
                                    console.log(session)
                                  }
                                  ....
                                }
                                
                  2) API JS파일 내부에서 유저의 정보를 출력해야 하는 경우
                      : getServerSession(요청, 응답, authOptions) 방식으로 호출
                         -> authOptions객체를 모듈로 가져오는 작업 + 함수형식으로 API 작성시 사용되는 요청(request), 응답(response) parameter까지 같이 포함시킴
                            (= 오버라이드 된 형태의 함수로 봐도 무방함.. 그리고 1)과 같은 방법으로 호출해도 별 문제는 없음)

                            ex) await getServerSession(요청, 응답, authOptions)를 await getServerSession(authOptions)로 해도 문제는 없음
                            
                                import { authOptions } from "../auth/[...nextauth]";

                                export default async function handler(요청, 응답) {
                                
                                    let session = await getServerSession(요청, 응답, authOptions); 
                                    console.log(!session);
                                
                                    if(!session){
                                        return 응답.status(500).json('로그인이나 먼저해라');
                                    }
                                
                                }

              2. client component의 경우
                  : useSession()라는 react hooks 함수를 사용하여 쉽게 로그인 정보 조회
                     -> (중요) 단! client component인 [부모 component]에서 <SessionProvider>라는 component를 import 해오고, 이를 client component인 [자식 component]에 감싸야 사용 가능
       
                        ex) client component인 [부] layout.js 에서 [자]에 해당하는 모든 component를 <SessionProvider>로 감싼다면...
                             -> (참고) 최상위 layout.js에서 회원기능에서 배울 getServerSession() 쓰면, 모든 페이지가 동적 랜더링(dynamnic rendering)으로 동작할 수 있음
       
                            'use client'
                            
                            import { SessionProvider } from "next-auth/react"
                            
                            export default function Layout({ children }){
       
                              return (
                                <SessionProvider>
                                  {children}
                                </SessionProvider>
                              )
                            }
       
                        ex) client component인 [자]에 해당하는 모든 component에서는 useSession()이라는 함수 하나로 로그인 정보를 보여줌
       
                            'use client'
                            
                            import { useSession } from 'next-auth/react'
                            export default function Page(){
       
                              let session  = useSession();
       
                              if (session) {
                                console.log(session)
                              }
                            }


    # Auth.js 라이브러리에서 각 로그인 기능 구현

      1. OAuth 로그인
          : 어떤 유저의 A사이트에서의 조회 권한을 잠시 B사이트를 운영하는 쪽에서 빌리는 식으로, A사이트의 유저조회 API를 호출하는 과정을 정의하는 규칙을 의미하기에..
             -> B사이트의 운영팀은 A사이트에서서 OAuth에 대한 사용허가를 받아야 함
                (= 그 사용허가를 구분하는 기준이 B사이트 입장에서 clientID, clientSecret인 셈)

          @ OAuth 로그인 기능 구현 과정
          
            0) OAuth를 원하는 플랫폼(provider)에 clientID, clientSecret을 얻어내기 위한 작업을 실시
  
               ex) Github로 예시
                    a. 회원가입 후, 유저 탭 영역의 'setting' 클릭
                    b. 좌측 하단 탭의 Developer settings -> New OAuth app 클릭
                    c. 어떤 앱에 어떤 용도로 쓸지와, 요청에 대한 응답을 어디로 보내줄지에 대한 도메인도 입력
                       (사실, 이 정보가 곧 API에 영향을 미치는건 아니니, 개인 레벨이면 대충써도 무방함)
                    d. 발급받은 clientID, clientSecret를 잘 보관하기
  
            1) OAuth 로그인은 JWT방식이 기본이라, 플랫폼(provider) 측의 서비스 ID, PW를 얻어서 [...nextauth].js 설정파일의 각 clientID, clientSecret에 넣으면 완료
                -> secret 멤버변수는 OAuth 로그인은 JWT방식이 기본이라는 점에서, 가져다 쓰는 개발자가 추가적으로 사용하는 salt같은 개념
                   (= 이거를 사용하면, 플랫폼(provider)측의 salt와 유저측의 salt들을 모두 알아야 로그인 정보 해킹이 된다는 점에서 더 골이 아프게 할 수 있음)
  
            2) import { signIn, signOut } from 'next-auth/react' 와 같은 방식으로, next-auth/react 라이브러리의 로그인 및 로그아웃 함수를 모듈로 가져와서 사용
                -> (참고) 주로 어떤 button의 클릭 이벤트로 구현될 경우가 많은데 react에서는 JSX문법으로 이벤트속성으로 이를 구현하니, 보통 client component에서 해당 기능이 구현되는 경우가 많음
  
            3) 기능 테스트를 해보면, 클릭 시 우리가 일반적으로 아는 각 플랙폼 사의 OAuth 로그인으로 들어가는 버튼들이 등장하며, 그걸 누르면 소셜로그인 진행

      2. OAuth + session 방식 로그인 (DB adapter 기능 활용)
          : DB에 유저 회원정보를 보관하고, 로그인시 그 정보가 일치하면?
             -> 입장권에 해당하는 session(유효한 날짜까지만 사용가능 + 여차하면 DB에서 이를 지워 통제가능)을 유저에게 주고, 서버에 요청을 보낼때마다 이를 체크하는 방식 

          @ (필수) MongoDB의 adapter 기능을 설정 과정
             : MongoDB가 아니더라도 Next.JS 프레임워크에서 Auth.JS로 session 로그인 기능을 구현하려면, 반드시 사용할 DB의 adapter 기능을 활성화시킬 뭔가가 필요함

               1) 터미널에 npm install @next-auth/mongodb-adapter을 입력하여, MongoDB의 adapter 관련 라이브러리를 설치하자
                   -> 설치에 문제가 생긴다면 상위 버전의 mongoDB 지우고 npm install mongodb@4를 입력하여, 4 ~ 5 버전의 MongoDB 라이브러리를 사용하게 하자

               2) DB adapter 자체가 session 관련 기능을 수행할 컬랙션(= 테이블)을 추가하는 것이기에, 해당 컬랙션들이 위치할 Database를 결정해야 함
                  (= MongoDB 접속 URL에 ?가 있는 부분 왼쪽에, 원하는 Database명을 넣으면 session 관련 컬랙션들이 생길 위치를 해당 Database명에 지정 완료)
                      -> 안 적으면, 기본값 TEST라는 DB명이 생겨나서, 추후 관련 collection들을 보관

                         ex) const url = 'mongodb+srv://아이디:비밀번호@클러스터명.도메인/Database명?DretryWrites=true&w=majority'

               3) [...nextauth].js 파일에, authOptions이 저장하는 로그인 정보를 가지는 JS객체에 adapter 프로퍼티를 추가하고, MongoDBAdapter(connectDB)를 대입함
                   -> MongoDBAdapter(DB연결정보) 함수는 해당 DB연결정보를 사용하여, MongoDB adepter기능을 사용한다는 것
                      (= connectDB가 의미하는건 database.js에서 export한 MongoDB에 연결한 보일러플레이트의 결과물)

                      ex) adapter : MongoDBAdapter(connectDB)를 추가하여, DB adapter기능을 활성화하여 session방식 로그인을 수행준비
                         
                          import { connectDB } from "@/util/database";
                          import { MongoDBAdapter } from "@next-auth/mongodb-adapter";
                          import NextAuth from "next-auth";
                          import GithubProvider from "next-auth/providers/github";
                          
                          export const authOptions = {
                            providers: [
                              GithubProvider({
                                clientId: 'Github에서발급받은ID',
                                clientSecret: 'Github에서발급받은Secret',
                              }),
                            ],
                            secret : '어쩌구'
                            adapter : MongoDBAdapter(connectDB), //추가함
                          };
                          
                          export default NextAuth(authOptions); 

               4) 웹서버를 돌리고, MongoDB의 collection을 보면 session 관련 기능을 위한 accounts, sessions, users 3개 컬렉션들을 생성함을 확인가능
                   -> (생성된 collection 설명)

                       a. users   
                           : 유저들의 회원정보 보관하는 컬랙션 (= PK는 이메일로 설정) 
                              
                              ex) test@naver.com 만 등록 

                       b. sessions 
                           : 로그인 유효기간을 포함한, 현재 로그인된 유저들의 session 정보들이 모여있는 컬랙션

                       c. accounts
                           : 유저들이 생성한 모든 계정 보관하는 컬랙션 

                              ex) test@naver.com라는 유저는 1명이나, 그 계정은 플랫폼(provider)에 따라 여러개가 있음을 기록
                                  (= 1명의 유저는 여러개의 계정을 가지고 있을 수 있어, 이메일 중복 가능성이 높음)
                              
                                  test@naver.com + Github이 써있는 document 
                                  test@naver.com + Google이 써있는 document 

          @ DB adapter 기능을 통한 session 로그인 기능 로직 과정

            1) 첫 로그인시 자동으로 유저를 회원가입 시킴
               (= 회원가입 X.. 로그인 하자마자 DB에 회원정보를 DB의 관련 컬렉션 및 테이블에 보관)

            2) 로그인시 자동으로 유저가 언제 로그인했는지에 대한 session정보를 DB의 관련 컬렉션 및 테이블에 보관

            3) 웹서버에서 지금 로그인된 유저정보가 필요하면, DB에 있던 session컬렉션 및 테이블의 정보를 조회해서 가져옴 
               (= JWT를 분석하지 않는다는 것)

            4) 로그아웃시 해당 유저의 session 정보는 DB에서 삭제되거나 사용완료 처리 


      3. 전통적 ID/PW + JWT 사용하기 방식 로그인 (auth.js의 Credentials provider 기능 활용)
          : auth 라이브러리 설정에서 Credentials provider를 모듈로 불러온 뒤, 해당되는 내용들을 보일러플레이트 코드로서 [...nextauth].js에 입력해주는 식으로 감
             -> 이걸 다 적고나서, 서버를 실행시킨 뒤, 로그인을 위한 버튼을 클릭하면, Credentials provider에서 제공하는 ID/PW 입력 화면이 <form>태그 기반으로 등장함
             -> (참고) ID/PW를 쓰게 된다면, DB에 회원정보를 저장한다는 의미니 API를 처리할 때 hashing을 담당해주는 라이브러리를 설치해도 쓰면 유용함
                
                ex) bscript 라이브러리 (= Node.js 쪽 참고)

          @ CredentialsProvider()함수
             : ID/PW 기능을 위한 미리 준비된 레이아웃의 <form> 태그 기반의 로그인 화면을 제공해주고, 로그인 기능 및 검증에 대한 영역을 사용자로 하여금 작성할 수 있게 도와주는 용도의 함수
                -> 로그인 방식의 한 종류이므로 {JS객체}를 담는 authOption 변수를 구성하는 [provider] 배열의 요소를 담당

               (CredentialsProvider()의 paramter로 들어가는 {JS요소} 구성)
                 1. name : "credentials"
                     : 해당 parameter인 객체의 이름이 credentials와 연관있음 기록
                 
                 2. credentials: { email: { label: "email", type: "text" }, password: { label: "password", type: "password" } }
                     : 해당 ID/PW를 쓰는 로그인페이지의 <form>의 input 요소들을 정하고, 그에 맞춰 레이아웃을 자동생성해주기 위한 목적의 코드 
      
                 3. authorize(credentials) { 로그인 API의 내용 } 
                     : 앞선 <form>의 정보를 이용하여, 로그인 API에 해당하는 내용을 사용자가 입력한데로 수행하는 비동기 방식으로 동작하는 함수
                        -> DB에서 아이디,비번 비교하고, 아이디,비번 맞으면 return 결과, 틀리면 return null 하는걸 주로 적음

                  ex) CredentialsProvider({
                     
                        name: "credentials",
          
                        //1. 로그인페이지 폼 자동생성해주는 코드 
                        credentials: {
                          email: { label: "email", type: "text" },
                          password: { label: "password", type: "password" },
                        },
              
                        //2. 로그인요청시 실행되는코드
                        async authorize(credentials) {
                          ~내용 생략~
                          return user
                        }
                      })

          @ 그 외 authOption들의 요소들
          
             1) session
                 : session 데이터의 구조(jwt, 만료일)와 설정을 담당하는 {js객체}
                    - strategy : PW 데이터 저장에 어떤 방식을 쓸건지를 결정 (사실상 'jwt'으로 고정)
                    - maxAge   : 만료일을 (초)단위 숫자로 적음, 연산 다음

             2) callback
                 : PW 데이터(= 사실상 jwt) 만들 때 실행되는 코드 
           
                   A. jwt : async  ({ token, user }) => { 내용 }
                       : client측에 JWT를 제공해야 할 때마다 실행되어 client측에 현재 token의 정보를 반환하는 비동기 함수 표현식 형식으로 작성된 프로퍼티
                           -> parameter : { token, user }를 가지는 {JS객체}를 parameter로 받는 비동기 무명콜백함수 
                                -> (중요) token, account, user는 jwt + session에서 MongoDB에 생성된 collection들과 같음
        
                                    a. users   
                                        : 유저들의 회원정보 보관하는 컬랙션 (= PK는 이메일로 설정) 
                                           
                                           ex) test@naver.com 만 등록 

                                    b. sessions 
                                        : 로그인 유효기간을 포함한, 현재 로그인된 유저들의 session 정보들이 모여있는 컬랙션

                   B. session : async  ({ session, token }) => { 내용 }
                       : session 정보를 새로 구성해야 할 때마다 실행되는 어떤 session 정보를 token을 이용하여 가공하여 구성한 뒤, session 객체로 반환하는 비동기 함수 표현식 형식으로 작성된 프로퍼티
                          -> parameter : 원하는 session과 token을 프로퍼티로 가지는 {js객체}를 parameter로 받는 비동기 무명콜백함수 
                              -> (중요) getServerSession()을 실행하면, 여기서 반환된 session 내용이 나오는 구조

             ex) import { connectDB } from "@/util/database";
                 import { MongoDBAdapter } from "@next-auth/mongodb-adapter";
                 import NextAuth from "next-auth";
                 import GithubProvider from "next-auth/providers/github";
                 import CredentialsProvider from "next-auth/providers/credentials";
                 import bcrypt from 'bcrypt';
                 
                 export const authOptions = {
                   providers: [
                     GithubProvider({
                       clientId: 'Github에서 발급받은 ID',
                       clientSecret: 'Github에서 발급받은 Secret',
                     }),
                 
                     CredentialsProvider({
                       name: "credentials",
                         credentials: {
                           email: { label: "email", type: "text" },
                           password: { label: "password", type: "password" },
                       },
                 
                       async authorize(credentials) {
                         let db = (await connectDB).db('forum');
                         let user = await db.collection('user_cred').findOne({email : credentials.email})
                         if (!user) {
                           console.log('해당 이메일은 없음');
                           return null
                         }
                         const pwcheck = await bcrypt.compare(credentials.password, user.password);
                         if (!pwcheck) {
                           console.log('비번틀림');
                           return null
                         }
                         return user
                       }
                     })
                   ],
                 
                   session: {
                     strategy: 'jwt',
                     maxAge: 30 * 24 * 60 * 60 //30일
                   },
                 
                 
                   callbacks: {

                     jwt: async ({ token, user }) => {
                       if (user) {
                         token.user = {};
                         token.user.name = user.name
                         token.user.email = user.email
                       }
                       return token;
                     },

                     session: async ({ session, token }) => {
                       session.user = token.user;  
                       return session;
                     },
                   },
                 
                   adapter: MongoDBAdapter(connectDB),
                   secret: 'qwer1234'  
                 };
                 export default NextAuth(authOptions); 


      4. JWT + refresh token(재발급 토큰) 사용하기 방식 로그인
          : auth 라이브러리 설정에서, authOptions의 멤버변수에 해당되는 내용들을 보일러플레이트 코드로서 refresh token(재발급 토큰)과 관련된 모든 서버 로직들을 [...nextauth].js에 입력해주는 식으로 감
             -> So..! 매우 귀찮은 작업이기에? 몇몇 플랫폼(provider) 서비스들은 자체적으로 refresh token(재발급 토큰) 기능을 개발자가 사용할 수 있도록 제공해줌

           @ 현재 refresh token(재발급 토큰) 관련 이슈 참고문서
              : (중요) 현재 JWT가 갱신 타이밍에 갱신되지 않고 에러 메시지가 뜨면서 그냥 기존 JWT만 사용
                  -> nextjs 13 ~ 14버전의 app폴더 사용시 쿠키조작이 어렵기에 생기는 refresh token 관련 버그라고 볼 수 있음..
                     (Auth.js에서 고쳐지길 기다리는거도 방법)

             1) JWT 갱신 고장 이슈 
                 : https://github.com/nextauthjs/next-auth/discussions/6642

             2) next-auth refresh token 공식문서
                 : https://auth-docs-git-feat-nextjs-auth-authjs.vercel.app/guides/basics/refresh-token-rotation


           @ refresh token(재발급 토큰) 로직 구현 과정 
              -> 간략하게 보기 위해서 Github OAuth의 내용만 반영하여 구현
           
             1) 개발자 측에서 직접 구현해야 할 refresh token(재발급 토큰) 로직들

                [1] 로그인 시 refresh token 난수로 만들고, JWT에 몰래 넣어주고 DB에도 저장
                [2] client측의 access token 유효기간이 지나면? refresh token을 서버로 보내는 코드를 next-auth 설정 파일의 jwt 콜백함수 안에 작성 
                [3] client측에서 refresh token 보내면, DB에 있는거랑 맞는지 검사
                [4] client측에서 보낸 refresh token이 유효하면, access token과 refresh token을 새롭게 제조 + 유효기간도 기록해서 JWT로 만들어주고 DB에도 저장

             2) OAuth 제공 플랫폼(provider) 서비스 측에서 refresh token(재발급 토큰) 로직을 제공하는 경우

                [1] OAuth를 원하는 플랫폼(provider)에 clientID, clientSecret을 얻어내기 위한 작업을 실시

                    ex) Github로 예시

                        a. 회원가입 후, 유저 탭 영역의 'setting' 클릭
                        b. 좌측 하단 탭의 Developer settings -> GitHub Apps 클릭
                        c. 어떤 앱에 어떤 용도로 쓸지와, 요청에 대한 응답을 어디로 보내줄지에 대한 도메인도 입력
                           (사실, 이 정보가 곧 API에 영향을 미치는건 아니니, 개인 레벨이면 대충써도 무방함)
                        d. 발급받은 clientID, clientSecret를 잘 보관하기

                [2] (1번의 일반 OAuth 방식과 동일한 파트) 
                     : OAuth 로그인은 JWT방식이 기본이라, 플랫폼(provider) 측의 서비스 ID, PW를 얻어서 [...nextauth].js 설정파일에 넣어줌
                         -> authOptions의 providers 프로퍼티 배열에 GithubProvider라는 JS객체를 받는 함수를 넣고, 그 객체 안에 각 clientID, clientSecret를 멤버로 만들고 값을 넣음
                             -> 여기에 secret 프로퍼티를 채우면 OAuth 로그인은 JWT방식이 기본이라는 점에서, 가져다 쓰는 개발자가 추가적으로 사용하는 salt같은 개념

                [3] (3번의 전통적 ID/PW + JWT 방식과 동일한 파트) 
                     : 공통적인 일반 OAuth 방식에 필요한 authOptions의 프로퍼티들 외의 다른 프로퍼티(jwt, callback)들의 값을 입력함

                    (jwt 발급시 authOptions에서의 로직 작동 흐름)
                      -> 로그인 시 Github 측에서 accessToken, refreshToken, expires_at (유효기간)을 보내주면, 처음 JWT 만들어줄 때 해당 정보를 넣음
                      -> JWT 사용할 때마다 callback의 메서드인 jwt()의 코드가 실행, JWT의 유효기간(maxAge)이 얼마 남았는지 측정 후 JWT로 변환하여 client 측에 반환
                      -> 유효기간이 임박한 경우 Github의 공식문서가 시키는대로 재발급 요청
                           -> 길어질거 같으니 [4]에서 refreshAccessToken() 이라는 함수로 독립시켜 설명 예정

                     a. jwt
                         : jwt(= access token)의 설정을 정하는 authOptions의 프로퍼티
                            -> But github 측에서 ccess token 유효기간 8시간, refresh token 유효기간 6개월로 정해주었기에 무시됨
                   
                     b. callback
                         : client의 로그인 요청을 확인하고, 경우에 따라 알맞은 jwt을 만들어주는 로직에 해당하는 메서드(jwt, session)들을 가지는 authOptions의 프로퍼티 객체 
                           (= callback 프로퍼티 내부의 메서드들의 내용은 공개되어 있지만, 구체적으로 이들을 호출하여 jwt를 발급하는 부분은 블랙박스에 해당)

                           A. jwt({ token, account, user })
                               : client측에 JWT를 제공해야 할 때마다 실행되어 client측에 현재 token의 정보를 반환하는 비동기 함수 (비동기 무명함수 표현식을 받는 프로퍼티 방식으로 써도 무방)
                                  -> parameter : token, account, user 를 가지는 {js객체}
                                      -> (중요) token, account, user는 jwt + session에서 MongoDB에 생성된 collection들과 같음
        
                                          a. users   
                                              : 유저들의 회원정보 보관하는 컬랙션 (= PK는 이메일로 설정) 
                                                 
                                                 ex) test@naver.com 만 등록 

                                          b. sessions 
                                              : 로그인 유효기간을 포함한, 현재 로그인된 유저들의 session 정보들이 모여있는 컬랙션

                                          c. accounts
                                              : 유저들이 생성한 모든 계정 보관하는 컬랙션 

                                                 ex) test@naver.com라는 유저는 1명이나, 그 계정은 플랫폼(provider)에 따라 여러개가 있음을 기록
                                                     (= 1명의 유저는 여러개의 계정을 가지고 있을 수 있어, 이메일 중복 가능성이 높음)
                                                 
                                                     test@naver.com + Github이 써있는 document 
                                                     test@naver.com + Google이 써있는 document 
        
                           B. session({ session, token })
                               : session 정보를 새로 구성해야 할 때마다 실행되는 어떤 session 정보를 token을 이용하여 가공하여 구성한 뒤, session 객체로 반환하는 비동기 함수 (비동기 무명함수 표현식을 받는 프로퍼티 방식으로 써도 무방)
                                  -> parameter : 원하는 session과 token을 프로퍼티로 가지는 {js객체}

                    ex) [...nextauth]에 입력되는 코드

                        export const authOptions = {
                        
                            providers: [
                        
                                // 깃허브 AUTH 관련 정보
                                GithubProvider({
                                    clientId: process.env.GITHUB_APP_ID,
                                    clientSecret: process.env.GUTHUB_APP_SECRET,
                                }),
                            ],
                            
                            // 기간설정은 무시됨, github은 access token 유효기간 8시간, refresh token 유효기간 6개월 
                            jwt: {
                                maxAge: 60
                            },
                        
                            callbacks: {
                        
                                // JWT 사용할 때마다 실행됨, return 오른쪽에 뭐 적으면 그걸 JWT로 만들어서 유저에게 보내줌
                                async jwt({ token, account, user }) {
                                    console.log('account', account);
                                    console.log('user', user);
                                    console.log('token', token);
                            
                                    // 1. 첫 JWT 토큰 만들어주기 (첫 로그인시에만 실행)
                                    if (account && user) {
                        
                                        return {
                                            accessToken: account.access_token,
                                            refreshToken: account.refresh_token, 
                                            accessTokenExpires: account.expires_at,
                                            user,
                                        }
                                    }
                            
                                    // 2. 남은 시간이 임박한 경우 access token 재발급하기 
                                    //     -> 지금은 개발중이라 8시간 - 10초 남았을 때 재발급중
                                    let 남은시간 = token.accessTokenExpires - Math.round(Date.now() / 1000);
                        
                                    if (남은시간 < (60 * 60 * 8 - 10) ) {  
                        
                                        console.log('유효기간 얼마안남음')
                        
                                        // 3. 깃헙에게 재발급해달라고 조르는 비동기 함수  refreshAccessToken() 
                                        let 새로운JWT = await refreshAccessToken(token) 
                        
                                        console.log('새로운 JWT : ', 새로운JWT)
                        
                                        return 새로운JWT
                                    } else {
                                        return token
                                    }
                                },
                        
                                // 4. 유저 세션이 조회될 때 마다 실행되는 코드
                                //    -> getServerSession 실행시 토큰에 있던 어떤 정보 뽑아서 컴포넌트로 보내줄지 결정가능  
                                session: async ({ session, token }) => {
                                    session.user = token.user
                                    session.accessToken = token.accessToken
                                    session.accessTokenExpires = token.accessTokenExpires
                                    session.error = token.error
                                    return session
                                },
                            },
                        
                            secret : process.env.NEXT_AUTH_SECRET,
                        };
                        
                        export default NextAuth(authOptions); 


                [4] access token 재발급을 받아오는 용도에 해당하는 refreshAccessToken() 함수를 OAuth 제공 플랫폼(provider)에서 시키는데로 작성함

                    (refreshAccessToken 로직 작동 흐름)
                      -> access token을 재발급해달라고 POST로 플랫폼(provider) 측인 github에 API 요청을 함 (BUT! 반드시 header를 추가해야 받아들임)
                         (예시 코드에서는 axios 라이브러리 설치해서 그걸로 post요청을 날림)
                      -> 재발급 된 access token에는 재발급된 access token, refresh token, 유효기간이 들어있음
                         (주석으로 출력해보면 querystring 형식으로 출력됨)
                      -> 재발급된 access token, refresh token, 유효기간으로 새로운 JWT 만들어서 return  
                         (발급된 token은 querystring 형식으로 발급되기에, 쉽게 데이터를 추출하려면 new URLSearchParams의 parameter로 넣고 .get() 으로 뽑아야 함) 
                      -> refreshAccessToken(token) 이걸 쓸 때 마다 그 자리에 재발급된 토큰들이 남음

                         ex) [...nextauth].js에 작성되는 함수 (= authOptions.callback.jwt에 쓰이게 됨)
                         
                             import axios from 'axios';
                             
                             async function refreshAccessToken(token) {
                             
                                 // 1. access token 재발급해달라고 POST요청
                                 const url = 'https://github.com/login/oauth/access_token';
                                 const params = {
                                     grant_type: 'refresh_token',
                                     refresh_token: token.refreshToken,
                                     client_id: process.env.GITHUB_APP_ID,
                                     client_secret: process.env.GITHUB_APP_SECRET,
                                 };
                             
                                 const res = await axios.post(url, null, {            
                                     headers: {
                                         'Content-Type': 'application/x-www-form-urlencoded',
                                         'Accept': 'application/json',
                                     },
                                     params : params 
                                 })

                                 const refreshedTokens = await res.data

                                 if (res.status !== 200) {
                                     console.log('실패', refreshedTokens)
                                 }
                             
                                 // 2. 재발급한거 출력해보기 
                                 console.log('토큰 재발급한거 : ')
                                 console.log(refreshedTokens)
                                 
                                 // access_token=ghu_8afeApnRAkzkBYDmshCKqq6uyKJunA1EScAS
                                 // &expires_in=28800
                                 // &refresh_token=ghr_IZNb9vbPyu8FnSpnP1fLP0DQPq1EVH2JLB6HMOjgBaeGbZSo3dHJihM46QM5cX1odrOUYe1OhZxc
                                 // &refresh_token_expires_in=15811200
                                 // &scope=
                                 // &token_type=bearer   
                             
                                 // 3. 이걸로 새로운 토큰 만들어서 return 해주기 
                                 let data = new URLSearchParams(refreshedTokens);

                                 if (data.get('error') == null){
                                     return {
                                        ...token,
                                        accessToken: data.get('access_token'),
                                        accessTokenExpires: Math.round(Date.now() / 1000) + Number(data.get('expires_in')),
                                        refreshToken: data.get('refresh_token')
                                     }
                                 } else {
                                     return token
                                 }
                             } 
