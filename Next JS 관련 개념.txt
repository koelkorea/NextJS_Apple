- 프론트엔드 기반의 '풀스택 프레임워크'들의 등장 배경 타임라인 및 이유

   1. client-side rendering (CSG)의 단점부각
       -> 첫 페이지 진입시 로딩이 상대적으로 엄청 오래 걸림 + 검색엔진의 노출이 좀 많이 어려움
           -> 웹서비스 트래픽 늘리기가 상대적으로 어렵고, 결국 수입지표적으로 어려움이 많이 생김 

   2. server-side rendering (SSG)의 장점이 다시 주목되고 다시 대세가 변하는 중
       -> client-side rendering (CSG)의 기능 및 성능향상의 최적화를 위해 알아야 했던, 프론트엔드의 전문성이라고 부르던 것들이 별로 필요함
          (= server-side rendering (SSG)을 사용하면, 결과적으로 그 딴거 쓸 이유가 사라지고, 상대적으로 프론트엔드 개발의 복잡성이 많이 줄어듬)

   3. NodeJS로 이제는 백엔드 개발도 JS로 가능해진 시대가 되었음
       -> CSG를 안 쓴다면, 그 CSG에 특화된 복잡한 개발력이 필요없어지니, 그만큼 백엔드를 만질 수 있는것도 중요
    
   4. 프론트엔드와 백엔드를 JS를 중심으로 통합된 개발환경을 제공할 수 있다면 엄청 유용할거 같음
       -> 가장 점유율이 높은 react 기반으로 각종 프론트엔드 기반의 풀스택 프레임워크('렌더링 프레임워크', 'meta 프레임워크'라고 불림)들이 등장하기 시작함
          (= Next.js 도 그 중 하나)

          ex) GatsBY, nuxt, sveltekit, remix, Next.js


- Next.js
   : react 라이브러리 기반의 '풀스택 프레임워크'로 이걸로 JS기반으로 화면과 웹서버 전부를 통합적으로 개발 가능하고, 쉽게 서버 및 화면에 대한 설정이나 기능 또한 도입이 가능함
      -> 웹서버 개발에 대한 수요가 반영 = 상대적으로 client에 많이 역할을 떠넘긴 CSG보단, JS만으로 SSG 기반 웹서비스를 상정하고 개발된 프레임워크


    # Next.JS를 배우는게 유리한 이유 + 장점

       @ Next.JS 장점
          1. GPT의 템플릿 기능이 나날이 발전하고 있기에, 점점 노가다성 개발력은 사라져가고 낮은 수준의 업무 장벽은 많이 줄어든 상태니, 개발자로서 풀스택적으로 범용성이 넓어 나쁠건 없음
 
          2. 프론트엔드 기반 통합 프레임워크들의 사용방법도 나날히 쉬워지기에, 미래의 개발환경의 점유율이 높아질 수 있기에 대비해서 나쁠건 없음
  
              ex) 회원인증 기능도 Next-auth 라이브러리를 끌어다 쓰면 10초면 구현 가능
 
          3. react기반이기에 react 문법을 사용하여, 특히나 쉽게 입문 가능
 
          4. GatsBY, nuxt, sveltekit, remix, Next.js 중 Next.js가 가장 꾸준하게 많이 쓰고, 만족도 수준과 유지력도 좋다는 점에서, 나중에 미래는 이 녀석이 될 확률이 높음
 
          5. 14버전 부터는 각종 편의성이 매우 증가함
              1) 폴더 기반 자동 라우팅으로 폴더와 JS파일만 만들면, 자동으로 잡아내서 HTML페이지를 생성해 줌
              2) 서버API 기능이 개선
              3) 더 쉬운 DB연결
              4) 직관적으로 rendering 전략 선택할 수 있는 기능이 존재 = SSG, CSG를 선택 가능하며 JS 없는거도 개발 가능 
              5) hydration 없는 server-side rendering
              6) 파워풀하고 쉬운 캐싱
              7) 이미지와 폰트 최적화
    
       @ Next.JS 단점
          1. react 라이브러리의 신문법인 client component, server component의 구분을 적극적으로 하는데, 이를 구분해서 코드를 짜는게 프로젝트 커지면 복잡할 수 있음
   
          2. WebSocket, WebRTC 같은 기능은 제대로 지원하지 않음 
             (= 직접 Nodejs + express 서버를 하나 더 만드는게 나음)
   
          3. HTML 랜더링에 기능이 집중되어 있고, 서버기능 쪽은 아직 상대적으로 갈 길이 멀다는 점
   
          4. 14버전인데 아직도 프레임워크 자체 버그가 종종 보임
              -> react 라이브러리를 적극 반영한건 좋은데, 아직 react가 구현하지 않은 미완성 기능들까지 도입해놓은 것 포함
   
          5. 14버전부터 폴더 기반 자동 라우팅 기능이 강화된 덕분에, 프로젝트 커지면 관련 예약 파일들이 많아져 복잡도가 올라갈 수는 있음


    # Next.js 프로젝트 생성 (= 서버까지 생성)
      1. nodejs 설치
      2. 작업폴더만들고 에디터로 오픈
      3. 터미널에 npx create-next-app@latest 입력
          -> (참고) 이 명령어가 'npm init -y'로 대표되는 node 서버의 초기화 기능까지 담당해 줌

      4. 프로젝트 설정을 결정해야 하는데, App Router는 사용한다 체크하고 나머지는 적절히 체크

         ex) 프로젝트 이름, App Router 사용할 건지, Typescript 사용여부, ES lint 사용여부, Tailwind CSS 사용여부, src 폴더 사용 여부, import alias 사용시 어떤 문자를 쓸건지 등

      5. page.js에 존재하는 기본 예시 화면에 대한 코드인 return 부분 다 지우고 <div></div>만 적고 코딩 시작
      6. global.css의 내용도 전부 지우기
      7. 터미널에 npm run dev 를 입력 = 서버 미리보기 띄우기 (page.js가 메인페이지)
      8. http://localhost:3000 으로 접속


    # 프로젝트 파일들
       1. app 폴더 : react와 비슷하게 화면 관련 코드들이 들어있는 핵심 폴더

          1) page.js  
              : 메인 페이지에 해당하는 JS파일
                 -> (참고) URL을 통한 웹페이지 Router 기능을 구현
                      : app 폴더 안에 다른 폴더를 만드는 식으로 단계별로 폴더를 만들고, 그 안에 page.js를 제작하면 됨  

          2) layout.js
              : 메인 페이지를 감싸는 용도로 제작된 JS파일
                 -> 참고사항
                     a. RootLayout({ children })라는 functional component로 구성
                         : parameter인 js객체 children은 각 폴더 위치 및 url에 대응하는 page.js를 의미하며, {}내 배치는 그 녀석이 위치할 곳을 의미 
                           (= 가장 바깥쪽의 layout.js의 함수 RootLayout({ children })의 children은 가장 바깥에 작성한 page.js에 해당하는 react의 App 컴포넌트 역할)

                     b. 동작방식
                        : app 폴더 안에 다른 폴더를 만드는 Router 기능을 구현 시 최상위의 layout.js를 가장 바깥, app 폴더를 기준으로 layout.js를 가장 마지막에 적용하는 양파같은 구조로 웹페이지 조립을 해줌
                          (= app 폴더를 기준으로 layout.js는 모든 하위 웹페이지들에 모두 적용됨)
                              -> (중요) js의 이벤트버블링이 작동하는 방식과 유사함을 명심하자... 대상 page.js 자기가 닿지 못한 폴더의 layout.js는 적용 못한다고 생각하면 이해가 편함

                                  ex) <head> 태그의 내용들을 여기다 담기도 함 
                                  ex) 페이지 간 공용으로 사용하는 component들의 경우
                                       -> 상단 navigation 같은 녀석들

          3) globals.css
              : 모든 페이지에 적용되는 전역 style들을 적는 css파일

          4) js파일명.node_modules.css
              : 특정 js파일명을 가진 JS 페이지에만 적용되는 style들을 적는 css파일

          5) api 폴더
              : node JS 본연의 기능인 웹서버 관련 기능을 담당하는 JS코드들이 모여 있는 app 폴더 내부의 폴더
 
          6) public 폴더
              : 이미지, 폰트 static 파일들을 보관하는 app 폴더 내부의 폴더 

       2. 그 밖에 존재하는 파일/폴더들

          1) next.config.js   
              : nextjs 설정 파일

          2) node_modules 폴더
              : 프로젝트 구동에 필요한 node JS 기반 라이브러리 보관용 폴더 
                 -> npm을 통해 다운받은 내용들을 다 여기 보관

          3) package.json     
              : npm 명령어 내용과 설치한 라이브러리 버전 기록용 파일.. 
                 -> 이거 하나면, 나중에 npm install 한 방으로 모든 라이브러리를 npm에서 다시 다운로드 가능

 
    # React 라이브러리의 JSX 문법(functional component를 기반으로 설명) 대략 정리
       -> React 기반의 프레임워크 Next.js에서 페이지 layout작성을 위한 문법.. 
          (심화된 내용을 내용을 원한다면, react 쪽 문서 참고)

          1. functional component 관련 
          
            @ component 만드는 과정

              1) 컴포넌트 만들고 싶으면 우선 function을 만들고 작명 (관습적으로 영어 대문자)
              2) function의 return () 안에 해당 component 단위를 구성하는 HTML 기반의 코드에 대한 내용이 기입되어야 함
              3) 원하는 곳에서 <작명/> 을 사용
 
                 ex) <작명> 이라는 임의의 component를 정의해서 사용
                 
                     export default function Cart() {
                       return (
                         <div>
                           <h4>Cart</h4>
                           <작명></작명>
                           <작명></작명>
                         </div>
                       )
                     }
                     
                     function 작명(){
                       return(
                         <div className="cart-item">
                           <p>상품명</p>
                           <p>$40</p>
                           <p>1개</p>
                         </div>
                       )
                     } 

            @ component 장/단점

               (장점)
                 a. component 들을 쉽게 재사용 가능 
                     -> (보통 배열명.map(콜백함수) 이거랑 조합)

                 b. 해당 component에서 통용되는 state 객체의 데이터들은 캡슐화가 되어 있음
                    (= 다른 component로 부터 값을 보호 가능하며, 자신의 값은 자신들만 조작이 가능한 구조)

                 c. component의 state객체가 변하는 부분에 한해서, 해당 영역의 component 부위만 다시 랜더링 가능
                    (= 페이지 재랜더링을 딱 변화가 필요한 부분만 하니 작업 효율과 성능이 올라감)

               (단점)
                 a. component 간 state 객체의 값을 전달받는 방법은 자기 후손들에게 일일히 props 객체를 구성해서 전달하는 방법 뿐이 없음 
                    (= 형제 component간 값을 주고받을 수 없고, 부모에게 값을 주는 방법도 없고, 오로지 받기만 해야함)

            @ functional component 작성시 주의사항
               1) (중요!) 각 component를 구성하는 최상위 HTML 태그에 해당하는 녀석은 '반드시' 1개만 허용됨

                   ex) 최상위 태그가 2개 (X)

                       return (
                         <div></div>
                         <div></div>
                       )

                   ex) 굳이 하고 싶다면, 다른 최상위 태그로 감싸자 (O)

                       return (
                         <> 
                           <div></div>
                           <div></div>
                         </>
                       )

               2) HTML 기반의 코드 = HTML 문법과 유사하나, 결과적으로는 HTML과 유사할 뿐, 여러 부분에서 JSX에서만 통용되는 유사 HTML 문법이라고 보면 됨
  
                   ex) JS변수의 값을 {}를 통해 넣거나, 각종 속성명이 HTML 원본의 그것과는 다르게 설계, style 속성값 작성법이 js객체 형식으로 작성되어야 함

               3) functional component의 HTML영역 작성시 함수 {} 내의 JSX변수 값을 넣고 싶을때는 어디서든 { JSX변수명 }을 사용하자
                   -> (중요) className, id, href 이런 HTML 속성에 해당하는 값에도 사용이 가능
                       -> (참고) ES6 이후 백틱(``)을 통한 문자열 작성시 JS에서도 `문자열어쩌고 ${JS변수명} 끝`과 같은 식으로 변수의 값을 문자열 도중에 끌어들일 수 있음

                           ex) HTML 속성에 해당되는 값이라도 상관없이 {}를 쓰면 함수 내부의 지역변수명을 사용 가능

                               export default function Home() {

                                 let name = 'park';
                                 let link = 'https://naver.com';

                                 return (
                                   <div>
                                     <h4 className="title">애플후레시</h1>
                                     <p className="title-sub">by dev {name}</p>
                                     <a href={link}>링크</a>
                                   </div>
                                 )
                               }

            @ functional component 작성시 HTML 속성넣기

               1) HTML에서의 class 속성 -> className으로 기입
                   : JS의 class라는 예약어가 class 문법과 관련해서 이미 존재하고 있기 때문
                     (= 작성하는 JSX파일의 functional component도 따지고보면, JS영역이라고 볼 수 있음) 
     
                     ex) JSX에서는 class (X) -> className (O)
     
                         export default function Home() {
                           return (
                             <div>
                               <h4 className="title">애플후레시</h4>
                               <p className="title-sub">by dev kim</p>
                             </div>
                           )
                         }
     
               2) functional component의 HTML영역 작성시 inline style 형식으로 style 값을 넣고 싶으면, 'JS객체 자료형' 형식으로 작성해야 함 
                  (주로 동적으로 component에 style 변경이 필요한 경우 쓰이곤 함)
     
                   ex) JSX에서의 component의 style 작성 형식 
                        : {{ style속성명1 : '값1', ... , style속성명N : '값N' }}
        
                          export default function Home() {
                            return (
                              <div>
                                <h4 className="title" style={{ color : 'red', fontSize : '20px' }}>애플후레시</h4>
                                <p className="title-sub">by dev {name}</p>
                              </div>
                            )
                          }
     
               3) (주의) style 속성 작성시 주의사항
                  : '-'이 들어간 style속성명의 경우, camalCase 형식으로 작성해 줘야 함
                      -> 'JS객체' 형식 내부에 입력되는 style 속성명은 '-'을 인식할 수 없기 때문임 
     
                          ex) font-size -> fontSize
     
               4) react의 CSR 방식의 Routing기능을 만들고 싶다면, component 반환값 html 레이아웃을 작성시, <a>태그 대신 Link를 import하고 대신 쓰면 됨
                  (새로고침없이 부드럽게 페이지 이동이 가능하다는 장점이 있음)
                 
                  ex) import Link from "next/link";
                  
                      <body>
                        <div className="navbar">
                          <Link href="/">Home</Link>
                          <Link href="/list">List</Link>
                        </div>
                        {children}
                      </body>

            @ functional component 고유의 이벤트속성 문법 (= react 전용 JSX 이벤트헨들러 문법)
               : functional component의 HTML영역 작성시, HTML의 이벤트속성과 유사한 이벤트핸들러 문법으로 CSR방식으로 동작하는 이벤트를 작성 가능함
                  -> CSR방식으로 동작하게 설계되어 있는 문법이니, Client component에서만 사용가능
                     (= page.js 맨 위에 'use client'를 적어놔야 함) 

                (JSX 이벤트헨들러 사용법)
                  : functional component의 HTML영역 작성 중, camalCase이벤트속성명 = {콜백함수} 형식으로 이벤트 수행시 내용을 작성
                      -> 이와 component의 상태값을 관리하는 state객체와 연계되어, state객체의 변경이 감지되면 해당되는 component 부분에 한해서 비동기적으로 화면을 실시간으로 변경
                         (= 사실상 CSR방식으로 동작하는 react의 사용목적을 생각하면, 사실상 이벤트핸들러는 해당 방식으로 강제되는 셈이나 다름없음)

                          ex) onClick, onMouseOver, onChange 등등이 존재함...
                          
                             <button onClick={()=>{ 이름변경('park') }}>버튼</button> 

          2. props/state 객체
              : CSR(client side rendering) 방식으로 component에서 새로고침되지 않고, 웹서버의 응답과 별개로 비동기적으로 통신하며 실시간으로 화면의 값을 변경하여 재랜더링 해주는데 필요한 component들의 값과 관련된 대한 객체
                (= react에서 CSR(client side rendering) 방식을 구현하는 핵심 개념이기에, server component 사용시에는 사용 불가)

             @ (중요!) CSR 방식에서의 component의 특징 (= react에서의 component의 특징)
                : 개별 component는 자신을 실시간으로 변경하고 저장하는데 있어 필요한 값들을 state라는 하나의 객체에 '캡슐화'해서 관리
                  (= 자기 {}에서만 작동하는 지역객체인 state객체를 통해, 다른 component에 영향을 주지 않고, 영향도 받지않는 폐쇄성 유지)
                      -> 다른 component에 값을 전달할 필요가 있다면? 부모 component -> 자식 component 1방향으로 props 객체로 필요한 값들을 parameter형식으로 통해 전달
                          -> (참고) But..? 자식 component도 fetch를 통해 서버에 필요한 데이터를 요청할 수 있다는 점은 편의성 증진에 도움이 됨  

             @ props 객체
                : 부모 component -> 자식 component로 연계에 필요한 값들을 보낼 목적으로 사용되는 JS객체
                   -> 자식 component에 1번째 parameter 형식으로 보내지며, {1번째parmeter명.멤버변수명} 형식으로 꺼내쓸 수 있음

                 (props 객체를 통해 자식 component에 값을 전달하는 법)
                  a. (중요) CSR방식으로 동작하는 기능의 코드를 짜는 것이므로, 'use client'; 를 작성
                  b. 부모 component의 HTML 반환값 부분에 가서 <자식component명 = {전해줄데이터} or "원시값" /> 이런식으로 작성
                  c. 자식 component의 함수 정의 영역으로 가서 props라는 parameter를 등록 후 {props.멤버변수명} 이런식으로 호출 

                     ex) props 객체에 '상품'이란 멤버변수를 담아 CartItem 컴포넌트로 보내면, 해당 컴포넌트는 'props.상품'으로 해당 값을 꺼내쓸 수 있음

                         export default function Cart() {
                           let 장바구니 = ['Tomatoes', 'Pasta']
                           return (
                             <div>
                               <h4>Cart</h4>
                               <CartItem 상품={장바구니[0]}/>
                               <CartItem 상품={장바구니[1]}/>
                             </div>
                           )
                         }
                         
                         function CartItem(props){
                           return(
                             <div className="cart-item">
                               <p>{props.상품}</p>
                             </div>
                           )
                         }  

                 (props 객체 주의사항) 
                   a. 오직 부모 component-> 자식 component 간 1방향 전송만 가능
                      (= '자식 -> 부모' or '형제간 전송' or '선조 -> X대' 직계 전달 다 해당 안 됨)

                   b. X대 자손 component에 선조 component가 props객체를 보내려면, 귀찮아도 X번 props객체를 통해 값을 되물림해야 함

                   c. props 객체로 부모 component가 보낼수 있는 멤버변수의 갯수는 제한X
                     
                      ex) <CartItem 이런거={이런거}  저런거={저런거} ..... 캡틴={하루종일도가능해}> 이렇게 많이 전송 가능

                   d. props객체 : functional component = parameter : function 의 관계라는 점은 중복의 최소화를 유도 가능

             @ state 객체
                : component를 구성하는 값들을 관리하는 객체
                   -> 실시간으로 state 객체값의 변동이 감시되면? 변화한 state변수를 사용하는 component에 한해서만, 서버의 응답과 상관없이 먼저 비동기적으로 재랜더링을 해줘서 사용자 경험을 높히는 핵심 JS객체
                
                 (state 객체에 멤버변수를 선언하고 초기화하고, setter함수 선언하기)
                   a. (중요) CSR방식으로 동작하는 기능의 코드를 짜는 것이므로, 'use client'; 를 작성
                   b. 상단에 import {useState} from 'react'를 작성해서 import 준비
                   c. (중요) react 18버전 이후, state객체에 멤버변수와 setter함수를 선언할 때는 useState(초기값)함수로 구조분해 할당 문법을 사용함
                        -> useState(초기값) 함수는 [어떤 state의 초기값, 해당 state의 setter함수]를 반환하는데, 이를 구조분해구문을 통해 각각 [state변수명, 해당setter함수명]에 대입

                           ex) let [state멤버변수명, 해당setter함수명] = useState(초기화값 or [초기화배열] or {초기화 객체} );

                   d. 해당 state객체가 속한 component의 HTML 반환값 부분에 가서, {state멤버변수명}으로 해당 state객체멤버값이 위치할 곳을 정해주고, 이벤트핸들러의 {콜백함수}의 내용에 {해당setter함수명(값)}을 넣어줘서 setter사용
                      (= setter함수가 존재하는 JSX 이벤트핸들러가 작동하는 순간, 해당 state객체변수를 사용하는 component의 부분에 한해서만 바로 재랜더링이 완료됨)

                      ex) 'use client';
                          import { useState } from 'react'
                          
                          export default function List() {
                          
                              let [수량, 수량변경] = useState([0, 0, 0]);
                          
                              return (
                                  <div> 
                                      <h4 className="title">상품목록</h4>
                                        <div className="food" key={인덱스}> 
                                            <button onClick = { () => { 
                                                let copy = [...수량];
                                                copy[인덱스]--;
                                                copy[인덱스] < 0 ? null : 수량변경(copy) } }>-</button>
                                        </div>
                                  </div>
                              );
                          }


                 (state 객체 사용시 주의사항) 
                   a. 'state멤버변수명' 변수의 초기값은 useState의 parameter에 넣은대로고, 해당 멤버변수를 수정하고 싶으면 '해당setter함수명(수정값)'을 기입하면 됨
                      
                      ex) '이름'이란 state멤버변수의 초기값은 'kim'이고, 이를 바꾸려면 '이름변경('변경 이름')'을 호출하여 HTML 영역에 채움
                      
                          let [이름, 이름변경] = useState('kim');

                          <h4>{이름}</h4>
                          <button onClick={()=>{ 이름변경('park') }}>버튼</button> 

                   b. state멤버변수를 만드는 이유는 서버에 변경된 값을 전하는 것과 별개로 state객체의 멤버변수의 변화가 감지되면 실시간으로 비동기적 랜더링 로직이 해당 state변수를 사용하는 부분에 한해서만 작동
                      (= CSR의 목적 자체가 사용자의 웹서비스 경험을 증진시키는데 있음)
                          -> But.. 그런만큼 모든 변수를 다 state변수로 처리하면, 그건 자원낭비와 성능의 저하로 이어진다는걸 기억하자

                   c. useState(초기값) 함수의 초기값 부분에는 여러 변수의 값이 들어있는 [배열] 기입이 가능함
                       -> BUT! 해당setter함수명()을 통해 state객체의 멤버변수값의 변화는 '부분적인 요소값'은 안 되고, [배열] 전체를 바꿔야 변경됨
                          (= 배열명.map(콜백함수)를 통해, 데이터들의 반복적인 부분을 component로 작성해도 setter함수(배열명[인덱스]) 이런식으로 써봐야 해당 부분의 state객체의 멤버배열요소가 수정되지 않음)

                          ex) 초기값이 [배열]인데 setter함수에 paramter로 배열요소를 지정해봐야 수정은 일어나지 않음
                          
                              let [이름, 이름변경] = useState(['Tomatoes', 'Pasta', 'Coconut']);

                              <button onClick={()=>{ let copy = 이름[인덱스]
                                                      copy[0]++
                                                      수량변경(copy)
                                                     }}>+</button>

                   d. '해당setter함수명(수정값)'를 호출하면, 반환된  기존state객체값 === 신규state객체값인지 확인 후, 같은게 확인되어 component에 재랜더링할 부분이 없다면 굳이 새로 랜더링하지 않음
                       -> (중요) c의 경우와 같이 state객체변수 = [배열]이 초기값이면, [배열]이 참조 자료형인걸 모르고 '깊은 복사'를 안하고 '얕은 복사'를 하는 경우 당황하기 마련인데 그러지 말자

                          ex) 참조 자료형을 '얕은복사' 하는 예시
                               -> [1,2,3]이 위치한 주소값을 저장하는 arr을 arr2에 대입하면, 둘은 사실상 같은 값을 공유하는 셈

                              let arr = [1,2,3]
                              let arr2 = arr
                              arr2[0]++
                              console.log(arr2 == arr)

                          ex) state객체변수값을 '얕은복사(shallow copy)' 한 뒤 수정하면?
                               -> 'copy'와 '수량' 변수는 사실상 같은 값을 공유함 

                              let copy = 수량
                              수량[0]++
                              수량변경(copy)      <-  state변경함수를 써도 기존state == 신규state라서 state변경을 안해 줌

                   e. (c, d의 사례가 있기에) state객체변수의 초기값으로 [배열]을 둔 경우, 해당 [배열]을 수정하고 이를 component 재랜더링까지 가게하기 위해서는?
                       -> 이벤트헨들러의 콜백함수의 내용 영역에 [배열]값을 spread operator문법( [...], {...} )을 통한 '깊은복사'를 한 뒤에 setter함수를 사용하자
                           -> (참고) spread operator문법( [...], {...} )
                                : 대상 변수가 가리키는 메모리 영역에 위치한 컨테이너 데이터의 캡슐화를 해제하고 개별 데이터들을 각각 다른 영역에 복사한 뒤, 이들을 다시 독립적인 컨테이너 자료형으로 캡슐화하고 그 포인터값을 참조로 반환하라는 이야기

                          ex) 참조 자료형을 spread operator문법( [...], {...} )을 통해 '깊은복사(deep copy)' 하는 예시
                               -> spread operator문법( [...], {...} )를 통해 요소나 멤버의 값 자체가 복사된 컨테이너 데이터는 원본 컨테이너 데이터와 완전히 독립적인 데이터

                              let arr = [1,2,3]
                              let arr2 = [...arr]
                              console.log(arr2 == arr);  // false

                              let obj = {멤버1 : a, 멤버2 : b}
                              let obj2 = {...obj}
                              console.log(obj2 == obj);  // false

                          ex) state객체변수값을 spread operator문법( [...], {...} )을 통해 '깊은복사' 한 뒤 수정하고, setter함수를 통해 수정하면
                               -> 'copy'와 '수량' 변수는 아예 각각 다른 [배열]을 참조하고 있기에, '수량' 변수의 [배열]이 수정되고, 이것이 setter함수에 들어가면 state객체값인 [배열]이 다른 것으로 확인되어 state객체가 변하고 화면의 재랜더링이 이뤄짐

                              let copy = 수량
                              수량[인덱스]++
                              수량변경(copy)      <-  수량 != copy라서 다른 배열값으로 판정되어 state변경을 이행하여 component 영역의 변경된 부분에 재랜더링이 일어남

          3. '배열명.map( (요소값, 인덱스) => { 요소값, 인덱스 사용 내용 return 문 } )' 함수를 통해, functional component의 return값을 반환하는 HTML 안에서 반복문 사용 가능!
               -> js에도 배열명.map이 있고, JSX에도 있지만, 반환되는 HTML 내부에는 JSX의 map구문이 사용된다고 보면 됨

             @ 왜 for, if문을 문법 안 쓰나?
                : JSX의 functional component의 return값을 반환하는 HTML 안에는 for, if문을 문법을 사용할 수 없음
                  (= return값을 반환하는 HTML밖에서는 얼마든지 JS의 문법을 사용해도 전혀 문제가 없음)

             @ (주의) 배열명.map( (요소값, 인덱스) => { 요소값, 인덱스 사용 내용 return 문 } ) 사용시 주의사항
             
                1) JSX 문법으로서 배열명.map(콜백함수) 함수를 쓰고 싶다면, component의 HTML layout의 반환문 내에 {}를 적고 그 안에 작성하면 됨       
                2) (중요) map(콜백함수) 함수는 parameter인 콜백함수를 통해 요소값, 인덱스를 사용하여 순차적으로 반환된 요소를 통한 배열을 반환함

                    ex) console.log(newArray); 로 [20, 30, 40] 반환
                    
                        var 어레이 = [2,3,4];
                        var newArray = 어레이.map((a)=>{
                          return a * 10
                        });
                        
                3) return문은 필수는 아니나, 이게 없으면 map(콜백함수)함수를 통해 가공하여 생성되는 배열은 없음 
                   (= 연산은 해주기에 console.log 같은거로 값을 보여는 주지만, 함수 {}를 넘어가면 거기서 끝이라는 이야기)

                    ex) return이 없어서 console.log(newArray); 해봐야 빈 배열 반환
                    
                        var 어레이 = [2,3,4];
                        var newArray = 어레이.map((a)=>{
                          a * 10
                        });

                4) 배열명.map(콜백함수)함수의 콜백함수의 1번째 parameter는 뭘 넣어도 각 '배열요소의 값'이며, 2번째 parameter는 뭘 넣어도 각 '배열의 인덱스'를 의미
                    -> (참고) 이 parameter들은 콜백함수 작성시 없어도 됨 (= 얘들이랑 관계없는 값을 반환해도 된다는 것)

                    ex) return이 없어서 console.log(newArray); 해봐야 [10, 10, 10] 배열 반환
                    
                        var 어레이 = [2,3,4];
                        var newArray = 어레이.map((a, i)=>{
                          return 10
                        });

                5) return값으로 component의 HTML layout을 반환해도 react는 JSX 형식으로 작성된 component를 잘 파싱하고 rendering함  
                    -> (참고) 배열명.map(콜백함수)를 사용 시, 각 반복된 component를 구분하기 위해 react는 고유값으로 key 속성을 넣을 것을 권장하는데, 보통은 index값을 넣음                  

                        ex) [ <div></div>, <div></div>, <div></div> ] 이런 구조의 배열이 반환되고, 이것이 List라는 component의 일부로서 반환되고 rendering 됨
                        
                            export default function List() {
                            
                                let 상품 = ['Tomatoes', 'Pasta', 'Coconut'];
                            
                                return (
                                    <div> 
                                    <h4 className="title">상품목록</h4>
                                    { 
                                        상품.map((개별상품)=>{
                                            return ( 
                                                <div className="food" key={인덱스}> 
                                                    <h4>{ 개별상품 } $40</h4>
                                                </div>
                                            )
                                        })
                                    }
                                    </div>
                                );
                            }

                6) JS의 for문으로 이를 구현하고 싶다면?
                    : HTML영역 바깥쪽에서 array를 for문을 통해 만들고, 이를 JSX의 배열명.map(콜백함수)를 통해 rendering 할 수 밖에 없음 
                       -> 다른 내용을 다루지만, 대상 배열과 같은 수의 index를 가지고, 대상 배열의 요소 값을 입력 가능하면 더 좋음

                           ex) 상품 문자의 갯수가 가격과 연관된 경우의 구현
                           
                               export default function List() {

                                   let 상품 = ['Tomatoes', 'Pasta', 'Coconut'];
                                   let 가격 = [];
                               
                                   for(var i = 0; i < 상품.length; i++){
                                     가격[i] = 상품[i].length * 10;
                                   }
                               
                                   return (
                                       <div> 
                                       <h4 className="title">상품목록</h4>
                                       { 
                                           상품.map((개별상품, 인덱스)=>{
                                               return ( 
                                                   <div className="food"> 
                                                       <h4>{ 상품[인덱스] } $ { 가격[인덱스] }</h4>
                                                   </div>
                                               )
                                           })
                                       }
                                       </div>
                                   );
                               }

    # Next.js의 URL에 따른 웹페이지 자동 라우팅 기능 구현법

      1. app 폴더 내부에 폴더를 하나 만들고 작명

      2. (중요) 원하는 폴더 내부에 page.js 파일을 생성하고, 그 파일 내부에 component를 이루는 html 레이아웃을 반환값으로 가지는 functional component 작성
          -> 1) functional component는 무조건 작성해야 하며, 함수명은 맘대로 작명 가능하나, 보통 폴더명이랑 비슷하게 함
             2) (참고) 새로고침없이 부드럽게 페이지 이동이 가능한 react의 CSR 방식의 Routing기능을 만들고 싶다면?
                 : component 반환값 html 레이아웃을 작성시, <a>태그 대신 Link를 import하고 대신 쓰면 됨

                   ex) import Link from "next/link";
                       import './globals.css';
                       
                       export default function RootLayout({ children }) {
                         return (
                           <html lang="en">
                             <head />
                             <body>
                               <div className="navbar">
                                 <Link href="/">Home</Link>
                                 <Link href="/list">List</Link>
                               </div>
                               {children}
                             </body>
                           </html>
                         )
                       }

      3. '도메인/폴더명'을 url로 작성하면, 해당 웹페이지 출력 완료
          -> (참고) '/app/폴더1/폴더2/page.js' 이런식으로 page.js를 형성하면, '도메인/폴더1/폴더2'를 url로 입력하면 해당 page.js 출력 가능 

        @ 웹페이지 Routing 기능
           : url로 웹페이지를 나누고, 사용자의 url명 호출에 따라 웹서버던 클라이언트 측이건 다른 웹페이지를 보여주는 기능

        @ 일반적인 Routing 기능 구현 방식
           : 특정 url을 사용자가 입력하고, 어디에 위치하는 어떤 파일명에 해당하는 HMTL을 보여줄지를 구체적으로 지시
             (= 그러니까, 참 사용자를 귀찮게 한다 이거임) 
                 -> BUT! Next.JS 에서는 사용자를 아주 편하게 만들어 줌 ㅇㅇ
  
                    ex) '도메인/list'라는 url을 사용자가 호출하면, /app/list/에 위치한 '상품목록.js'을 rendering 해주세요 로직

 
    # (layout.js 사용) 페이지 간 공용으로 사용하는 component 공용 layout 만드는 과정 (ex : 상단 navigation) 
       : Next.js는 page.js를 보여줄 때, 그 옆에 layout.js 파일이 있으면 layout.js 내용 안에 page.js 내용을 담아서 보여줌
         (= url과 매칭되는 위치의 layout.js를 기준, 가장 안쪽 폴더의 layout은 가장 먼저 적용, app폴더의 layout은 가장 나중에 적용)

          1. 원하는 url의 component에 해당하는 page.js가 위치하는 곳을 가장 바깥 layout으로 간주하고, 단계별로 layout.js 생성
              -> (중요) js의 이벤트버블링이 작동하는 방식과 유사함을 명심하자... 대상 page.js 자기가 닿지 못한 폴더의 layout.js는 적용 못한다고 생각하면 이해가 편함

              @ app 폴더의 layout.js
                 : 가장 나중에 적용될 layout
                   (= app 폴더를 기준으로 layout.js는 모든 하위 웹페이지들에 모두 적용됨)

                   ex) <head> 태그의 내용들을 여기다 담기도 함 

              @ url과 폴더구조를 기준으로 가장 안쪽부터 바깥쪽인 app 폴더로 올라오는 layout.js들
                 : 가장 안쪽의 layout.js는 가장 먼저 적용될 layout에 적용될 layout

          2. 각 layout.js의 functional component에 해당하는 RootLayout({ children }) 함수의 return영역에 html 레이아웃을 작성하면 됨
      
             ex) import Link from "next/link";
                 import './globals.css';
                 
                 export default function RootLayout({ children }) {
                   return (
                     <html lang="en">
                       <head />
                       <body>
                         <div className="navbar">
                           <Link href="/">Home</Link>
                           <Link href="/list">List</Link>
                         </div>
                         {children}
                       </body>
                     </html>
                   )
                 }

          3. global.css에 style 작성하면 끝
 

     # Next.js에서 이미지를 넣는 방법론 2가지

        1. JSX형식에 이미지 넣는 일반적인 방식 
            : <img src="/port1.png" alt="설명"/> 형식으로 img태그 삽입

          @ <img> 태그 사용시 주의사항
             1) 그냥 html 파일에선 <img> 이렇게 단독으로 써도 되지만, react에서 참고하는 JSX에선 <img></img> 이렇게 쓰거나 <img />로 반드시 태그를 받아줘야 작동함
             2) public 폴더에 있는 것들은 사이트 발행시 자동으로 사이트 root 경로로 이동함
                (= src 속성에 이미지 위치나 주소를 입력할 때, 가급적 public 폴더에 이미지를 넣으면 여러모로 쉬워짐)

        2. Next.js가 지원하는 성능과 속도 측면에서 최적화된 이미지 넣는 법 
            : <Image>라는 Next.js가 지원하는 모듈을 통해 고유의 태그를 사용

              @ <Image> 태그 장점
                  1) 이미지가 늦게 뜨는 lazy loading 방지
                      -> (참고) lazy loading 기능만 원하면 다른 라이브러리 찾아봐도 됨
                  2) 이미지가 늦게 뜰 시, 그 시간동안 화면구조가 지멋대로 변경되는 layout shift 방지
                  3) 사이즈 최적화에 유용함
                      -> (중요!) 최적화는 사이트 다 만들고나서 하는게 좋은 관습이니, 초장부터 여기 집중할 필요 없음

              @ (참고) <Image> 단점
                  1) map(콜백함수)를 통한 반복문 처리시, 다른 이미지 보여주기 좀 난감
                      -> 이미지 주소가 index랑 관계없는 무작위인 경우, src 속성값에 require 같은 함수를 이용해야 할 때도 있음

                  2) 외부 이미지 넣는 조건이 좀 많아서 귀찮음

              @ <Image> 태그 사용 방법
                 1) Image라는 변수로 Next.js의 image 모듈을 import 문법으로 상단에 추가
                     : import Image from 'next/image'

                 2) 넣고 싶은 이미지 또한 상단에 import 문법으로 상단에 모듈로서 추가
                     : import 이미지명 from '이미지경로명(현재 위치 기준)'
                        -> (참고) ''를 쓰기 싫으면 @이미지경로명을 써도 됨

                           ex) import Image from 'next/image'
                               import 이미지 from @./food0.png
                               
                               export default function Home() {
                                 return(
                                   <div>
                                     <Image src={이미지} alt="설명"/>
                                   <div/>
                               )} 

              @ 만약 <Image> 태그로 타 웹페이지의 이미지를 절대경로로 집어넣고 싶다면?
                  -> (결론) 여러모로 귀찮으니, 이럴 때는 img태그 대충 사용하도록 하자

                      1) <Image> 태그 안에 width, height 속성을 집어넣어야 함
                          -> (대안) <Image> 태그 안에 fill="true" 이거 대신 넣고, 부모 <div>가 width, height를 대신 조절

                             ex) import Image from 'next/image'

                                 export default function Home() {
                                   return(
                                     <div width="500" height="500">
                                       <Image src="https://placehold.co/500" fill="true" />
                                     <div/>
                                 )} 

                      2) next.config.js에 images 관련 세팅이 추가로 필요함

                         ex) 이런식으로 images관련 속성을 세팅해줘야 해당 사이트의 이미지 사용가능
                         
                             module.exports = {
                               images: {
                                 remotePatterns: [
                                   {
                                     protocol: 'https',
                                     hostname: '도메인주소',
                                     port: '',
                                     pathname: '/my-bucket/**',
                                   },
                                 ],
                               },
                             }


     # Next.js에서 다중 rendering(SSR, CSR 양쪽 방식 모두 사용 가능)을 지원하는 방법
        : component 종류를 2가지로 지원하여, 개발자가 원하는 방식으로 해당 component 작성 가능
           -> (추천) 웹페이지의 틀은 SSR의 server component로, react적 기능이 필요한 component에 한해서 CSR의 client component 방식으로 제작히여, CSR과 SSR의 장점만 혼합하는 식으로 사용 가능

               1. server component
                   : SSR(Server Side rendering) 방식으로 동작하는 component 단위
                     (= react가 아닌 HTML, CSS, JS만을 사용하겠다는 것을 의미)

                    @ server component 만드는 법
                       : page.js, layout.js 등 Next.js가 기본적으로 편의성으로 제공해주는 component는 전부 server component라고 생각하면 됨

                    @ server component 장/단점
                       -> (장점)
                           1) 웹서버에서 미리 웹페이지를 랜더링해서 보내주는 고전적인 방식으로 성능적으로 속도가 빠름
                             (= 웹페이지 로드시 react에서 처럼 랜더링시 비동기적인 JS코드를 쓸 일이 없으니, 작동 최적화를 생각할 필요가 없기 때문)

                           2) SEO(Search Engine Optimization)에 유리하여, 검색엔진에 노출이 쉬움

                       -> (단점)
                           : component의 반환되는 html 안에 react에서 통용되는 JSX문법을 사용할 수 없음 
                             (= 쉽게말해 react를 전혀 쓸 수 없으므로, useState, useEffect, onClick 이런 거 사용X)


               2. client component
                   : CSR(Server Side rendering) 방식으로 동작하는 component 단위
                     (= react 라이브러이의 방식을 쓰겠다는 의미)

                    @ client component 만드는 법
                       : component 제작시 'use client' 라는 코드를 넣으면 OK

                    @ client component 장/단점
                       -> (장점)
                           : component의 반환되는 html 안에 자유롭게 react에서 통용되는 JSX문법을 사용 가능
                             (= react를 사용할 수 있음) 
                           
                       -> (단점)
                           : 웹페이지 상의 모든 동작과 이벤트를 Client 측에서 새로고침 없이 비동기적으로 처리하는 CSR 방식의 근본적인 문제에 직면

                              1) 웹페이지 용량이 커지게 됨
                                  : react의 JSX문법에 해당하는 JS코드가 늘어남 + CSR을 위해서는 모든 조작에 반응해야 하므로 다운로드 받을 HTML, CSS, JS 파일이 많을 수 밖에 없음

                              2) 웹페이지 로딩속도도 약간 느려질 수 있음
                                  a. Client 측에서 초기에 필요한 정보들을 서버에 API로 호출하고, 이를 직접 랜더링해야 하기 때문
                                  b. JS로 구현된 React 문법을 적용하는 과정에서, JS로 html을 읽고 분석하는 과정인 hydration에 소요되는 시간도 추가로 발생
                                  

     # Next.js의 module(작게 분리한 프로그램 개별 파일) 시스템
        : 일반적인 JS와 전혀 다를 것이 없으니, ES6 이후로 공식화 된 ES모듈의 import/export 방식 그대로 쓰면 됨
          (= 물론 require로 대표되는 CommonJS 문법도 사용은 가능함)

          1. export
              : 특정 변수, 함수 등을 외부 파일에서 가져다 쓸 수 있는 모듈로서 내보내는 모듈화를 시킬 떄 쓰는 문법.. 파일별로 1개만 사용 가능
                 -> (중요!) But 변수나 함수나 선언할 때마다 export를 붙이는건 제한이 없고, 선언된 게 1개면 당연히 default도 사용가능

                    1) export default 변수명 or 함수명
                        : 단일 변수, 함수만 모듈로 내보낼 경우 사용하는 문법
                           -> default 자체가 '해당 모듈엔 개체가 하나만 있다'는 사실을 암시하며, import로 모듈을 가져올 때 {}가 필요없게 함 

                    2) export {변수명, ... , 함수명} 
                        : 여러 함수나 변수를 모듈로 내보낼 경우 사용하는 문법

          2. import
              : export된 모듈을 외부 파일에서 가져다 쓸 때 쓰는 문법 
                 -> 보통 파일 가장 최상단에 사용

                    1) import 변수명 or 함수명 from '모듈경로명'
                        : default export 된 변수나 함수를 모듈로서 가져올때 사용하는 문법
                           -> default가 들어갔으니, {}를 쓰면 안되며, as는 필요없이 꼴리는 변수명을 붙이면 됨

                              ex) import 꼴리는변수 from "./data.js"

                    2) import {변수명, ... , 함수명} from '모듈경로명'
                        : 여러 함수나 변수를 모듈로 가져오는 경우 사용하는 문법
                           -> as 별칭을 통해, 변수명처럼 쓸 수도 있음

                    3) import * from '모듈경로명'
                        : 해당 모듈에서 export한 모든 함수나 변수를 모듈로 가져오는 경우 사용하는 문법
                           -> But 이렇게 하면 어떤 변수나 함수를 사용하는지 알 수 없고, 불필요한 내용까지 가져오는 경우가 있어 성능이나 코드 구조 파악이나 모두 힘듦


    # Next.JS와 MongoDB 관련 특수지식들
       1. MongoDB 세팅은 일반적으로 Node.js에 하는 것과 차이 없음
           -> DB연결용 보일러플레이트 코드도 new MongoClient(url, options).connect()의 값을 모듈분리하여 export 시켜도 전혀 문제없음

       2. Next.JS에서 MongoDB를 사용한다는건, React 라이브러리와 DB를 같이 쓰는 것이라고 볼 수 있음
          (= import한 모듈화된 연결변수와 DB호출함수는 component 안에 지역변수처럼 해줘야 component내에서 정상동작하는데 유리함)

       3. (중요) DB입출력하는 코드는 server component 안에서만 사용해야 함
           -> client component 안에 적은 코드는 유저들도 쉽게 볼 수 있음!!

       4. Next.Js에서 작성을 권하는 DB연결변수를 분리 모듈로서 관리하는 database.js의 MongoDB 관련 보일러플레이트 코드는 다음과 같음
           -> Nextjs의 경우 개발환경에서 JS파일을 작성 중이라 갱신할 때마다 JS파일들을 다시 읽어들이고 코드를 재실행함
              (= DB연결 객체인 MongoClient.connect()가 동시에 여러 개 실행될 수 있고, DB의 성능낭비가 심해지는 문제 발생)
                  -> 방지 차원에서 개발중임이 확인되면 Next.JS에서 가지고 있는 global이라는 전역변수 객체에 연결정보를 저장할 수 있음

                     ex) import { MongoClient } from 'mongodb'
                         const url = 'DB접속URL~~'
                         const options = { useNewUrlParser: true }
                         let connectDB
                         
                         if (process.env.NODE_ENV === 'development') {
                           if (!global._mongo) {
                             global._mongo = new MongoClient(url, options).connect()
                           }
                           connectDB = global._mongo
                         } else {
                           connectDB = new MongoClient(url, options).connect()
                         }
                         export { connectDB }


       5. 비동기코드이기에 promise문법으로 통제되는 DB연결로직이 선행되기에, DB호출코드들을 export 시키면 안정성이 떨어진다는 문제에 대한 Next.js 솔루션?
           -> Next.Js는 현재 next.config.js파일에서 실험단계인 top-level await 기능을 true/false로 해금할 수 있게해서, true시 DB호출코드까지 export해도 안정적으로 작동할 수 있도록 기능을 추가중임
               -> But! nodejs 버전이 낮으면 못쓰는 기능이라.. 클라우드를 쓰기라도 할 경우 서버가 지원안해주면 못 씀

                  ex) next.config.js 파일열어서 webpack(){} 부분을 참고
                  
                       /** @type {import('next').NextConfig} */
                      const nextConfig = {
                        experimental: {
                          appDir: true,
                        },
                        webpack(config) {
                          config.experiments = { ...config.experiments, topLevelAwait: true }
                          return config
                        }
                      }
                      module.exports = nextConfig