- 프론트엔드 기반의 '풀스택 프레임워크'들의 등장 배경 타임라인 및 이유

   1. client-side rendering (CSG)의 단점부각
       -> 첫 페이지 진입시 로딩이 상대적으로 엄청 오래 걸림 + 검색엔진의 노출이 좀 많이 어려움
           -> 웹서비스 트래픽 늘리기가 상대적으로 어렵고, 결국 수입지표적으로 어려움이 많이 생김 

   2. server-side rendering (SSG)의 장점이 다시 주목되고 다시 대세가 변하는 중
       -> client-side rendering (CSG)의 기능 및 성능향상의 최적화를 위해 알아야 했던, 프론트엔드의 전문성이라고 부르던 것들이 별로 필요함
          (= server-side rendering (SSG)을 사용하면, 결과적으로 그 딴거 쓸 이유가 사라지고, 상대적으로 프론트엔드 개발의 복잡성이 많이 줄어듬)

   3. NodeJS로 이제는 백엔드 개발도 JS로 가능해진 시대가 되었음
       -> CSG를 안 쓴다면, 그 CSG에 특화된 복잡한 개발력이 필요없어지니, 그만큼 백엔드를 만질 수 있는것도 중요
    
   4. 프론트엔드와 백엔드를 JS를 중심으로 통합된 개발환경을 제공할 수 있다면 엄청 유용할거 같음
       -> 가장 점유율이 높은 react 기반으로 각종 프론트엔드 기반의 풀스택 프레임워크('렌더링 프레임워크', 'meta 프레임워크'라고 불림)들이 등장하기 시작함
          (= Next.js 도 그 중 하나)

          ex) GatsBY, nuxt, sveltekit, remix, Next.js


- Next.js
   : react 라이브러리 기반의 '풀스택 프레임워크'로 이걸로 JS기반으로 화면과 웹서버 전부를 통합적으로 개발 가능하고, 쉽게 서버 및 화면에 대한 설정이나 기능 또한 도입이 가능함
      -> 웹서버 개발에 대한 수요가 반영 = 상대적으로 client에 많이 역할을 떠넘긴 CSG보단, JS만으로 SSG 기반 웹서비스를 상정하고 개발된 프레임워크


    # Next.JS를 배우는게 유리한 이유 + 장점

       @ Next.JS 장점
          1. GPT의 템플릿 기능이 나날이 발전하고 있기에, 점점 노가다성 개발력은 사라져가고 낮은 수준의 업무 장벽은 많이 줄어든 상태니, 개발자로서 풀스택적으로 범용성이 넓어 나쁠건 없음
 
          2. 프론트엔드 기반 통합 프레임워크들의 사용방법도 나날히 쉬워지기에, 미래의 개발환경의 점유율이 높아질 수 있기에 대비해서 나쁠건 없음
  
              ex) 회원인증 기능도 Next-auth 라이브러리를 끌어다 쓰면 10초면 구현 가능
 
          3. react기반이기에 react 문법을 사용하여, 특히나 쉽게 입문 가능
 
          4. GatsBY, nuxt, sveltekit, remix, Next.js 중 Next.js가 가장 꾸준하게 많이 쓰고, 만족도 수준과 유지력도 좋다는 점에서, 나중에 미래는 이 녀석이 될 확률이 높음
 
          5. 14버전 부터는 각종 편의성이 매우 증가함
              1) 폴더 기반 자동 라우팅으로 폴더와 JS파일만 만들면, 자동으로 잡아내서 HTML페이지를 생성해 줌
              2) 서버API 기능이 개선
              3) 더 쉬운 DB연결
              4) 직관적으로 rendering 전략 선택할 수 있는 기능이 존재 = SSG, CSG를 선택 가능하며 JS 없는거도 개발 가능 
              5) hydration 없는 server-side rendering
              6) 파워풀하고 쉬운 캐싱
              7) 이미지와 폰트 최적화
    
       @ Next.JS 단점
          1. react 라이브러리의 신문법인 client component, server component의 구분을 적극적으로 하는데, 이를 구분해서 코드를 짜는게 프로젝트 커지면 복잡할 수 있음
   
          2. WebSocket, WebRTC 같은 기능은 제대로 지원하지 않음 
             (= 직접 Nodejs + express 서버를 하나 더 만드는게 나음)
   
          3. HTML 랜더링에 기능이 집중되어 있고, 서버기능 쪽은 아직 상대적으로 갈 길이 멀다는 점
   
          4. 14버전인데 아직도 프레임워크 자체 버그가 종종 보임
              -> react 라이브러리를 적극 반영한건 좋은데, 아직 react가 구현하지 않은 미완성 기능들까지 도입해놓은 것 포함
   
          5. 14버전부터 폴더 기반 자동 라우팅 기능이 강화된 덕분에, 프로젝트 커지면 관련 예약 파일들이 많아져 복잡도가 올라갈 수는 있음


    # Next.js 프로젝트 생성 (= 서버까지 생성)
      1. nodejs 설치
      2. 작업폴더만들고 에디터로 오픈
      3. 터미널에 npx create-next-app@latest 입력
          -> (참고) 이 명령어가 'npm init -y'로 대표되는 node 서버의 초기화 기능까지 담당해 줌

      4. 프로젝트 설정을 결정해야 하는데, App Router는 사용한다 체크하고 나머지는 적절히 체크

         ex) 프로젝트 이름, App Router 사용할 건지, Typescript 사용여부, ES lint 사용여부, Tailwind CSS 사용여부, src 폴더 사용 여부, import alias 사용시 어떤 문자를 쓸건지 등

      5. page.js에 존재하는 기본 예시 화면에 대한 코드인 return 부분 다 지우고 <div></div>만 적고 코딩 시작
      6. global.css의 내용도 전부 지우기
      7. 터미널에 npm run dev 를 입력 = 서버 미리보기 띄우기 (page.js가 메인페이지)
      8. http://localhost:3000 으로 접속


    # 프로젝트 파일들
       1. app 폴더 : react와 비슷하게 화면 관련 코드들이 들어있는 핵심 폴더

          1) page.js  
              : 메인 페이지에 해당하는 JS파일
                 -> (참고) URL을 통한 웹페이지 Router 기능을 구현
                      : app 폴더 안에 다른 폴더를 만드는 식으로 단계별로 폴더를 만들고, 그 안에 page.js를 제작하면 됨  

          2) layout.js
              : 메인 페이지를 감싸는 용도로 제작된 JS파일
                 -> 참고사항
                     a. RootLayout({ children })라는 functional component로 구성
                         : parameter인 js객체 children은 각 폴더 위치 및 url에 대응하는 page.js를 의미하며, {}내 배치는 그 녀석이 위치할 곳을 의미 
                           (= 가장 바깥쪽의 layout.js의 함수 RootLayout({ children })의 children은 가장 바깥에 작성한 page.js에 해당하는 react의 App 컴포넌트 역할)

                     b. 동작방식
                        : app 폴더 안에 다른 폴더를 만드는 Router 기능을 구현 시 최상위의 layout.js를 가장 바깥, app 폴더를 기준으로 layout.js를 가장 마지막에 적용하는 양파같은 구조로 웹페이지 조립을 해줌
                          (= app 폴더를 기준으로 layout.js는 모든 하위 웹페이지들에 모두 적용됨)
                              -> (중요) js의 이벤트버블링이 작동하는 방식과 유사함을 명심하자... 대상 page.js 자기가 닿지 못한 폴더의 layout.js는 적용 못한다고 생각하면 이해가 편함

                                  ex) <head> 태그의 내용들을 여기다 담기도 함 
                                  ex) 페이지 간 공용으로 사용하는 component들의 경우
                                       -> 상단 navigation 같은 녀석들

          3) globals.css
              : 모든 페이지에 적용되는 전역 style들을 적는 css파일

          4) js파일명.node_modules.css
              : 특정 js파일명을 가진 JS 페이지에만 적용되는 style들을 적는 css파일

          5) api 폴더
              : node JS 본연의 기능인 웹서버 관련 기능을 담당하는 JS코드들이 모여 있는 app 폴더 내부의 폴더
 
          6) public 폴더
              : 이미지, 폰트 static 파일들을 보관하는 app 폴더 내부의 폴더 

       2. 그 밖에 존재하는 파일/폴더들

          1) next.config.js   
              : nextjs 설정 파일

          2) node_modules 폴더
              : 프로젝트 구동에 필요한 node JS 기반 라이브러리 보관용 폴더 
                 -> npm을 통해 다운받은 내용들을 다 여기 보관

          3) package.json     
              : npm 명령어 내용과 설치한 라이브러리 버전 기록용 파일.. 
                 -> 이거 하나면, 나중에 npm install 한 방으로 모든 라이브러리를 npm에서 다시 다운로드 가능

 
    # React 라이브러리의 JSX 문법(functional component를 기반으로 설명) 대략 정리
       -> React 기반의 프레임워크 Next.js에서 페이지 layout작성을 위한 문법.. 
          (심화된 내용을 내용을 원한다면, react 쪽 문서 참고)

          1. functional component 관련 
          
            @ component 만드는 과정

              1) 컴포넌트 만들고 싶으면 우선 function을 만들고 작명 (관습적으로 영어 대문자)
              2) function의 return () 안에 해당 component 단위를 구성하는 HTML 기반의 코드에 대한 내용이 기입되어야 함
              3) 원하는 곳에서 <작명/> 을 사용
 
                 ex) <작명> 이라는 임의의 component를 정의해서 사용
                 
                     export default function Cart() {
                       return (
                         <div>
                           <h4>Cart</h4>
                           <작명></작명>
                           <작명></작명>
                         </div>
                       )
                     }
                     
                     function 작명(){
                       return(
                         <div className="cart-item">
                           <p>상품명</p>
                           <p>$40</p>
                           <p>1개</p>
                         </div>
                       )
                     } 

            @ component 장/단점

               (장점)
                 a. component 들을 쉽게 재사용 가능 
                     -> (보통 배열명.map(콜백함수) 이거랑 조합)

                 b. 해당 component에서 통용되는 state 객체의 데이터들은 캡슐화가 되어 있음
                    (= 다른 component로 부터 값을 보호 가능하며, 자신의 값은 자신들만 조작이 가능한 구조)

                 c. component의 state객체가 변하는 부분에 한해서, 해당 영역의 component 부위만 다시 랜더링 가능
                    (= 페이지 재랜더링을 딱 변화가 필요한 부분만 하니 작업 효율과 성능이 올라감)

               (단점)
                 a. component 간 state 객체의 값을 전달받는 방법은 자기 후손들에게 일일히 props 객체를 구성해서 전달하는 방법 뿐이 없음 
                    (= 형제 component간 값을 주고받을 수 없고, 부모에게 값을 주는 방법도 없고, 오로지 받기만 해야함)

            @ functional component 작성시 주의사항
               1) (중요!) 각 component를 구성하는 최상위 HTML 태그에 해당하는 녀석은 '반드시' 1개만 허용됨

                   ex) 최상위 태그가 2개 (X)

                       return (
                         <div></div>
                         <div></div>
                       )

                   ex) 굳이 하고 싶다면, 다른 최상위 태그로 감싸자 (O)

                       return (
                         <> 
                           <div></div>
                           <div></div>
                         </>
                       )

               2) HTML 기반의 코드 = HTML 문법과 유사하나, 결과적으로는 HTML과 유사할 뿐, 여러 부분에서 JSX에서만 통용되는 유사 HTML 문법이라고 보면 됨
  
                   ex) JS변수의 값을 {}를 통해 넣거나, 각종 속성명이 HTML 원본의 그것과는 다르게 설계, style 속성값 작성법이 js객체 형식으로 작성되어야 함

               3) functional component의 HTML영역 작성시 함수 {} 내의 JSX변수 값을 넣고 싶을때는 어디서든 { JSX변수명 }을 사용하자
                   -> (중요) className, id, href 이런 HTML 속성에 해당하는 값에도 사용이 가능
                       -> (참고) ES6 이후 백틱(``)을 통한 문자열 작성시 JS에서도 `문자열어쩌고 ${JS변수명} 끝`과 같은 식으로 변수의 값을 문자열 도중에 끌어들일 수 있음

                           ex) HTML 속성에 해당되는 값이라도 상관없이 {}를 쓰면 함수 내부의 지역변수명을 사용 가능

                               export default function Home() {

                                 let name = 'park';
                                 let link = 'https://naver.com';

                                 return (
                                   <div>
                                     <h4 className="title">애플후레시</h1>
                                     <p className="title-sub">by dev {name}</p>
                                     <a href={link}>링크</a>
                                   </div>
                                 )
                               }

            @ functional component 작성시 HTML 속성넣기

               1) HTML에서의 class 속성 -> className으로 기입
                   : JS의 class라는 예약어가 class 문법과 관련해서 이미 존재하고 있기 때문
                     (= 작성하는 JSX파일의 functional component도 따지고보면, JS영역이라고 볼 수 있음) 
     
                     ex) JSX에서는 class (X) -> className (O)
     
                         export default function Home() {
                           return (
                             <div>
                               <h4 className="title">애플후레시</h4>
                               <p className="title-sub">by dev kim</p>
                             </div>
                           )
                         }
     
               2) functional component의 HTML영역 작성시 inline style 형식으로 style 값을 넣고 싶으면, 'JS객체 자료형' 형식으로 작성해야 함 
                  (주로 동적으로 component에 style 변경이 필요한 경우 쓰이곤 함)
     
                   ex) JSX에서의 component의 style 작성 형식 
                        : {{ style속성명1 : '값1', ... , style속성명N : '값N' }}
        
                          export default function Home() {
                            return (
                              <div>
                                <h4 className="title" style={{ color : 'red', fontSize : '20px' }}>애플후레시</h4>
                                <p className="title-sub">by dev {name}</p>
                              </div>
                            )
                          }
     
               3) (주의) style 속성 작성시 주의사항
                  : '-'이 들어간 style속성명의 경우, camalCase 형식으로 작성해 줘야 함
                      -> 'JS객체' 형식 내부에 입력되는 style 속성명은 '-'을 인식할 수 없기 때문임 
     
                          ex) font-size -> fontSize

               4) (주의) <input> 안의 value 속성의 경우 react에서도 쓰는 상황이고, 이는 CSR방식으로 state객체의 변수를 초기값으로 <input>에 두고, react의 onChange 이벤트핸들러 속성과 setter함수로 state객체를 통제하고 싶을 때 사용
                   : Next.JS에서 SSR방식으로 <input>태그의 value속성을 쓰고 싶은 경우, defaultValue 속성을 쓰도록 하자
                      -> (중요) 구분해서 써야 할 이유는 value쪽을 쓰려면, CSR방식으로 <input>과 state객체의 요소가 관련된 특별한 용도에 맞는 기능이 추가되는 만큼 성능도 더 많이 잡아먹기 때문...

               5) react의 CSR 방식의 Routing기능을 만들고 싶다면, component 반환값 html 레이아웃을 작성시, <a>태그 대신 Link를 import하고 대신 쓰면 됨
                   -> (중요) server component에서도 사용가능하나, CSR방식을 사용하여 새로고침없이 부드럽게 페이지 이동이 가능한 soft Refresh 기능을 사용..

                       ex) import Link from "next/link";
                  
                            <body>
                              <div className="navbar">
                                <Link href="/">Home</Link>
                                <Link href="/list">List</Link>
                              </div>
                              {children}
                            </body>

                   -> (NEXT.JS의 <Link> 태그와 prefetch()의 관계)
                        : <Link> 태그는 서버에서는 랜더링만 해주고, client 측의 JS런타임에서 useRouter().perfetch()에 해당하는 기능을 수행가능하기에 CSR임에도 server component 환경에서 쓸수 있게 설계됨 
                           -> 만약 <Link> 태그가 보이면, URL에 해당하는 페이지를 미리 로딩해주는 prefetch() 기능을 써서 CSR방식으로 동작하는 것을 원하지 않는다면? 
                               -> prefetch 속성값 = false로 변경하기
   
                                  ex) <Link href={'/어쩌구'} prefetch={false}>링크</Link> 
   
                        a. <Link> 태그
                            : react hooks의 useRouter()함수의 perfetch() 메서드를 사용하는 components에 해당하는 NEXT.JS의 component
                               -> perfetch()
                                   : 해당 코드가 화면에 보이는 즉시 'URL명'에 해당하는 웹페이지를 먼저 로딩하는 성능 향상을 위해 필요할 때만 동작하는 client측의 코드
                                     (= perfetch()는 클라이언트 측의 JavaScript 런타임이 처리하는 함수라는 것)
                               
                        b. perfetch()의 기능은 client 측의 JS런타임이 담당 = <Link>는 웹서버 측에서는 단순히 HTML로서의 <Link>를 랜더링만 해줄뿐
                           (= 서버측에서는 <Link> 랜더링을 다 해놓고, client측의 JS런타임이 이를 처리할 수 있게 보냄으로서, <Link> 태그 처리를 이행한다는 것)
                                -> 그래서 perfetch()를 통해, CSR 방식임에도 server component에서도 사용이 가능한 태그라는 것
                        
                        c. client측의 JS런타임은 화면에 <Link>가 보이는 상황이 감지되고, 성능적으로 필요한 상황을 감지하여 perfetch() 기능이 필요할 때 <Link> 태그에서 실행함
                            -> IntersectionObserver라는 API가 해당 기능을 담당함
                                               
            @ functional component 고유의 이벤트속성 문법 (= react 전용 JSX 이벤트헨들러 문법)
               : functional component의 HTML영역 작성시, HTML의 이벤트속성과 유사한 이벤트핸들러 문법으로 CSR방식으로 동작하는 이벤트를 작성 가능함
                  -> CSR방식으로 동작하게 설계되어 있는 문법이니, Client component에서만 사용가능
                     (= page.js 맨 위에 'use client'를 적어놔야 함) 

                (JSX 이벤트헨들러 사용법)
                  : functional component의 HTML영역 작성 중, camalCase이벤트속성명 = {콜백함수} 형식으로 이벤트 수행시 내용을 작성
                      -> 이와 component의 상태값을 관리하는 state객체와 연계되어, state객체의 변경이 감지되면 해당되는 component 부분에 한해서 비동기적으로 화면을 실시간으로 변경
                         (= 사실상 CSR방식으로 동작하는 react의 사용목적을 생각하면, 사실상 이벤트핸들러는 해당 방식으로 강제되는 셈이나 다름없음)

                          ex) onClick, onMouseOver, onChange 등등이 존재함...
                          
                             <button onClick={()=>{ 이름변경('park') }}>버튼</button> 

          2. props/state 객체
              : CSR(client side rendering) 방식으로 component에서 새로고침되지 않고, 웹서버의 응답과 별개로 비동기적으로 통신하며 실시간으로 화면의 값을 변경하여 재랜더링 해주는데 필요한 component들의 값과 관련된 대한 객체
                (= react에서 CSR(client side rendering) 방식을 구현하는 핵심 개념이기에, server component 사용시에는 사용 불가)

             @ (중요!) CSR 방식에서의 component의 특징 (= react에서의 component의 특징)
                : 개별 component는 자신을 실시간으로 변경하고 저장하는데 있어 필요한 값들을 state라는 하나의 객체에 '캡슐화'해서 관리
                  (= 자기 {}에서만 작동하는 지역객체인 state객체를 통해, 다른 component에 영향을 주지 않고, 영향도 받지않는 폐쇄성 유지)
                      -> 다른 component에 값을 전달할 필요가 있다면? 부모 component -> 자식 component 1방향으로 props 객체로 필요한 값들을 parameter형식으로 통해 전달
                          -> (참고) But..? 자식 component도 fetch를 통해 서버에 필요한 데이터를 요청할 수 있다는 점은 편의성 증진에 도움이 됨  

             @ props 객체
                : 부모 component -> 자식 component로 연계에 필요한 값들을 보낼 목적으로 사용되는 JS객체
                   -> 자식 component에 1번째 parameter 형식으로 보내지며, {1번째parmeter명.멤버변수명} 형식으로 꺼내쓸 수 있음

                 (props 객체를 통해 자식 component에 값을 전달하는 법)
                  a. (중요) CSR방식으로 동작하는 기능의 코드를 짜는 것이므로, 'use client'; 를 작성
                  b. 부모 component의 HTML 반환값 부분에 가서 <자식component명 = {전해줄데이터} or "원시값" /> 이런식으로 작성
                  c. 자식 component의 함수 정의 영역으로 가서 props라는 parameter를 등록 후 {props.멤버변수명} 이런식으로 호출 

                     ex) props 객체에 '상품'이란 멤버변수를 담아 CartItem 컴포넌트로 보내면, 해당 컴포넌트는 'props.상품'으로 해당 값을 꺼내쓸 수 있음

                         export default function Cart() {
                           let 장바구니 = ['Tomatoes', 'Pasta']
                           return (
                             <div>
                               <h4>Cart</h4>
                               <CartItem 상품={장바구니[0]}/>
                               <CartItem 상품={장바구니[1]}/>
                             </div>
                           )
                         }
                         
                         function CartItem(props){
                           return(
                             <div className="cart-item">
                               <p>{props.상품}</p>
                             </div>
                           )
                         }  

                 (props 객체 주의사항) 
                   a. 오직 부모 component-> 자식 component 간 1방향 전송만 가능
                      (= '자식 -> 부모' or '형제간 전송' or '선조 -> X대' 직계 전달 다 해당 안 됨)

                   b. X대 자손 component에 선조 component가 props객체를 보내려면, 귀찮아도 X번 props객체를 통해 값을 되물림해야 함

                   c. props 객체로 부모 component가 보낼수 있는 멤버변수의 갯수는 제한X
                     
                      ex) <CartItem 이런거={이런거}  저런거={저런거} ..... 캡틴={하루종일도가능해}> 이렇게 많이 전송 가능

                   d. props객체 : functional component = parameter : function 의 관계라는 점은 중복의 최소화를 유도 가능

             @ state 객체
                : component를 구성하는 값들을 관리하는 객체
                   -> 실시간으로 state 객체값의 변동이 감시되면? 변화한 state변수를 사용하는 component에 한해서만, 서버의 응답과 상관없이 먼저 비동기적으로 재랜더링을 해줘서 사용자 경험을 높히는 핵심 JS객체
                
                 (state 객체에 멤버변수를 선언하고 초기화하고, setter함수 선언하기)
                   a. (중요) CSR방식으로 동작하는 기능의 코드를 짜는 것이므로, 'use client'; 를 작성
                   b. 상단에 import {useState} from 'react'를 작성해서 import 준비
                   c. (중요) react 18버전 이후, state객체에 멤버변수와 setter함수를 선언할 때는 useState(초기값)함수로 구조분해 할당 문법을 사용함
                        -> useState(초기값) 함수는 [어떤 state의 초기값, 해당 state의 setter함수]를 반환하는데, 이를 구조분해구문을 통해 각각 [state변수명, 해당setter함수명]에 대입

                           ex) let [state멤버변수명, 해당setter함수명] = useState(초기화값 or [초기화배열] or {초기화 객체} );

                   d. 해당 state객체가 속한 component의 HTML 반환값 부분에 가서, {state멤버변수명}으로 해당 state객체멤버값이 위치할 곳을 정해주고, 이벤트핸들러의 {콜백함수}의 내용에 {해당setter함수명(값)}을 넣어줘서 setter사용
                      (= setter함수가 존재하는 JSX 이벤트핸들러가 작동하는 순간, 해당 state객체변수를 사용하는 component의 부분에 한해서만 바로 재랜더링이 완료됨)

                      ex) 'use client';
                          import { useState } from 'react'
                          
                          export default function List() {
                          
                              let [수량, 수량변경] = useState([0, 0, 0]);
                          
                              return (
                                  <div> 
                                      <h4 className="title">상품목록</h4>
                                        <div className="food" key={인덱스}> 
                                            <button onClick = { () => { 
                                                let copy = [...수량];
                                                copy[인덱스]--;
                                                copy[인덱스] < 0 ? null : 수량변경(copy) } }>-</button>
                                        </div>
                                  </div>
                              );
                          }


                 (state 객체 사용시 주의사항) 
                   a. 'state멤버변수명' 변수의 초기값은 useState의 parameter에 넣은대로고, 해당 멤버변수를 수정하고 싶으면 '해당setter함수명(수정값)'을 기입하면 됨
                      
                      ex) '이름'이란 state멤버변수의 초기값은 'kim'이고, 이를 바꾸려면 '이름변경('변경 이름')'을 호출하여 HTML 영역에 채움
                      
                          let [이름, 이름변경] = useState('kim');

                          <h4>{이름}</h4>
                          <button onClick={()=>{ 이름변경('park') }}>버튼</button> 

                   b. state멤버변수를 만드는 이유는 서버에 변경된 값을 전하는 것과 별개로 state객체의 멤버변수의 변화가 감지되면 실시간으로 비동기적 랜더링 로직이 해당 state변수를 사용하는 부분에 한해서만 작동
                      (= CSR의 목적 자체가 사용자의 웹서비스 경험을 증진시키는데 있음)
                          -> But.. 그런만큼 모든 변수를 다 state변수로 처리하면, 그건 자원낭비와 성능의 저하로 이어진다는걸 기억하자

                   c. useState(초기값) 함수의 초기값 부분에는 여러 변수의 값이 들어있는 [배열] 기입이 가능함
                       -> BUT! 해당setter함수명()을 통해 state객체의 멤버변수값의 변화는 '부분적인 요소값'은 안 되고, [배열] 전체를 바꿔야 변경됨
                          (= 배열명.map(콜백함수)를 통해, 데이터들의 반복적인 부분을 component로 작성해도 setter함수(배열명[인덱스]) 이런식으로 써봐야 해당 부분의 state객체의 멤버배열요소가 수정되지 않음)

                          ex) 초기값이 [배열]인데 setter함수에 paramter로 배열요소를 지정해봐야 수정은 일어나지 않음
                          
                              let [이름, 이름변경] = useState(['Tomatoes', 'Pasta', 'Coconut']);

                              <button onClick={()=>{ let copy = 이름[인덱스]
                                                      copy[0]++
                                                      수량변경(copy)
                                                     }}>+</button>

                   d. '해당setter함수명(수정값)'를 호출하면, 반환된  기존state객체값 === 신규state객체값인지 확인 후, 같은게 확인되어 component에 재랜더링할 부분이 없다면 굳이 새로 랜더링하지 않음
                       -> (중요) c의 경우와 같이 state객체변수 = [배열]이 초기값이면, [배열]이 참조 자료형인걸 모르고 '깊은 복사'를 안하고 '얕은 복사'를 하는 경우 당황하기 마련인데 그러지 말자

                          ex) 참조 자료형을 '얕은복사' 하는 예시
                               -> [1,2,3]이 위치한 주소값을 저장하는 arr을 arr2에 대입하면, 둘은 사실상 같은 값을 공유하는 셈

                              let arr = [1,2,3]
                              let arr2 = arr
                              arr2[0]++
                              console.log(arr2 == arr)

                          ex) state객체변수값을 '얕은복사(shallow copy)' 한 뒤 수정하면?
                               -> 'copy'와 '수량' 변수는 사실상 같은 값을 공유함 

                              let copy = 수량
                              수량[0]++
                              수량변경(copy)      <-  state변경함수를 써도 기존state == 신규state라서 state변경을 안해 줌

                   e. (c, d의 사례가 있기에) state객체변수의 초기값으로 [배열]을 둔 경우, 해당 [배열]을 수정하고 이를 component 재랜더링까지 가게하기 위해서는?
                       -> 이벤트헨들러의 콜백함수의 내용 영역에 [배열]값을 spread operator문법( [...], {...} )을 통한 '깊은복사'를 한 뒤에 setter함수를 사용하자
                           -> (참고) spread operator문법( [...], {...} )
                                : 대상 변수가 가리키는 메모리 영역에 위치한 컨테이너 데이터의 캡슐화를 해제하고 개별 데이터들을 각각 다른 영역에 복사한 뒤, 이들을 다시 독립적인 컨테이너 자료형으로 캡슐화하고 그 포인터값을 참조로 반환하라는 이야기

                          ex) 참조 자료형을 spread operator문법( [...], {...} )을 통해 '깊은복사(deep copy)' 하는 예시
                               -> spread operator문법( [...], {...} )를 통해 요소나 멤버의 값 자체가 복사된 컨테이너 데이터는 원본 컨테이너 데이터와 완전히 독립적인 데이터

                              let arr = [1,2,3]
                              let arr2 = [...arr]
                              console.log(arr2 == arr);  // false

                              let obj = {멤버1 : a, 멤버2 : b}
                              let obj2 = {...obj}
                              console.log(obj2 == obj);  // false

                          ex) state객체변수값을 spread operator문법( [...], {...} )을 통해 '깊은복사' 한 뒤 수정하고, setter함수를 통해 수정하면
                               -> 'copy'와 '수량' 변수는 아예 각각 다른 [배열]을 참조하고 있기에, '수량' 변수의 [배열]이 수정되고, 이것이 setter함수에 들어가면 state객체값인 [배열]이 다른 것으로 확인되어 state객체가 변하고 화면의 재랜더링이 이뤄짐

                              let copy = 수량
                              수량[인덱스]++
                              수량변경(copy)      <-  수량 != copy라서 다른 배열값으로 판정되어 state변경을 이행하여 component 영역의 변경된 부분에 재랜더링이 일어남

          3. '배열명.map( (요소값, 인덱스) => { 요소값, 인덱스 사용 내용 return 문 } )' 함수를 통해, functional component의 return값을 반환하는 HTML 안에서 반복문 사용 가능!
               -> js에도 배열명.map이 있고, JSX에도 있지만, 반환되는 HTML 내부에는 JSX의 map구문이 사용된다고 보면 됨

             @ 왜 for, if문을 문법 안 쓰나?
                : JSX의 functional component의 return값을 반환하는 HTML 안에는 for, if문(그 대신 '조건문 ? 참 : 거짓'의 '삼항연산자'를 사용)을 문법을 사용할 수 없음
                  (= return값을 반환하는 HTML밖에서는 얼마든지 JS의 문법을 사용해도 전혀 문제가 없음)

             @ (주의) 배열명.map( (요소값, 인덱스) => { 요소값, 인덱스 사용 내용 return 문 } ) 사용시 주의사항
             
                1) JSX 문법으로서 배열명.map(콜백함수) 함수를 쓰고 싶다면, component의 HTML layout의 반환문 내에 {}를 적고 그 안에 작성하면 됨       
                2) (중요) map(콜백함수) 함수는 parameter인 콜백함수를 통해 요소값, 인덱스를 사용하여 순차적으로 반환된 요소를 통한 배열을 반환함

                    ex) console.log(newArray); 로 [20, 30, 40] 반환
                    
                        var 어레이 = [2,3,4];
                        var newArray = 어레이.map((a)=>{
                          return a * 10
                        });
                        
                3) return문은 필수는 아니나, 이게 없으면 map(콜백함수)함수를 통해 가공하여 생성되는 배열은 없음 
                   (= 연산은 해주기에 console.log 같은거로 값을 보여는 주지만, 함수 {}를 넘어가면 거기서 끝이라는 이야기)

                    ex) return이 없어서 console.log(newArray); 해봐야 빈 배열 반환
                    
                        var 어레이 = [2,3,4];
                        var newArray = 어레이.map((a)=>{
                          a * 10
                        });

                4) 배열명.map(콜백함수)함수의 콜백함수의 1번째 parameter는 뭘 넣어도 각 '배열요소의 값'이며, 2번째 parameter는 뭘 넣어도 각 '배열의 인덱스'를 의미
                    -> (참고) 이 parameter들은 콜백함수 작성시 없어도 됨 (= 얘들이랑 관계없는 값을 반환해도 된다는 것)

                    ex) return이 없어서 console.log(newArray); 해봐야 [10, 10, 10] 배열 반환
                    
                        var 어레이 = [2,3,4];
                        var newArray = 어레이.map((a, i)=>{
                          return 10
                        });

                5) return값으로 component의 HTML layout을 반환해도 react는 JSX 형식으로 작성된 component를 잘 파싱하고 rendering함  
                    -> (참고) 배열명.map(콜백함수)를 사용 시, 각 반복된 component를 구분하기 위해 react는 고유값으로 key 속성을 넣을 것을 권장하는데, 보통은 index값을 넣음                  

                        ex) [ <div></div>, <div></div>, <div></div> ] 이런 구조의 배열이 반환되고, 이것이 List라는 component의 일부로서 반환되고 rendering 됨
                        
                            export default function List() {
                            
                                let 상품 = ['Tomatoes', 'Pasta', 'Coconut'];
                            
                                return (
                                    <div> 
                                    <h4 className="title">상품목록</h4>
                                    { 
                                        상품.map((개별상품)=>{
                                            return ( 
                                                <div className="food" key={인덱스}> 
                                                    <h4>{ 개별상품 } $40</h4>
                                                </div>
                                            )
                                        })
                                    }
                                    </div>
                                );
                            }

                6) JS의 for문으로 이를 구현하고 싶다면?
                    : HTML영역 바깥쪽에서 array를 for문을 통해 만들고, 이를 JSX의 배열명.map(콜백함수)를 통해 rendering 할 수 밖에 없음 
                       -> 다른 내용을 다루지만, 대상 배열과 같은 수의 index를 가지고, 대상 배열의 요소 값을 입력 가능하면 더 좋음

                           ex) 상품 문자의 갯수가 가격과 연관된 경우의 구현
                           
                               export default function List() {

                                   let 상품 = ['Tomatoes', 'Pasta', 'Coconut'];
                                   let 가격 = [];
                               
                                   for(var i = 0; i < 상품.length; i++){
                                     가격[i] = 상품[i].length * 10;
                                   }
                               
                                   return (
                                       <div> 
                                       <h4 className="title">상품목록</h4>
                                       { 
                                           상품.map((개별상품, 인덱스)=>{
                                               return ( 
                                                   <div className="food"> 
                                                       <h4>{ 상품[인덱스] } $ { 가격[인덱스] }</h4>
                                                   </div>
                                               )
                                           })
                                       }
                                       </div>
                                   );
                               }

    # Next.js의 URL에 따른 웹페이지 자동 라우팅(auto routing) 기능 구현법

      1. app 폴더 내부에 폴더를 하나 만들고 작명

      2. (중요) 원하는 폴더 내부에 page.js 파일을 생성하고, 그 파일 내부에 component를 이루는 html 레이아웃을 반환값으로 가지는 functional component 작성
          -> 1) functional component는 무조건 작성해야 하며, 함수명은 맘대로 작명 가능하나, 보통 폴더명이랑 비슷하게 함
             2) (참고) 새로고침없이 부드럽게 페이지 이동이 가능한 react의 CSR 방식의 Routing기능을 만들고 싶다면?
                 : component 반환값 html 레이아웃을 작성시, <a>태그 대신 Link를 import하고 대신 쓰면 됨

                   ex) import Link from "next/link";
                       import './globals.css';
                       
                       export default function RootLayout({ children }) {
                         return (
                           <html lang="en">
                             <head />
                             <body>
                               <div className="navbar">
                                 <Link href="/">Home</Link>
                                 <Link href="/list">List</Link>
                               </div>
                               {children}
                             </body>
                           </html>
                         )
                       }

      3. '도메인/폴더명'을 url로 작성하면, 해당 웹페이지 출력 완료
          -> (참고) '/app/폴더1/폴더2/page.js' 이런식으로 page.js를 형성하면, '도메인/폴더1/폴더2'를 url로 입력하면 해당 page.js 출력 가능 

        @ 웹페이지 Routing 기능
           : url로 웹페이지를 나누고, 사용자의 url명 호출에 따라 웹서버던 클라이언트 측이건 다른 웹페이지를 보여주는 기능

        @ 일반적인 Routing 기능 구현 방식
           : 특정 url을 사용자가 입력하고, 어디에 위치하는 어떤 파일명에 해당하는 HMTL을 보여줄지를 구체적으로 지시
             (= 그러니까, 참 사용자를 귀찮게 한다 이거임) 
                 -> BUT! Next.JS 에서는 사용자를 아주 편하게 만들어 줌 ㅇㅇ
  
                    ex) '도메인/list'라는 url을 사용자가 호출하면, /app/list/에 위치한 '상품목록.js'을 rendering 해주세요 로직

      4. 동적 라우트(dynamic route) 기능
          : '폴더위치 = url' 구조로 치환되는 Next.JS에서 '특정 데이터의 상세페이지'처럼 url이 '도메인/폴더명/pk값'과 같은 URL을 Next.JS의 방식으로도 라우팅을 구현할 수 있도록 지원하는 기능
      
        @ dynamic route를 지원하는 폴더와 page.js파일, 그리고 component 만드는 법

           1) 폴더 or 파일을 만들 때 []을 씌우기
              (= '이 부분에 해당하는 URL에는 아무거나 입력하면 됨'과 같은 의미)
                   -> (중요!) 이렇게 구성해놓으면, []부분에 해당하는 수많은 폴더들을 직접 만들 필요가 없음

              ex) [폴더명]
                    -> 예를 들어, '/photo/[폴더명]/page.js'에 해당하는 웹페이지를 호출하려면, 'https://도메인/photo/아무문자'로 URL을 입력하면, 웹서버가 아무문자에 해당하는 부분의 정보를 잘 URL parameter로 받아서 원하는 데이터를 가져와서 페이지를 랜더링해줌

              ex) [페이지명],js
                    -> 예를 들어, '/photo/[폴더명].js'에 해당하는 웹페이지를 호출하려면, 'https://도메인/photo/아무문자'로 URL을 입력하면, 웹서버가 아무문자에 해당하는 부분의 정보를 잘 URL parameter로 받아서 원하는 데이터를 가져와서 페이지를 랜더링해줌

           2) dynamnic route에 해당하는 URL요청에 웹서버가 응답하여 랜더링(rendering)을 할 대상인 page.js를 생성하고, 해당하는 functional component를 작성함
               -> (중요) dynamic route의 [폴더명]에 해당하는 URL parameter에 해당하는 부분을 가져오고 싶으면?
                    : page.js의 functional component의 parameter 기입 항목에 props를 작성하고, component {}안에 'props.params.원하는parameter명' 출력하면 됨

                      ex) '/app/detail/[id]/page.js'에 해당하는 파일 경로을 통해, Next.JS는 해당 component를 'https://도메인/detail/id명'이란 URL에서 id명에 따른 동적 라우트(dynamnic route)를 쓰는 component로 인식
                            -> 'https://도메인/detail/id명'의 'id명'은 [id]폴더에 대응되며, 'props.params.id'로 꺼내쓸 수 있음
                                (= 페이지 redirect시 입력된 id명에 해당하는 값의 전달은 props객체를 통한 부모 - 자식 간의 값 교환으로 구현)

                                import { ObjectId } from "mongodb";
                                import { connectDB } from "@/util/database.js"
                                
                                export default async function Detail(props) {
                                    let db = (await connectDB).db('forum')
                                    let result = await db.collection('post').findOne({_id : new ObjectId(props.params.id)});
                                
                                    return (
                                      <div>
                                          <h4>상세페이지임</h4>
                                          <h4>{result.title}</h4>
                                          <p>{result.content}</p>
                                      </div>
                                    )
                                }


    # Next.JS의 navigation모듈
       : navigation 모듈을 통해 Next.JS는 React hooks 함수 중 useRouter, usePathname, useSearchParams, useParam를 사용할 수 있게 해줌
         (= 이를 통해, NestJS에서도 CSR방식의 페이지 간 다용도의 route 기능을 쉽게 구현하게 하는 useRouter나, URL과 연관된 각 정보들의 Getter함수에 해당하는 usePathname, useSearchParams, useParam을 사용할 수 있게 됨)
             -> a태그에 해당하는 <Link> 태그나 window.location.href 속성값을 변경시키는 이벤트핸들러를 제작하지 않더라도, CSR방식으로 웹페이지간 이동이 가능함
                (= react 라이브러리의 기능을 사용하니, Virtual DOM을 통한 효율적 화면 전환에 해당하는 로직이 내장되어 있음을 알 수 있음)

        @ (중요) navigation모듈 사용시 주의사항
           : react hooks에 해당하는 기능 = 'use client'를 써서 client component로 작성했을 때, 제대로 작동하게 되어있음

        @ navigation 모듈의 react hooks 함수들

           1. useRouter()
               : 손쉽게 웹페이지 간 route 기능을 수행해줄 수 있는 react의 router 관련 JSX객체를 생성해주는 JSX함수
                 (= react 라이브러리의 기능을 사용하니, Virtual DOM을 통한 효율적 화면 전환에 해당하는 로직이 내장되어 있음을 알 수 있음)
                   -> 추후 해당 JSX객체의 메서드( push(url명), back(), forward(), refresh(), perfetch(url명) )들을 실행

                      ex) useRouter()를 통한 기능 예시코드
                      
                          'use client'

                          import { useRouter } from "next/navigation"
                          
                          export default function DetailLink(){
                              let router = useRouter();
                              return(
                                  <div>
                                      <button onClick={()=> { router.back() } }>뒤로가기</button>
                                      <button onClick={()=> { router.forward() } }>앞으로가기</button>
                                      <button onClick={()=> { router.refresh() } }>react식 새로고침</button>
                                      <button onClick={()=> { router.push('/write') } }>글쓰기</button>
                                      <button onClick={()=> { router.prefetch('/practice') } }>임시 회원가입</button>
                                  </div>
                              )
                          }
 
                      1) useRouter().back()
                          : 현재 페이지를 기준으로 '뒤로가기' 기능을 CSR방식으로 수행
                           
                            ex) <button onClick={()=>{ router.back() }}>버튼</button> 
 
                      2) useRouter().forward()
                          : 현재 페이지를 기준으로 '앞으로가기' 기능을 CSR방식으로 수행

                            ex) <button onClick={()=>{ router.forward() }}>버튼</button> 

                      3) useRouter().refresh()
                          : 현재 페이지를 기준으로 '새로고침' 기능을 CSR방식으로 수행
                             -> Virtual DOM을 사용한 로직을 통해, 이전과 바뀐점을 분석해서 바뀐부분만 새로고침하는 soft refresh 사용

                                ex) <button onClick={()=> { router.refresh() } }>react식 새로고침</button>
 
                      4) useRouter().push(url명)
                          : react 라이브러리를 통한 CSR 방식의 route 기능을 수행하여, 작성한 url명에 해당하는 웹페이지로 이동이 가능해짐
                             -> Virtual DOM을 사용한 로직을 통해, 변경된 요소만 변경

                                ex) <button onClick={()=> { router.push('/write') } }>글쓰기</button>

                      5) useRouter().perfetch(url명)
                          : 해당 메서드가 화면에 보이게 된다면, 해당 url의 페이지에 해당하는 내용을 미리 로드하여 사용자가 이를 클릭시 하여금 빠르게 방문이 가능해짐
                            (= react hooks의 component가 렌더링된 후에 component의 생애상태에 따라 실행되는 사이드 이펙트 코드들을 처리하는 useEffect와 연관)

                            ex) import { useEffect } from 'react';
                                import { useRouter } from 'next/router';
                                
                                export default function MyComponent() {
                                    const router = useRouter();
                                
                                    useEffect(() => {
                                        router.prefetch('/some-page');
                                    }, []); // 빈 배열을 사용하여 컴포넌트가 마운트될 때 한 번만 실행
                                
                                    return <div>My Component</div>;
                                }
                          
                             -> (perfetch 참고사항)
                                  a. 링크가 많은 게시판의 경우 모든 링크를 다 읽을게 아니기에, 이를 사용하여 굳이 모든걸 미리 로드하는건 자원낭비기에 상황 봐가며 사용해야 함
                                  b. server component의 <Link> 태그 또한 perfetch 메서드처럼 해당 코드가 화면에 보이는 즉시 'URL명'에 해당하는 웹페이지를 먼저 로딩
                                     ( <Link> 태그는 서버에서는 랜더링만 해주고, client 측의 JS런타임에서 useRouter().perfetch()에 해당하는 기능을 수행가능하기에 CSR임에도 server component 환경에서 쓸수 있게 설계됨 )
                                  c. 만약 <Link> 태그가 보이면, URL에 해당하는 페이지를 미리 로딩해주는 prefetch() 기능을 써서 CSR방식으로 동작하는 것을 원하지 않는다면? 
                                       -> prefetch 속성값 = false로 변경하기
                                          (자세한 내용은 <Link> 부분에서 참고)

                                          ex) <Link href={'/어쩌구'} prefetch={false}>링크</Link> 

           2. usePathname()
               : 현재 URL 출력해주는 Getter 함수

           3. useSearchParams()
               : 현재 URL의 search parameter (query string)에 해당하는 부분 출력해주는 Getter 함수

           4. useParams()
               : 현재 URL의 [dynamic route] 부분에 해당하는 URL 파라미터를 부분 출력해주는 Getter에 해당하는 함수

                 ex) usePathname(),  useSearchParams(), useParams()를 통한 기능 예시코드
                      : 이들의 의의는 복잡하게 window 객체를 통하지 않더라도, URL정보를 도출이 가능하다는거 

                        import {usePathname, useSearchParams, useParams} from 'next/navigation'
                        
                        export default function DetailLink(){
                          let a = usePathname()
                          let b = useSearchParams()
                          let c = useParams()
                          console.log(a)
                        }


    # (layout.js 사용) 페이지 간 공용으로 사용하는 component 공용 layout 만드는 과정 (ex : 상단 navigation) 
       : Next.js는 page.js를 보여줄 때, 그 옆에 layout.js 파일이 있으면 layout.js 내용 안에 page.js 내용을 담아서 보여줌
         (= url과 매칭되는 위치의 layout.js를 기준, 가장 안쪽 폴더의 layout은 가장 먼저 적용, app폴더의 layout은 가장 나중에 적용)

          1. 원하는 url의 component에 해당하는 page.js가 위치하는 곳을 가장 바깥 layout으로 간주하고, 단계별로 layout.js 생성
              -> (중요) js의 이벤트버블링이 작동하는 방식과 유사함을 명심하자... 대상 page.js 자기가 닿지 못한 폴더의 layout.js는 적용 못한다고 생각하면 이해가 편함

              @ app 폴더의 layout.js
                 : 가장 나중에 적용될 layout
                   (= app 폴더를 기준으로 layout.js는 모든 하위 웹페이지들에 모두 적용됨)

                   ex) <head> 태그의 내용들을 여기다 담기도 함 

              @ url과 폴더구조를 기준으로 가장 안쪽부터 바깥쪽인 app 폴더로 올라오는 layout.js들
                 : 가장 안쪽의 layout.js는 가장 먼저 적용될 layout에 적용될 layout

          2. 각 layout.js의 functional component에 해당하는 RootLayout({ children }) 함수의 return영역에 html 레이아웃을 작성하면 됨
      
             ex) import Link from "next/link";
                 import './globals.css';
                 
                 export default function RootLayout({ children }) {
                   return (
                     <html lang="en">
                       <head />
                       <body>
                         <div className="navbar">
                           <Link href="/">Home</Link>
                           <Link href="/list">List</Link>
                         </div>
                         {children}
                       </body>
                     </html>
                   )
                 }

          3. global.css에 style 작성하면 끝
 

     # Next.js에서 이미지를 넣는 방법론 2가지

        1. JSX형식에 이미지 넣는 일반적인 방식 
            : <img src="/port1.png" alt="설명"/> 형식으로 img태그 삽입

          @ <img> 태그 사용시 주의사항
             1) 그냥 html 파일에선 <img> 이렇게 단독으로 써도 되지만, react에서 참고하는 JSX에선 <img></img> 이렇게 쓰거나 <img />로 반드시 태그를 받아줘야 작동함
             2) public 폴더에 있는 것들은 사이트 발행시 자동으로 사이트 root 경로로 이동함
                (= src 속성에 이미지 위치나 주소를 입력할 때, 가급적 public 폴더에 이미지를 넣으면 여러모로 쉬워짐)

        2. Next.js가 지원하는 성능과 속도 측면에서 최적화된 이미지 넣는 법 
            : <Image>라는 Next.js가 지원하는 모듈을 통해 고유의 태그를 사용

              @ <Image> 태그 장점
                  1) 이미지가 늦게 뜨는 lazy loading 방지
                      -> (참고) lazy loading 기능만 원하면 다른 라이브러리 찾아봐도 됨
                  2) 이미지가 늦게 뜰 시, 그 시간동안 화면구조가 지멋대로 변경되는 layout shift 방지
                  3) 사이즈 최적화에 유용함
                      -> (중요!) 최적화는 사이트 다 만들고나서 하는게 좋은 관습이니, 초장부터 여기 집중할 필요 없음

              @ (참고) <Image> 단점
                  1) map(콜백함수)를 통한 반복문 처리시, 다른 이미지 보여주기 좀 난감
                      -> 이미지 주소가 index랑 관계없는 무작위인 경우, src 속성값에 require 같은 함수를 이용해야 할 때도 있음

                  2) 외부 이미지 넣는 조건이 좀 많아서 귀찮음

              @ <Image> 태그 사용 방법
                 1) Image라는 변수로 Next.js의 image 모듈을 import 문법으로 상단에 추가
                     : import Image from 'next/image'

                 2) 넣고 싶은 이미지 또한 상단에 import 문법으로 상단에 모듈로서 추가
                     : import 이미지명 from '이미지경로명(현재 위치 기준)'
                        -> (참고) ''를 쓰기 싫으면 @이미지경로명을 써도 됨

                           ex) import Image from 'next/image'
                               import 이미지 from @./food0.png
                               
                               export default function Home() {
                                 return(
                                   <div>
                                     <Image src={이미지} alt="설명"/>
                                   <div/>
                               )} 

              @ 만약 <Image> 태그로 타 웹페이지의 이미지를 절대경로로 집어넣고 싶다면?
                  -> (결론) 여러모로 귀찮으니, 이럴 때는 img태그 대충 사용하도록 하자

                      1) <Image> 태그 안에 width, height 속성을 집어넣어야 함
                          -> (대안) <Image> 태그 안에 fill="true" 이거 대신 넣고, 부모 <div>가 width, height를 대신 조절

                             ex) import Image from 'next/image'

                                 export default function Home() {
                                   return(
                                     <div width="500" height="500">
                                       <Image src="https://placehold.co/500" fill="true" />
                                     <div/>
                                 )} 

                      2) next.config.js에 images 관련 세팅이 추가로 필요함

                         ex) 이런식으로 images관련 속성을 세팅해줘야 해당 사이트의 이미지 사용가능
                         
                             module.exports = {
                               images: {
                                 remotePatterns: [
                                   {
                                     protocol: 'https',
                                     hostname: '도메인주소',
                                     port: '',
                                     pathname: '/my-bucket/**',
                                   },
                                 ],
                               },
                             }


     # Next.js에서 다중 rendering(SSR, CSR 양쪽 방식 모두 사용 가능)을 지원하는 방법
        : component 종류를 2가지로 지원하여, 개발자가 원하는 방식으로 해당 component 작성 가능
           -> (추천) 웹페이지의 틀은 SSR의 server component로, react적 기능이 필요한 component에 한해서 CSR의 client component 방식으로 제작하면?
                : SSR을 쓰는 부모 component에 붙히는 방식으로, CSR과 SSR의 장점만 혼합하는 식으로 사용 가능

                 1. server component (Uncontrolled Components)
                     : SSR(Server Side rendering) 방식으로 동작하는 component 단위
                       (= react가 아닌 HTML, CSS, JS만을 사용하겠다는 것을 의미)
  
                      @ server component 만드는 법
                         : page.js, layout.js 등 Next.js가 기본적으로 편의성으로 제공해주는 component는 전부 server component라고 생각하면 됨
  
                      @ server component 장/단점
                         -> (장점)
                             1) 웹서버에서 미리 웹페이지를 랜더링해서 보내주는 고전적인 방식으로 성능적으로 속도가 빠름
                               (= 웹페이지 로드시 react에서 처럼 랜더링시 비동기적인 JS코드를 쓸 일이 없으니, 작동 최적화를 생각할 필요가 없기 때문)
  
                             2) SEO(Search Engine Optimization)에 유리하여, 검색엔진에 노출이 쉬움
  
                         -> (단점)
                             : component의 반환되는 html 안에 react에서 통용되는 JSX문법을 사용할 수 없음 
                               (= 쉽게말해 react를 전혀 쓸 수 없으므로, useState, useEffect, onClick 이런 거 사용X)
  
  
                 2. client component (Controlled Components)
                     : CSR(Server Side rendering) 방식으로 동작하는 component 단위
                       (= react 라이브러리의 방식을 쓰겠다는 의미)
  
                      @ client component 만드는 법
                         : component 제작시 'use client' 라는 코드를 넣으면 OK
  
                      @ client component 장/단점
                         -> (장점)
                             : component의 반환되는 html 안에 자유롭게 react에서 통용되는 JSX문법을 사용 가능
                               (= react를 사용할 수 있음) 
  
                                1) JSX의 이벤트핸들러 함수를 사용 가능
                                    : DOM을 직접 조작하는게 아닌, VDOM 로직으로 다른 부분만 다시 랜더링하는 react 기반 프론트엔드 라이브러리에서 사실상 이벤트핸들러 사용법은 이게 유일
  
                                2) 새로고침이 강제되지 않는 페이지를 만드는 것이 가능하기에, Ajax 방식의 API호출과 시너지가 우수한 편
  
                         -> (단점)
                             : 웹페이지 상의 모든 동작과 이벤트를 Client 측에서 새로고침 없이 비동기적으로 처리하는 CSR 방식의 근본적인 문제에 직면
  
                                1) 웹페이지 용량이 커지게 됨
                                    : react의 JSX문법에 해당하는 JS코드가 늘어남 + CSR을 위해서는 모든 조작에 반응해야 하므로 다운로드 받을 HTML, CSS, JS 파일이 많을 수 밖에 없음
  
                                2) 웹페이지 로딩속도도 약간 느려질 수 있음
                                    a. Client 측에서 초기에 필요한 정보들을 서버에 API로 호출하고, 이를 직접 랜더링해야 하기 때문
                                    b. JS로 구현된 React 문법을 적용하는 과정에서, JS로 html을 읽고 분석하는 과정인 hydration에 소요되는 시간도 추가로 발생

                                3) client component에 적은 코드는 데이터를 캡슐화해주는 react의 요소 없이는 유저들이 볼 수 있기에 보안에 문제가 됨
                                    : state객체변수나 useEffect와 같은 react hook함수를 사용하는 것이 거의 강제됨

                                4) 페이지 로딩에 있어, 모든 경우의 수를 상정하여 코드를 짜야함
                                    : 어떤 데이터를 가져오는 API를 호출할지부터, 데이터가 없는 경우의 component의 구조들도 작성해야 하는 등.. 개발자가 손봐야 할 내용이 적지 않음 


     # 다중 rendering(SSR, CSR 양쪽 방식 모두 사용)을 사용하는 component에서 DB데이터를 받고 처리하고 가공하는 방식 
        : '[부모] : [자식] = server component (Uncontrolled Components) : client component (Controlled Components)' 경우 DB데이터를 어느쪽에서 호출해야 하는지에 대한 딜레마

          1. [부모] 측의 server component가 DB 서버로부터 데이터를 받고, 이를 [자식] 측의 client component에 props 객체를 통해 넘겨주기
              : (추천) 일반적으로 SSO에 띄기 위한 SSR기법의 장점과 component의 동작 측면에서 좋은 성능을 보이는 CSR의 장점까지 두루두루 활용 가능하기에 자주 쓰임

                ex) (/list/page.js)
                    
                    <ListItem result={result} />
                    
                ex) 구조분해(structure destruction) 문법을 활용하면, {props객체변수}로 parameter를 채워도 props.멤버변수가 아니라 멤버변수만 써도 알잘딱하게 알아먹음
                
                    (/list/ListItem.js)
                    
                    'use client'
                    
                    export default async function ListItem({result}) {
                      return (
                        <div>
                          { result.map((a,i)=>
                              <div className="list-item" key={i}>
                                <Link href={'/detail/' + result[i]._id}>{result[i].title}</Link>
                                <Link href={'/edit/' + result[i]._id} className="list-btn">✏️</Link>
                                <button>🗑️<button>
                                <p>1월 1일</p>
                              </div>
                           ) }
                        </div>
                      )
                    }

             @ (참고) [부] server - [자] client 관계의 component 구조는 Next.js에서 허용하는 구조고, 이렇게 하면 client component도 DB 데이터를 미리 채워서 보내주게 로직이 짜여서 가능
                 -> 크롬 개발자도구에서 Javascript disable 해놓고 페이지 방문해서 잘 보이나 테스트해보면, 바로 JS를 통해 해당 로직이 구현되었음을 알 수 있음
              
          2. [자식] 측의 client component가 직접 DB서버로부터 데이터를 받는 방안
              : 가능하고, 괜찮은 방안이지만 꽤 단점이 많아서 써야하는 경우를 잘 상정하는게 중요함
                (= 사실 그 단점이라는게, 근본적으로 검색엔진 노출이 힘들어서 서비스가 유저들에게 노출이 잘 안 된다는 비즈니스적인 측면에 있음)
              
                ex) 'use client'
                    
                    export default function ListItem(){

                      const [result, setResult] = useState([]);
                    
                      useEffect(() => {

                        async function fetchData() {

                          try {
                            const db = (await connectDB).db('forum');
                            let data = await db.collection('post').find().toArray();
                            setResult(data);

                          } catch (error) {
                            console.error("Failed to fetch data:", error);
                          }
                        }

                        fetchData();
                      }, []);
                    
                      return (
                        <div>{result}</div>
                      )
                      
                    }

             @ (단점)
                1) 유저가 코드를 볼 수 있는 보안 문제로 캡슐화를 통한 접근제한이 보장되는 state객체변수와 useEffect와 같은 react hook함수를 통해 DB에 호출하는 코드를 작성하는 것이 좋음
                    -> useEffect(무명콜백함수, [component명, ...])
                        : 해당 무명콜백함수의 내용에는 우선순위가 떨어지는 무거운 코드들인 'side efferct'들이 모여있고, [component명]을 적지 않는다면 모든 컴포넌트들이 다 로드된 후에 실행하라는 용도의 react hooks 함수
                           -> 보통 서버로 DB데이터 요청하는 코드도 예상 시간이 오래 걸리고, 우선순위가 떨어지는 작업이기에 useEffect를 사용함

                2) 처음부터 component에 초기화 된 데이터가 들어가 있는 것이 아님
                   (= 검색엔진 BOT들은 이걸 보면 기다리지 않고 해당 웹페이지는 내용이 텅 비었다고 판단함 = 검색엔진에 웹페이지가 노출되는 것이 느려지기에 SSO 측면에서 좋지 않음)


     # Next.js로 제작된 페이지들의 rendering 종류와 개념 (static rendering / dynamic rendering )
        : 정적 렌더링(static rendering)과 동적 렌더링(dynamic rendering)으로 나뉘어져 있음 
            -> 구체적으로 어떤 페이지들이 어떤 렌더링(rendering)으로 동작하는지 알고 싶다면, npm run build 명령어를 통해 complie이 완료된 후 파일에 λ (람다) 표시와 ㅇ표시로 이를 구분 가능
               (Controlled / Uncontrolled component와 같은 영역이 아니라.. 조금이라도 페이지가 다르게 랜더링되냐 마냐로 더 엄격하게 구분됨)
                 -> λ로 표시되는 페이지 = dynamic rendering으로 동작
                    ㅇ로 표시되는 페이지 = static rendering으로 동작

          1. 정적 렌더링(static rendering)
              : 어떤 유저라도 해당 URL에 접속하게 되면, 매번 npm run build시 생성한 html을 아무런 변동없이 그대로 보내주는 방식의 웹페이지 랜더링
                 -> 웹 페이지 안에 별 기능이 없기에, 매번 html 페이지를 새로 만들 필요가 없기 때문

                    ex) 100명이 들어와도 언제나 똑같은 웹페이지 복붙하는 '로그인' 페이지 같은거가 여기 해당
              
             @ 정적 렌더링(static rendering) 특징
                : ㅇ로 표시되는 페이지 = static rendering으로 동작

                  (장점)
                    : 유저가 100명 들어와도 페이지를 새로 만들지 않기에 성능에 유리
                      (= 애초에 cashing이 필요 없음)

                  (단점)
                    1) 복잡한 서비스랑은 당연히 거리가 먼 편 
                    2) cashing(캐싱) 기능을 이용하면, 동적 랜더링(dynamic rendering) 페이지도 효율적인 재사용으로 성능적으로 뒤쳐지지 않을 수 있음

             @ 강제로 정적 렌더링(static rendering)을 쓰도록 고정하는 방법
                : 원하는 페이지에 해당하는 component의 js파일에 dynamic이란 예약어 변수를 선언하고, 'force-static'을 입력
                   -> 'auto'가 기본값이며, 이는 알아서 시스템이 판단해줌

                      ex) export const dynamic = 'force-static' 
    
                          export default function 페이지(){
                            (생략)
                          }

          2. 동적 렌더링(dynamic rendering)
              : 해당 URL에 접속하게 되면, 접속하는 유저나 상황에 따라 html에 변동사항이 들어가기에, 페이지에 들어갈 때마다 html 페이지를 서버에서 다시 그려주는 방식의 웹페이지 랜더링
                 -> 변화하는 내용에 영향을 줄 수 있는 fetch('/URL', { cache: 'no-store' }),  useSearchParams(), cookies(), headers(), [dynamic route] 같은걸 사용하는 페이지들이 해당

                    ex) 상세 페이지, 회원정보와 같은 대다수의 페이지들이 여기 해당
              
             @ 동적 렌더링(dynamic rendering) 특징
                : λ로 표시되는 페이지 = dynamic rendering으로 동작

                (장점)
                  : DB 입출력 기능에 대응할 수 있는 복잡한 서비스에 유리하며, 구현 가능한 영역이 많음
                
                (단점)
                  : cashing(캐싱) 기능을 이용해도, 정적 랜더링(static rendering)에 비해서 성능은 어쩔수 없이 밀림

             @ 강제로 동적 렌더링(dynamic rendering)을 쓰도록 고정하는 방법
                : 원하는 페이지에 해당하는 component의 js파일에 dynamic이란 예약어 변수를 선언하고, 'force-dynamic'을 입력한 뒤 export처리 
                   -> 'auto'가 기본값이며, 이는 알아서 시스템이 판단해줌

                      ex) export const dynamic = 'force-dynamic' 
    
                          export default function 페이지(){
                            (생략)
                          }

             @ cashing(캐싱)
                : 데이터를 잠깐 몰래 저장해두고 그걸 재사용하여 비용절약 + 속도향상을 노린다는 개념

                  ex) Next.js에선 페이지 캐싱, GET요청결과 캐싱 이런 것들이 존재 

                  1) 페이지 cashing(캐싱) 기능 사용 방법 = (구) ISR
                     : 원하는 페이지에 해당하는 component의 js파일에 revalidate 이란 예약어 변수를 선언하고, 원하는 초단위 숫자를 입력한 뒤 export처리
                         -> 특정 페이지를 원하는 시간(초) 만큼 캐싱해두고 재활용을 할 수 있음 
     
                           ex) 60초가 지나면, 해당 페이지를 재생성 하여 또 60초간 캐싱해서 유저측에 보여줌
                               (= 60초마다 static rendering 페이지 하나 생성해주는 식이므로, 과거에는 ISR로 부름)
                           
                               export const revalidate = 60;
                               
                               export default function Page() {
     
                                 DB입출력하는코드~~
     
                                 return (
                                   <div>어쩌구</div>
                                 )
                               } 

                       ((구) ISR 중요사항) 
                         [1] 방문자가 있어야 페이지를 시간에 맞게 재생성
                         [2] on-demand revalidation 을 사용하면, 특정 이벤트가 발생시 입력된 시간을 무시하고, 페이지 캐싱을 새로 생성이 가능함

                  2) fetch API에서 사용가능한 GET요청데이터 cashing(캐싱) 기능
                     : (Next.js 13버전부터) server component에 한해, dynamic rendering 사용 페이지에서 fetch API의 option 파라미터에 cache, revalidate라는 멤버변수를 통해 캐싱을 통한 비용절약 + 속도향상 가능
     
                       (cashing 연관 fetch API 멤버변수)
                         [1] cache
                              : GET요청 결과값 cashing(캐싱)기능 on/off을 위한 fetch API의 option 파라미터 객체의 멤버변수
                                (= 시간에 따른 조건부 캐싱이 불가능 -> next라는 option 파라미터 객체의 멤버변수의 객체의 프로퍼티인 revalidate의 존재 이유)
                                
                                   a. (기본값) fetch('/URL명', { cache: 'force-cache' }) 
                                       : fetch()로 요청하면 한 번 가져온 결과를 어딘가에 몰래 저장해두고 웹사이트 다시 npm run build 하기 전까지 계속 가져와 줌
          
                                          ex) let result = await fetch('/api/어쩌구', { cache: 'force-cache' })
      
                                   b. fetch('/URL명', { cache: 'no-store' }) 
                                       : fetch()로 요청하면 매번 새로 서버로 요청해서 데이터를 새로 가져옴
                                         (= 재사용 X, 데이터의 갱신여부가 중요한 경우 사용)
          
                                          ex) let result = await fetch('/api/어쩌구', { cache: 'no-store' })
     
                         [2] next: { revalidate: 숫자 }
                              : GET요청 결과값 cashing(캐싱)결과를 얼마나 보관할지를 초 단위 정하기 위한 fetch API의 option 파라미터 객체의 멤버변수와 내부 객체의 프로퍼티
                                 -> (참고)  웹서버의 API를 작성할 때도 fetch API의 revalidate 옵션기입이 가능

                                    ex) 60초가 지나면 다시 /URL로 새로 요청해서 결과를 가져오고 캐싱
 
                                        let result = await fetch('/api/어쩌구', { next: { revalidate: 60 } })
     
                       (fetch API와 관련된 cashing 기능의 중요사항) 
                         [1] (중요) server component에 한해서만 fetch API의 cashing기능 사용 가능
                               -> 이것이 server component에서 ajax 사용시 fetch를 계속 쓸 이유라고 할 수 있겠음 

                         [2] (중요) 여러 component에서 동시다발적으로 같은 /url로 fetch하는 경우 중복은 알아서 제거되며, 변수나 state 공유문제도 마찬가지로 데이터 캐싱으로 해결됨
                                    (= 같은 /url로 요청하는 fetch() 잔뜩 사용해도 비효율 문제가 딱히 없는 이유)

                         [3] 로직 자체는 Next.js에서 바닐라 JS의 fetch() 기본함수를 업그레이드해놔서 사용 가능
                         [4] 웹서버의 API를 작성할 때도 fetch API의 revalidate 옵션기입이 가능


     # Next.js의 module(작게 분리한 프로그램 개별 파일) 시스템
        : 일반적인 JS와 전혀 다를 것이 없으니, ES6 이후로 공식화 된 ES모듈의 import/export 방식 그대로 쓰면 됨
          (= 물론 require로 대표되는 CommonJS 문법도 사용은 가능함)

          1. export
              : 특정 변수, 함수 등을 외부 파일에서 가져다 쓸 수 있는 모듈로서 내보내는 모듈화를 시킬 떄 쓰는 문법.. 파일별로 1개만 사용 가능
                 -> (중요!) But 변수나 함수나 선언할 때마다 export를 붙이는건 제한이 없고, 선언된 게 1개면 당연히 default도 사용가능

                    1) export default 변수명 or 함수명
                        : 단일 변수, 함수만 모듈로 내보낼 경우 사용하는 문법
                           -> default 자체가 '해당 모듈엔 개체가 하나만 있다'는 사실을 암시하며, import로 모듈을 가져올 때 {}가 필요없게 함 

                    2) export {변수명, ... , 함수명} 
                        : 여러 함수나 변수를 모듈로 내보낼 경우 사용하는 문법

          2. import
              : export된 모듈을 외부 파일에서 가져다 쓸 때 쓰는 문법 
                 -> 보통 파일 가장 최상단에 사용

                    1) import 변수명 or 함수명 from '모듈경로명'
                        : default export 된 변수나 함수를 모듈로서 가져올때 사용하는 문법
                           -> default가 들어갔으니, {}를 쓰면 안되며, as는 필요없이 꼴리는 변수명을 붙이면 됨

                              ex) import 꼴리는변수 from "./data.js"

                    2) import {변수명, ... , 함수명} from '모듈경로명'
                        : 여러 함수나 변수를 모듈로 가져오는 경우 사용하는 문법
                           -> as 별칭을 통해, 변수명처럼 쓸 수도 있음

                    3) import * from '모듈경로명'
                        : 해당 모듈에서 export한 모든 함수나 변수를 모듈로 가져오는 경우 사용하는 문법
                           -> But 이렇게 하면 어떤 변수나 함수를 사용하는지 알 수 없고, 불필요한 내용까지 가져오는 경우가 있어 성능이나 코드 구조 파악이나 모두 힘듦


    # Next.js를 사용한 웹서비스 베포과정
       1. 터미널에 npm run build 입력 
           : react기반의 Next.js를 사용하여 개발한 코드들을 브라우저 친화적인 html, js, css 파일로 complie해 바꿔주는 작업

       2. 서버로 사용한 물리적인 컴퓨터 및 AWS같은 클라우드의 터미널에 해당 소스를 복사해두고 터미널에서 npm run start 입력
           : 이를 통해 실제로 유저 요청을 처리할 수 있는 Next.js 서버가 완성됨
              -> 단! 도메인 같은건 따로 처리를 해둬서, DNS서버에서 도메인을 보고 해당 서버로 연결되도록 처리할 수 있게 해줘야함

    # Next.JS와 MongoDB 관련 특수지식들
       1. MongoDB 세팅은 일반적으로 Node.js에 하는 것과 차이 없음
           -> DB연결용 보일러플레이트 코드도 new MongoClient(url, options).connect()의 값을 모듈분리하여 export 시켜도 전혀 문제없음

       2. Next.JS에서 MongoDB를 사용한다는건, React 라이브러리와 DB를 같이 쓰는 것이라고 볼 수 있음
          (= import한 모듈화된 연결변수와 DB호출함수는 component 안에 지역변수처럼 해줘야 component내에서 정상동작하는데 유리함)

       3. (중요) DB입출력하는 코드는 server component 안에서만 사용해야 함 (async await 방식으로 쓰려면, component에 async 붙여주기)
           -> client component 안에 적은 코드는 유저들도 쉽게 볼 수 있음!!

       4. Next.Js에서 작성을 권하는 DB연결변수를 분리 모듈로서 관리하는 database.js의 MongoDB 관련 보일러플레이트 코드는 다음과 같음
           -> Nextjs의 경우 개발환경에서 JS파일을 작성 중이라 갱신할 때마다 JS파일들을 다시 읽어들이고 코드를 재실행함
              (= DB연결 객체인 MongoClient.connect()가 동시에 여러 개 실행될 수 있고, DB의 성능낭비가 심해지는 문제 발생)
                  -> 방지 차원에서 개발중임이 확인되면 Next.JS에서 가지고 있는 global이라는 전역변수 객체에 연결정보를 저장할 수 있음

                     ex) import { MongoClient } from 'mongodb'
                         const url = 'DB접속URL~~'
                         const options = { useNewUrlParser: true }
                         let connectDB
                         
                         if (process.env.NODE_ENV === 'development') {
                           if (!global._mongo) {
                             global._mongo = new MongoClient(url, options).connect()
                           }
                           connectDB = global._mongo
                         } else {
                           connectDB = new MongoClient(url, options).connect()
                         }
                         export { connectDB }


       5. 비동기코드이기에 promise문법으로 통제되는 DB연결로직이 선행되기에, DB호출코드들을 export 시키면 안정성이 떨어진다는 문제에 대한 Next.js 솔루션?
           -> Next.Js는 현재 next.config.js파일에서 실험단계인 top-level await 기능을 true/false로 해금할 수 있게해서, true시 DB호출코드까지 export해도 안정적으로 작동할 수 있도록 기능을 추가중임
               -> But! nodejs 버전이 낮으면 못쓰는 기능이라.. 클라우드를 쓰기라도 할 경우 서버가 지원안해주면 못 씀

                  ex) next.config.js 파일열어서 webpack(){} 부분을 참고
                  
                       /** @type {import('next').NextConfig} */
                      const nextConfig = {
                        experimental: {
                          appDir: true,
                        },
                        webpack(config) {
                          config.experiments = { ...config.experiments, topLevelAwait: true }
                          return config
                        }
                      }
                      module.exports = nextConfig


    # Next.js에서 서버 기능 제작 
       : 결론부터 말하자면 Node.js에서 server.js에 일일히 노가다로 제작하던 API들의 제작이 일종의 자동화가 되었다고 볼 수 있음
         (= URL명 제작 구조를 API라는 폴더와 그 안의 파일들로 단순화 시켜놓고, API의 실행내용은 그 안의 함수 component형식으로 유사하게 만듦)
 
         1. app 폴더 밖에 api 폴더를 만들고 거기에 API명에 해당하는 js 파일을 'API명.js'으로 만듦
             : /api 폴더 안에 위치한 폴더와 JS파일들은 자동으로 웹서버의 URL에 대응되며, js파일들의 functional component들은 API 호출의 결과로 실행됨 

               ex) /pages/api/test.js 파일은 'https://도메인/api/test' 라는 URL로 호출되는 API의 내용으로 그 내부의 component를 실행함
                    -> 요청 객체의 내용 가공 및 응답 객체를 통한 client로 보내는 내용 주목 
              
                       export default function handler(요청, 응답) {
                         if (요청.method == 'GET'){
                           응답.status(200).json({ name: '안녕' })
                         }
                         if (요청.method == 'POST'){
                           응답.status(200).json({ name: '바보' })
                         }
                       }
    
         2. 'API명.js' 파일 안에 functional component(이름은 뭘로 지어도 됨)를 제작하고, API의 구체적인 실행 내용(DB에 요청할 쿼리, 요청내용 가공, 응답 처리 등)을 작성함

              @ 참고사항
                 1. server component에 해당하기에 DB 입출력하는 코드를 작성해도 괜찮음 
                 2. find() 같은 조회 쿼리에 해당하는 메서드를 사용시, 그 결과값이 없다면 NULL로 반환
                     -> (중요) 만약, 후속코드에 'cursor명.멤버변수' 같은 걸 지정시, NULL에는 멤버가 없으므로 이를 찾을수 없어 바로 런타임 에러가 떠버리니 참고  

                 3. 유저 측에서 보낸 정보를 추측했을 때 DB에 전송을 원하지 않은 상황이 생길경우, 요청(request) 객체의 정보를 조건문에 사용해서 문제를 차단 가능  
                     -> (참고) 프론트엔드에 있는 모든건 위조가 가능하여 넘어갈 수 있기에, 보낸 값의 대조는 웹서버에서 직접하는게 좋음 

                 4. try, catch 구문을 통한 예외처리를 통해, 에러시의 대처 완성도를 높일 수 있음

                    ex) insert를 해야 하니, 유저가 <form>태그로 보낸 요청(request) 객체의 멤버객체 body를 통째로 넣어도 문제없음  
                    
                        import { connectDB } from "@/util/database"
                        
                        export default async function handler(요청, 응답) {
                          if (요청.method == 'POST'){
                            if (요청.body.title == '') {
                              return 응답.status(500).json('제목써라')
                            }
                            try {
                              let db = (await connectDB).db('forum')
                              let result = db.collection('post').insertOne(요청.body)
                              응답.redirect(302, '/list')
                            } catch (error) {
                              DB에러시 실행할코드~~
                            }
                            
                          }
                        } 

                    ex) delete할 데이터를 찾는 filters 객체를 paramter로 넣어야하니, 유저가 URL에 보낸 데이터인 요청(request) 객체의 멤버객체 query의 특정 멤버변수를 찾아서 기입해야 에러날 확률이 적음
                    
                        import { connectDB } from "@/util/database";
                        import { ObjectId } from "mongodb";
                        
                        export default async function handler(요청, 응답) {
                        
                            try{
                                console.log(요청.query);
                        
                                let client = await connectDB;
                                const db = client.db('forum');
                                let 데이터 = await db.collection('post').deleteOne( {_id : new ObjectId(요청.query.URL_parameter) } );
                        
                                console.log(데이터);
                        
                                응답.status(200).json('삭제완료');
                        
                            }catch(error){
                                응답.status(500).json('서버나 DB에 문제가 발생했나 봅니다..');
                            }
                        
                        }

              @ client -> server로 들어온 요청(request)에서 들어온 정보 가공하는 코드 작성법
                 : functional component의 1번째 parameter로 들어가는 요청(request)객체의 멤버변수나 메서드를 사용
                 
                    1) 요청.method
                        : API 호출시 URL말고 HTTP method 또한 알고 싶은 경우, functional component의 1번째 parameter로 들어가는 요청(request)객체의 멤버변수인 method를 호출하면 됨
                           -> (중요) 이를 이용하면, HTTP 메서드에 따른 조건문을 통해 같은 URL이라도 HTTP 메서드에 다를 경우에 대한 '동URL이API'들을 쉽게 구현가능 

                    2) 요청.body
                        : client측에서 <form>태그를 통해 데이터를 입력하여 전송하여 API를 호출하는 경우, 서버측에서 유저가 보낸 데이터를 조회하기 위한 요청(request)객체의 멤버객체 body 

                    3) 요청.query
                        : client측에서 URL paramter 방식이나 queryString 방식을 통해 API를 호출하는 경우, 서버측에서 유저가 보낸 데이터를 조회하기 위한 요청(request)객체의 멤버객체 query 
                           -> (참고) 웹서버에서 유저가 보냔 요청(request) 객체의 데이터를 쓰려면, props객체의 데이터 쓸 때처럼 멤버객체도 확실히 지정해주는게 좋음

                               ex) queryString 예시
                                    : https://www.mydomainxxx.co.kr/detail?id=33&pw=222

                               ex) URL 파라미터 예시
                                    : https://www.mydomainxxx.co.kr/detail/33/pw/222

              @ server -> client로 '응답(response)'을 보낼 때 필요한 코드 작성법
                 : functional component의 2번째 parameter로 들어가는 응답(response)객체의 멤버변수나 메서드를 사용
                    -> (중요) 사실 안해주는 client측은 무한으로 대기중인 상태에 빠질 수 있으므로 거의 필수라고 보면 됨 

                        1) 응답.json(JS원시값 or JS객체 or 배열)
                            : ()안의 값을 json 형식으로 변환하여 문자열의 형태로 client에 전달하는데 사용
    
                        2) 응답.status(status숫자값)
                            : client 측에 요청에 대한 응답 상태를 전송할 때 사용하며, 여전히 응답(response) 객체를 return하기에, 메서드 메이닝(method chaining)이 가능함
                        
                              ex) 응답.status(200).json({ name: '바보' })
                                   -> client 측에 {"name" : "바보"}가 보임
    
                        3) 응답.redirect(status숫자값, 'URL명')
                            : API를 호출한 client를 다른 페이지로 강제로 이동시키고 싶은 경우 사용하는 메서드
                               -> (중요) 이건 웹서버 측에서 사용자에게 다른 웹페이지를 랜더링해 보내는 SSR(server side rendering)에 포함
    
                                   ex) 응답.redirect(302, '/list');

         3. 'API명.js' 파일의 작성이 다 끝났다면, client의 화면에서 이를 호출해 봐서 잘 작동하는지 확인

              @ client 측의 서버 API 호출법
                (자세한 내용은 Node.js 측에도 적어둠)

                1) <form> 태그 사용
                    : HTML의 공식 태그 중 하나인 <form>태그에 <input>태그를 사용하여 정보를 입력하고, action속성 안의 URL주소의 API를 호출하여 서버가 이를 실행하는데 쓸 수 있도록 데이터를 보내는 방식  

                      ex) export default function Write(){
                            return (
                              <div>
                                <h4>글작성</h4>
                                <form action="/api/test" method="POST">
                                  <button type="submit">버튼</button>
                                </form>
                              </div>
                            )
                          }
                        
                      @ <form> 장/단점

                         (장점) 
                           a. html에서 공식으로 지원하는 형식이라 검증
                           b. 웹서버로 POST, GET요청을 쉽게 날릴 수 있음

                         (단점)
                           a. POST, GET요청 말고는 HTTP 메서드를 날릴 수 없음
                           b. 새로고침이 무조건 동반되는 SSR 방식
                              (= 전송을 끝날 때까지는 아무것도 못하는 동기적 작동 방식)

                2) ajax(Asynchronous JavaScript and XML) 기능 사용
                    : ajax는 새로고침 없이, 비동기 방식으로 웹서버의 API를 JS나 XML을 사용한 코드로 호출할 수 있는 기술적 개념에 가까운 기능을 의미함
                      (= ajax의 구현 방법은 정말 다양하지만, 현 시점에서는 ECMA 6버전 이후 promise객체 기반으로 제작된 fetch구문이나, 그 이전부터 높은 편의성과 역사로 이름을 떨친 axios가 존재   

                   @ ajax 장/단점

                      (장점) 
                        a. 웹서버에 내용을 전송해도 새로고침을 안해도 됨
                        b. 비동기적 데이터 교환이 이뤄짐 = 데이터 전송과 관련없이 화면이 유지되고 사용자는 조작이 가능
                            -> (참고!) 화면 전환없이 이뤄지는 요청과 리턴이기에 ajax를 통한 통신을 주고받는 기능에서는 다른 페이지로 연결하여 새로고침을 유발하는 redirect나 render 같은 함수를 API {}안에 써봐야 작동하지 않음.. 
                        c. Js를 사용하는 Runtime 환경이면, 서버나 화면에서나 같은 방식으로 데이터를 주고받기 쉽다
                        d. GET, POST 외의 다른 HTTP 메서드(PUT, DELETE, PATCH)도 받을 수 있음

                      (단점)
                        : 기본적으로 버튼을 지원하는 FORM 태그랑 다르게, JS의 이벤트리스너를 통해 스스로 버튼 동작과 기능을 연결시킬 줄 알아야 해서 좀 과정이 귀찮음
                          (= fetch API가 표준이니 이거는 사용할 줄 아는게 좋음)

                   @ (참고) JSON 객체의 메서드
                      : [배열] or {JS객체} -> JSON형태의 "문자열" 로 변환 or 역으로 JSON형태의 "문자열" -> [배열] or {JS객체} 로 파싱하는 역할의 도구들

                         a. JSON.stringify( {JS객체} or [배열] )
                             : parameter로 들어간 {JS객체} or [배열]을  JSON형태의 "문자열"로 변환하는 메서드
                                -> (주의) BUT! {JS객체}의 메서드는 파싱 및 변환 과정에서 복구가 불가능해지니 주의

                         b. JSON.parse ( JSON 형식의 "문자열" )
                             : parameter로 들어간 JSON 형식의 "문자열" 을  {JS객체} or [배열]로 파싱하여 복구해주는 메서드
                                -> {JS객체}의 메서드는 복구가 불가능

                   @ fetch('URL명', {method : 'HTTP 메서드', body : '본문' , ... } )
                      : ECMA 6에서 공식적으로 지원하는 Ajax API기능으로 promise 객체를 기반으로 만들어져, 수신성공/실패에 따른 콜백함수 처리를 쉽게 할 수 있음

                       (fetch 문법)
                         : promise객체를 기반으로 제작되었기에, URL에 따른 API호출을 시작으로 늘 성공/실패에 따른 콜백함수 처리를 해줘야함
                            
                           a. async / await 방식
                               : Ajax 방식의 API호출 과정을 async 함수화시킨 모듈로 처리하고, 비동기적으로 작도하는 코드에 기다림의 질서를 부여할 await 처리를 해줌  

                                 ex) async function submit() {
   
                                       // 1번째 await 포인트
                                       let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));
   
                                       // 2번째 await 포인트 : 웹서버에 API호출
                                       let response = await fetch('/article/fetch/post/image', {
                                         method: 'POST',
                                         body: blob
                                       });
                                 
                                       // 3번째 await 포인트 : 전송이 잘 되었다는 응답이 오고, 이미지 사이즈가 얼럿창에 출력됩니다.
                                       let result = await response.json();
                                       alert(result.message);
                                     }

                           b. then, catch, finally
                               : Ajax 방식의 API호출 과정을 고전적으로 promise 체이닝 메서드 형식으로 실행

                                 ex) function submit() {

                                       canvasElem.toBlob(function(blob) {

                                         fetch('/article/fetch/post/image', {
                                           method: 'POST',
                                           body: blob
                                         })
                                           .then(response => response.json())
                                           .then(result => alert( JSON.stringify(result, null, 2) ) )

                                       }, 'image/png');
                                     }

                       (fetch 사용법) 

                         [1] API 요청
                              : 사용할 fetch API의 방식을 정하고, 거기에 맞게 URL과 fetch 형식을 정함
                                 -> ({ option 객체 }를 적어야 하는 경우) 
                                      a. method  : GET 이외의 HTTP메서드를 쓸 경우
                                      b. headers : client 측에서 header 영역을 따로 설정하고 싶은 경우 사용
                                      c. body    : 웹서버로 데이터(문자열, Form객체, Blob이나 BufferSource, URLSearchParams)를 보내고 싶은 경우 
                                                    -> (주의) {JS객체}, [배열]을 보내려도 '문자열'로 보내야 하므로, 반드시 JSON 형식으로 변환하여 보낼 것

                         [2] API 응답
                              : API의 요청에 웹서버가 성공적으로 응답한다면, 데이터를 응답(response)객체 형식으로 보내줌
                                (async/await 형식에서는 변수가 이를 받는다면, then() catch() 형식은 무명콜백함수의 1번째 객체 parameter가 이를 받음)

                       (fetch 응답(response) 객체의 구조) 

                         [1] 멤버변수 (= properties)
                              : 주로 메타 데이터에 해당하는 데이터를 가지고 있는 객체의 멤버변수 영역

                                a. response.status  : 응답시의 HTTP 상태코드
                                b. response.ok      : 응답 상태가 200과 299 사이에 있는 경우 true
                                c. response.headers : 응답 데이터의 HTTP 헤더데이터가 담긴 변수

                         [2] 메서드 
                              : 웹서버의 API 응답에 대한 데이터의 본문을 파싱하기 위한 메서드
                                (= 보통은 json으로 변환하게 될 것)
                                   -> (주의사항)
                                        1. fetch API에서는 응답을 받았으면, 반드시 해당 메서드들을 써서 서버가 보낸 응답객체의 body데이터를 파싱해줘야 client측이 알아먹을 수 있음
                                        2. 단! 한번만 사용이 가능함 
                                           (= 가장 먼저 실행한 메서드로 데이터는 파싱됨)

                                a. response.text()        : 응답객체 body 본문을 텍스트 형태로 반환함
                                b. response.json()        : 응답객체 body 본문을  파싱해 JSON 객체로 변경함
                                c. response.formData()    : 응답객체 body 본문을 FormData 객체 형태로 반환
                                d. response.blob()        : 응답객체 body 본문을  Blob(타입이 있는 바이너리 데이터) 형태로 반환
                                e. response.arrayBuffer() : 응답을 ArrayBuffer(바이너리 데이터를 로우 레벨로 표현한 것) 형태로 반환

                         ex) 이런식으로 응답객체의 프로퍼티와 메서드를 사용

                             fetch('/URL')
                             .then((응답)=>{
                               if(응답.status == 200) {
                                 return 응답.json()
                               } else {
                                 //서버가 에러코드 전송시 실행할코드
                               }
                             }).then((응답)=>{ 
                               // 성공시 실행할코드
                             })
                             .catch((실패)=>{
                               // 인터넷문제 등으로 실패시 실행할코드
                               console.log(error)
                             })

                       (fetch 주의사항 모음)
                         [1] fetch 요청시 {JS객체}, [배열]을 보내려도 '문자열'로 보내야 하므로, 반드시 JSON 형식으로 변환하여 보낼 것
                         [2] fetch 요청시, option에 body속성을 넣어야 한다면, 반드시 데이터를 넣어야 함
                         [3] fetch 요청시, POST 요청을 보낼 때 body속성값이 문자열이면 Content-Type 헤더가 text/plain;charset=UTF-8로 기본 설정됨
                         [4] fetch 요청시, URL을 적을 때 URL parameter와 queryString 형식까지 포함해서 데이터를 보내는 거도 가능은 함
                         [5] fetch API에서는 응답을 받았으면, 반드시 해당 메서드들을 써서 서버가 보낸 응답객체의 body데이터를 파싱해줘야 client측이 알아먹을 수 있음
                         [6] fetch API에서는 응답 변환 메서드는 단! 한번만 사용이 가능함
                             (= 가장 먼저 실행한 메서드로 데이터는 파싱됨)
                         [7] server component를 사용한다면, fetch API를 사용할 것이 Nextjs 13부터는 권장됨 
                              -> fetch에 특별한 기능이 추가되어 있기에 때문


                3) URL의 일부로 데이터를 포함해서 href 속성값으로 url를 작성하여, 웹서버의 API를 호출해 무식하게 보냄..
                    : 말 그대로 브라우저의 주소창에 해당하는 window.location.href의 속성값을 변경하는 방법으로 웹서버에 무식하게 호출을 보냄
                       -> (중요) fetch API나 <form> 태그를 쓸 때도 GET형식을 쓴다는 가정하에 URL을 해당 형식에 맞춰 적는다면, 데이터를 보내는게 가능함

                          ex) URL 파라미터 예시
                               : https://www.mydomainxxx.co.kr/detail/33/pw/222
       
                          ex) queryString 예시
                              : https://www.mydomainxxx.co.kr/detail?id=33&pw=222

                   @ URL 직접사용 장/단점
   
                      (장점) 
                        a. 추가적인 라이브러리 따위 없이, 간편하게 데이터를 보낼 수 있음
                        b. (URL 파라미터의 경우) 그나마 보내는 데이터가 어떤 칼럼에서 나오는지를 가리기에 보안적인 면에서 나을수는 있음
   
                      (단점)
                        a. 이를 통해서는 GET방식의 호출 밖에 할 수 없음
                        b. 새로고침이 무조건 동반되는 SSR 방식
                        c. (라이브러리에 따라서는) POST 방식을 쓸 수도 있지만, 기본적으로 URL에 데이터를 포함해서 보내기에 보안이 씹망


- Auth.js (Next-Auth 라이브러리)
   : Next.JS 프레임워크 사용시, 회원기능을 구현함에 있어 JWT또는 OAuth를 매우 쉽게 만들 수 있게 도와주는 라이브러리
      -> 라이브러리 설치 + 코드만 복사 붙여넣기 하면 여러가지 회원기능을 쉽게 구현 가능 

         ex) OAuth 소셜 로그인, 아이디/비번 로그인, JWT, session 방식
              -> DB adapter 기능을 이용하면, DB에 session을 저장해두는 식의 전통적인 유저 관리 

    # Auth.js의 장/단점

       (장점)
         : 그냥 개발자 입장에서 쓰기 매우 쉬움

       (단점) 
         1) 기본적으로 모든 방식이 JWT로 동작하게 설계됨
         2) 심지어 ID/PW로 로그인하는 옵션을 켜둔 경우?
             -> 제작팀에서는 보안이슈를 이유로 JWT 방식을 강제로 사용하게 제약을 걸어둠
                (= session 방식은 사용 불가능)

    # Auth.js 라이브러리 세팅
      1. node.js와 Next.js는 당연히 필수
      2. 작업폴더만들고 에디터로 오픈
      3. 터미널에 npm install next-auth  입력
      4. 'pages/api/auth/[...nextauth].js' 라는 경로에 [...nextauth].js 파일을 만들고, 보일러플레이트 코드를 작성해 둠
           -> authOptions이란 JS객체는 로그인 정보를 담고 있는 객체로서, 다른 component에서 열람가능

              ex) [...nextauth].js 파일의 보일러 플레이트 코드
              
                  import NextAuth from "next-auth";
                  import GithubProvider from "next-auth/providers/github";
                  
                  export const authOptions = {
                    providers: [
                      플렛폼1명Provider({
                        clientId: '플렛폼1에서 발급받은ID',
                        clientSecret: '플렛폼1에서 발급받은Secret',
                      }),
              
                      ... ,
              
                      플렛폼n명Provider({
                        clientId: '플렛폼n에서 발급받은ID',
                        clientSecret: '플렛폼n에서 발급받은Secret',
                      }),
                    ],
                    secret : 'jwt생성시쓰는암호'
                  };
     
                  export default NextAuth(authOptions); 

    # component에서 로그인 된 유저의 정보를 출력해야 하는 경우
       : (주의) 유저정보 또한 server component에서 유저정보 가져와서 client component로 전송해주는게 나을 수 있음
           -> 다른 외부서버에 API를 호출하는 경우와 마찬가지로, side effect와 로딩의 우선순위를 고려해야 하는 CSR 환경에서 동작하는 useSession() 함수 또한 html 다 보여주고나서 한 박자 늦게 실행될 수 있기 때문

              ex) Github의 경우는 유저정보를 조회하면 다음과 같은 user객체를 응답객체에 보내줌
                   -> (참고) DB adapter를 사용하여, session 로그인 기능을 쓰는 경우 expire라는 멤버변수도 포함

                      {
                        user: {
                          name: '유저명',
                          email: '이메일id@도메인.com',
                          image: '이미지주소'
                        }
                        
                        // session 로그인 사용시
                        expire : '만료 날짜'
                      }

              1. server component의 경우
                  : 비동기 함수코드 getServerSession()를 사용하나, parameter로 들어가는 내용이 JS파일 종류마다 변경

                  1) component JS파일 내부에서 유저의 정보를 출력해야 하는 경우
                      : getServerSession(authOptions) 방식으로 호출
                         -> (중요) next-auth 라이브러리에서 getServerSession() 함수를 모듈로 가져옴 + [...nextauth].js 파일에서 로그인 정보를 담는 authOptions객체를 모듈로 가져오는 작업 선행
                      
                            ex) import { authOptions } from "@/pages/api/auth/[...nextauth].js"
                                import { getServerSession } from "next-auth"
 
                                export default function Page(){

                                  // session 정보를 가져옴
                                  let session = await getServerSession(authOptions)

                                  if (session) {
                                    console.log(session)
                                  }
                                  ....
                                }
                                
                  2) API JS파일 내부에서 유저의 정보를 출력해야 하는 경우
                      : getServerSession(요청, 응답, authOptions) 방식으로 호출
                         -> (중요) authOptions객체를 모듈로 가져오는 작업 + 함수형식으로 API 작성시 사용되는 요청(request), 응답(response) parameter까지 같이 포함시킴
                      
                            ex) 

              2. client component의 경우
                  : useSession()라는 react hooks 함수를 사용하여 쉽게 로그인 정보 조회
                     -> (중요) 단! client component인 [부모 component]에서 <SessionProvider>라는 component를 import 해오고, 이를 client component인 [자식 component]에 감싸야 사용 가능
       
                        ex) client component인 [부] layout.js 에서 [자]에 해당하는 모든 component를 <SessionProvider>로 감싼다면...
                             -> (참고) 최상위 layout.js에서 회원기능에서 배울 getServerSession() 쓰면, 모든 페이지가 아마 동적 랜더링(dynamnic rendering)으로 동작할 수 있음
       
                            'use client'
                            
                            import { SessionProvider } from "next-auth/react"
                            
                            export default function Layout({ children }){
       
                              return (
                                <SessionProvider>
                                  {children}
                                </SessionProvider>
                              )
                            }
       
                        ex) client component인 [자]에 해당하는 모든 component에서는 useSession()이라는 함수 하나로 로그인 정보를 보여줌
       
                            'use client'
                            
                            import { useSession } from 'next-auth/react'
                            export default function Page(){
       
                              let session  = useSession();
       
                              if (session) {
                                console.log(session)
                              }
                            }


    # Auth.js 라이브러리에서 각 로그인 기능 구현

      1. OAuth 로그인
          : 어떤 유저의 A사이트에서의 조회 권한을 잠시 B사이트를 운영하는 쪽에서 빌리는 식으로, A사이트의 유저조회 API를 호출하는 과정을 정의하는 규칙을 의미하기에..
             -> B사이트의 운영팀은 A사이트에서서 OAuth에 대한 사용허가를 받아야 함
                (= 그 사용허가를 구분하는 기준이 B사이트 입장에서 clientID, clientSecret인 셈)

          @ OAuth 로그인 기능 구현 과정
          
            0) OAuth를 원하는 플랫폼에 clientID, clientSecret을 얻어내기 위한 작업을 실시
  
               ex) Github로 예시
                    a. 회원가입 후, 유저 탭 영역의 'setting' 클릭
                    b. 좌측 하단 탭의 Developer settings -> New OAuth app 클릭
                    c. 어떤 앱에 어떤 용도로 쓸지와, 요청에 대한 응답을 어디로 보내줄지에 대한 도메인도 입력
                       (사실, 이 정보가 곧 API에 영향을 미치는건 아니니, 개인 레벨이면 대충써도 무방함)
                    d. 발급받은 clientID, clientSecret를 잘 보관하기
  
            1) OAuth 로그인은 JWT방식이 기본이라, 플랫폼 측의 서비스 ID, PW를 얻어서 각 clientID, clientSecret에 넣으면 완료
                -> secret 멤버변수는 OAuth 로그인은 JWT방식이 기본이라는 점에서, 가져다 쓰는 개발자가 추가적으로 사용하는 salt같은 개념
                   (= 이거를 사용하면, 플랫폼측의 salt와 유저측의 salt들을 모두 알아야 로그인 정보 해킹이 된다는 점에서 더 골이 아프게 할 수 있음)
  
            2) import { signIn, signOut } from 'next-auth/react' 와 같은 방식으로, next-auth/react 라이브러리의 로그인 및 로그아웃 함수를 모듈로 가져와서 사용
                -> (참고) 주로 어떤 button의 클릭 이벤트로 구현될 경우가 많으니, react의 JSX문법으로 이벤트속성으로 이를 구현하니 보통 client component에서 해당 기능이 구현되는 경우가 많음
  
            3) 기능 테스트를 해보면, 클릭 시 우리가 일반적으로 아는 각 플랙폼 사의 OAuth 로그인으로 들어가는 버튼들이 등장하며, 그걸 누르면 소셜로그인 진행

      2. OAuth + session 방식 로그인 (DB adapter 기능 활용)
          : DB에 유저 회원정보를 보관하고, 로그인시 그 정보가 일치하면?
             -> 입장권에 해당하는 session(유효한 날짜까지만 사용가능 + 여차하면 DB에서 이를 지워 통제가능)을 유저에게 주고, 서버에 요청을 보낼때마다 이를 체크하는 방식 

          @ (필수) MongoDB의 adapter 기능을 설정 과정
             : MongoDB가 아니더라도 Next.JS 프레임워크에서 Auth.JS로 session 로그인 기능을 구현하려면, 반드시 사용할 DB의 adapter 기능을 활성화시킬 뭔가가 필요함

               1) 터미널에 npm install @next-auth/mongodb-adapter을 입력하여, MongoDB의 adapter 관련 라이브러리를 설치하자
                   -> 설치에 문제가 생긴다면 상위 버전의 mongoDB 지우고 npm install mongodb@4를 입력하여, 4 ~ 5 버전의 MongoDB 라이브러리를 사용하게 하자

               2) DB adapter 자체가 session 관련 기능을 수행할 컬랙션(= 테이블)을 추가하는 것이기에, 해당 컬랙션들이 위치할 Database를 결정해야 함
                  (= MongoDB 접속 URL에 ?가 있는 부분 왼쪽에, 원하는 Database명을 넣으면 session 관련 컬랙션들이 생길 위치를 해당 Database명에 지정 완료)
                      -> 안 적으면, 기본값 TEST라는 DB명이 생겨나서, 추후 관련 collection들을 보관

                         ex) const url = 'mongodb+srv://아이디:비밀번호@클러스터명.도메인/Database명?DretryWrites=true&w=majority'

               3) [...nextauth].js 파일에, authOptions이 저장하는 로그인 정보를 가지는 JS객체에 adapter 프로퍼티를 추가하고, MongoDBAdapter(connectDB)를 대입함
                   -> MongoDBAdapter(DB연결정보) 함수는 해당 DB연결정보를 사용하여, MongoDB adepter기능을 사용한다는 것
                      (= connectDB가 의미하는건 database.js에서 export한 MongoDB에 연결한 보일러플레이트의 결과물)

                      ex) adapter : MongoDBAdapter(connectDB)를 추가하여, DB adapter기능을 활성화하여 session방식 로그인을 수행준비
                         
                          import { connectDB } from "@/util/database";
                          import { MongoDBAdapter } from "@next-auth/mongodb-adapter";
                          import NextAuth from "next-auth";
                          import GithubProvider from "next-auth/providers/github";
                          
                          export const authOptions = {
                            providers: [
                              GithubProvider({
                                clientId: 'Github에서발급받은ID',
                                clientSecret: 'Github에서발급받은Secret',
                              }),
                            ],
                            secret : '어쩌구'
                            adapter : MongoDBAdapter(connectDB), //추가함
                          };
                          
                          export default NextAuth(authOptions); 

               4) 웹서버를 돌리고, MongoDB의 collection을 보면 session 관련 기능을 위한 accounts, sessions, users 3개 컬렉션들을 생성함을 확인가능
                   -> (생성된 collection 설명)

                       a. users   
                           : 유저들의 회원정보 보관하는 컬랙션 (= PK는 이메일로 설정) 
                              
                              ex) test@naver.com 만 등록 

                       b. sessions 
                           : 로그인 유효기간을 포함한, 현재 로그인된 유저들의 session 정보들이 모여있는 컬랙션

                       c. accounts
                           : 유저들이 생성한 모든 계정 보관하는 컬랙션 

                              ex) test@naver.com라는 유저는 1명이나, 그 계정은 플랫폼에 따라 여러개가 있음을 기록
                                  (= 1명의 유저는 여러개의 계정을 가지고 있을 수 있어, 이메일 중복 가능성이 높음)
                              
                                  test@naver.com + Github이 써있는 document 
                                  test@naver.com + Google이 써있는 document 

          @ DB adapter 기능을 통한 session 로그인 기능 로직 과정

            1) 첫 로그인시 자동으로 유저를 회원가입 시킴
               (= 회원가입 X.. 로그인 하자마자 DB에 회원정보를 DB의 관련 컬렉션 및 테이블에 보관)

            2) 로그인시 자동으로 유저가 언제 로그인했는지에 대한 session정보를 DB의 관련 컬렉션 및 테이블에 보관

            3) 웹서버에서 지금 로그인된 유저정보가 필요하면, DB에 있던 session컬렉션 및 테이블의 정보를 조회해서 가져옴 
               (= JWT를 분석하지 않는다는 것)

            4) 로그아웃시 해당 유저의 session 정보는 DB에서 삭제되거나 사용완료 처리 
