- 서버(server)
   : 누가 어떤 데이터를 '요청'하면 보내주는(= '응답') 역할을 수행하는 프로그램 
      -> 그 프로그램을 수행하는 실체가 물리적 컴퓨터일수도 있고, 논리적으로 분리된 가상 컴퓨터일수도 있음
         (비슷한 코드를 짜다보니 효과적인 중복방지를 위한 패턴으로 인해, 분리와 조건문 다형성을 활용한 패턴을 적극활용하는 경우가 많을 뿐)

    # 웹서버
       : 누가 어떤 홈페이지 도메인(URL)으로 접속하면 거기맞는 html을 보내주는 서버
          -> (주의) 클라이언트가 화면에서 db조작을 해서 CRUD 명령어를 실행해도, 화면이 그에 맞춰 반응하려면, 반응형 동작을 비동기적으로 지원해주는 프레임워크 쓰지 않는이상, 새로고침없이 화면 자체에서 그 데이터를 실시간으로 반영하진 않음

    # 포트(port)
       : 내 컴퓨터의 ip가 일종의 국가면, 포트는 항구와 같은 의미로.. 이 포트라는 단위를 기준으로 컴퓨터는 여러 컴퓨터 및 어플리케이션들과의 통신을 구분하여 주고 받을 수 있도록 할당받음 
          -> BUT! 기본적으로 유명한 번호의 포트는 컴퓨터에서 이미 사용하거나, 특정 기능이나 앱이 사용하도록 할당되는 경우가 있는데, 이런건 따로 건드는일 없도록 해 함

    # HTTP HEADER
       : 서버와 클라이언트가 HTTP요청으로 정보를 주고 받을 때 부가정보를 넣는 영역 
             -> 브라우저, OS, 쓰는 언어, 보유한 쿠키 등을 전달한다 보면 되며.. 이런거로 개인정보를 빼내기도 함
                 1) request header  : 유저 -> 서버 이렇게 전달되는 부가정보
                 2) response header : 서버 -> 유저 이렇게 전달되는 부가정보    


- rendering의 종류
   1. server-side rendering (SSG)
       : 서버측에서 HTTP API요청을 받으면, 그 요청에 맞는 HTML을 구성해서 CLIENT에게 보내주고, CLIENT측 브라우저는 이를 화면에 랜더링해주기만 하는 방식
          -> 1) DB에서 데이터 뽑아서
             2) 글목록.html 파일에 꽂아넣고
             3) 그 html 파일을 서버에서 보내줌

         EX) EJS (JSP 1.5에서 쓰던 그 템플릿 기호를(<% %>, <%= %>, <%- %>)을 사용함 )
   
   2. client-side rendering (CSG)
       : 서버측이 HTTP API요청을 받으면, DB에서 단지 데이터(보통은 JSON형식)를 보내주고, CLINET측은 그 받은 데이터를 기반으로 HTML구조를 재구성해서 다시 랜더링해 화면에 뿌리는 방식
          -> 1) 서버에 GET요청으로 DB데이터를 가져와서
             2) 그걸 html로 만들어서 보여줌

      # client-side rendering (CSG)의 단점
         : server-side rendering (SSG)의 장점과 다시 대세가 변하는 이유
            1) Client에서 모든 화면의 변동을 처리 가능해야하니, 첫 페이지 진입시 로딩이 상대적으로 엄청 오래 걸림
            2) 검색엔진의 노출이 좀 많이 어렵기에, 트래픽 늘리기가 상대적으로 어렵고, 결국 수입지표적으로 어려움이 많이 생김 
            3) client-side rendering (CSG)의 기능 및 성능향상의 최적화를 위해 알아야 했던, 프론트엔드의 전문성이라고 부르던 것들이 별로 필요함
               (= server-side rendering (SSG)을 사용하면, 결과적으로 그 딴거 쓸 이유가 사라지고, 상대적으로 프론트엔드 개발의 복잡성이 많이 줄어듬)
                   -> 다시 말해, server-side rendering (SSG)를 통해 화면 개발의 복잡성을 줄이면, 그만큼 백엔드 쪽에 대한 범용성이 또 중요해지는 시대가 올수 있음


- HTTP 메서드
   : HTTP를 통해 서버에 데이터를 어떻게 해달라고 요청하는 동사(Verb)로서의 의미를 가진방식(메서드)으로서 크게 5가지로 구분
     -> 이를 기반으로 어떤 종류의 데이터(Resource)를 작업해달랄지에 대해서는, URI 통해 전달함으로서 서버는 API의 종류를 구분함 
        (널리 사용되는건 get, post2가지)

        1. GET
            : 서버에게 데이터를 달라고 요청할 때 사용 (사용자가 보낸 URL 파라미터가 공개됨)

        2. POST
            : 서버에게 데이터를 보내서, 이를 가공하여 무언가를 요청하기까지 하는 광범위한 작업을 요청시 사용 
              (여기서부터는 사용자가 보낸 BODY영역의 데이터가 URL에 보이지 않음)

        3. PATCH
            : 서버에게 이미 존재하는 데이터의 일부를 수정할 때 사용
        
        4. PUT
            : 서버에게 이미 존재하는 데이터면 이를 통째로 바꾸도록, 없으면 추가하도록 할 때 사용

        5. DELETE
            : 서버에게 데이터를 삭제요청시에 사용


- RESTful(Representational State Transfer) API
   : 웹서버에서 URI + HTTP 메서드를 통해, 사용자와 운영자 모두에게 좋은 방식의 웹서버 API를 설계(= 작명)하는 6가지 방법론으로 이해
     (= 그냥 method, URL만 잘 기입해두면 관습적으로 REST하다고 함... )

      1. 일관적인 인터페이스(Uniform Interface)
          : 여러 URL과 method는 전체적인 개념에 일관성이 있어야 함
             - 하나의 URL로는 하나의 데이터를 가져오게 디자인하는게 좋고 
             - 간결하고 예측가능하게 URL과 method를 만드는게 사용자, 운영자 모두에게 좋음 
      
      2. Client-server 역할 구분 
          : 사용자는 사용자고! 서버는 서버다! 
            (= 사용자에게 서버가 할 역할을 맡기거나 DB를 직접 입출력하게 하는 기능을 오픈하면 안됨!)
      
      3. 무상태(Stateless)성 유지
          : 모든 요청들은 서로 의존성이 있는거 보단, 각각 독립적으로 처리되도록 API는 설계되어야 함
      
      4. 캐싱가능함(Cacheable)
          : 웹서버가 사용자들에게 보내는 자료들은 캐싱이 가능해야 좋음
             -> 자주 받는 자료들은 브라우저에서 하드에 저장해놓고 쓸 수 있게 하기에, 사용자나 서버나 트래픽이나 시간 낭비가 없음
      
      5. 계층화된 구조(Layered System)
          : 서버기능을 만들 때 레이어를 걸쳐서 코드가 실행되도록 만드는게, 프로그램의 코드 실행의 역할과 책임을 구분하기 유리함
      
      6. 실행가능한 코드(Code on demand)
          : 서버는 실행가능한 코드를 보냄으로서, 시스템에 유연성과 확장성을 제공할 수 있음

    # (참고) 그 외 API 설계시 도움되는 내용
       1. 단어들을 동사보다는 명사 위주로 구성함 
           -> 동사적 의미는 HTTP 메서드에게 맡기도록 하자

       2. 띄어쓰기는 언더바(_) 말고, 대시(-)를 사용하는게 직관적임
       3. 파일 확장자 쓰지 말기 (.html 이런거)
       4. 하위 문서들을 뜻할 땐 / 기호를 사용함 (하위폴더같은 느낌)

    # (참고) 웹서버 API 로직 작성시, 서버 API를 거치게 될 때 validation처리나 예외처리 코드를 짜는 방법론
        -> 물론 가능한 웹페이지에서 입력을 받기 전에 이를 거를 수 있게하는 로직이 들어가는게 중요함

           1. 필수적으로 들어가야 하는 데이터가 누락되거나, 적절하지 않게 들어갔다??
               : 조건문을 사용하여, 요청시 전달된 데이터 중 필요 데이터가 없거나 입력X 시를 기준으로 처리법을 나누기
                  -> or validation 라이브러리를 쓰는 것도 방법...  
                  
                     ex) express-validator, vinejs, validator 
    
           2. 어떤 코드 영역을 실행시 잠재적으로 에러가 나올수도 있는 코드가 예상된다??
               : try, catch(e) 구문을 통해, 에러가 예상되는 코드를 영역으로 묶은뒤 거기서 일어나는 에러를 처리할 수 있는 catch영역 코드를 작성하기


- 서버와 클라이언트가 통신하는 3가지 방법
 
  1. 일반 HTTP 메서드를 통한 API 요청 (클라이언트에서 일방적 호출)
      : GET, POST, PUT, PATCH, DELETE 등의 HTTP 메서드 종류를 특정 URL과 조합함으로서 서버에 API를 호출하여 요청을 보내는 방법
         -> HTTP 메서드는 대충 큰 틀의 용도를 알려주는 느낌에 가깝고, 서버측에서도 같은 URL을 HTTP 메서드 종류만 바꾸면 다른 URL처럼 사용할 수 있기에, API 제작에 있어 URL명칭 짓기가 수월해짐
     
      # 특징
         1) 2.0은 절차가 다 짜여져 있는 TCP/IP 기준, 3.0부터는 상대적으로 유저 꼴리는데로 가볍게 커스텀이 가능한 UDP를 씀
         2) a태그나 form태그를 통한 호출로는 GET, POST 기반 API 밖에 호출이 불가능함
         3) (중요) 클라이언트 측에서 먼저 호출을 보내야 서버는 응답한다는 '수동성'이 매우 강함 
            (= 유저가 움직이지 않으면 화면갱신이 안되는 서비스 뿐이 못 만듦)
 
 
  2. Server sent events (서버가 일방적 전달)
      : 서버에 한번 연결해두면 그 연결을 유지하여, 서버가 원할 때 실시간으로 라디오 같이 데이터를 마음배로 유저에게 보내줄 수 있는 서버 to 클라이언트 일방향 통신법
        (= 유저는 그냥 라디오 듣듯이 일방적으로 서버가 주는걸 받기만 할 수 있다..)
            -> 가벼운 데이터를 일정한 간격으로 클라이언트 측에 전달해야 할 때 유용함 
 
      # 사용법
         : server sent events 쓰겠다고 서버에 HTTP요청을 날리면, 서버에서 server sent events로 업그레이드해주는 식으로 사용
           (= 정확히는 화면의 script 영역에서 Server sent events 관련 함수를 통해 API를 호출하면, 서버는 header영역을 keep-alive로 하여 상호 간 연결을 유지하고, 서버는 클라이언트 측에 계속 응답을 보내주는 개념)

            ex) 서버에서 계속 유저에게 데이터를 푸시하여 새로고침해주는 주식창 
                 -> (중요) 주기적으로 뭘 보내는 데에는 setInterval()함수와 연계

  3. Websocket (서버 - 클라이언트 간 양방향 통신 가능)
      : HTTP 메서드, Server sent events의 단방향 통신이라는 치명적인 단점을 해결하여, 양측 모두가 주도적 통신이 가능한 전화 같은 통신법
         -> (중요) 단! socket.io의 경우는 상호작용 시작에 있어서 클라이언트 측의 웹소켓 선빵 요청이 필수로 필요하다는 한계는 있음
 
      # 사용법
         : Websocket 쓰겠다고 서버에 HTTP요청을 날리면, 서버에서 Websocket로 업그레이드해주는 식으로 사용
           (= 정확히는 화면의 script 영역에서 웹소켓 관련 라이브러리 함수를 이용해서, server에서 웹소켓을 사용하는 코드와 상호작용할 수 있도록 함)
 
            ex) 채팅기능, 게임기능같은 실시간 양방향 통신의 구성이 필요한 경우 사용
 
  4. (참고) long polling
      : 서버가 응답할 때 마다 유저측에서 다시 HTTP 요청을 날려서 실시간 데이터를 계속 받아내는 테크닉에 가까운 방법
        (= 유저가 서버로 HTTP 요청을 처음 날릴 때는 서버는 일단 기다린 뒤, 거기서 새로운 내용이 들어올 때 응답.어쩌구()를 날려줌)
 
      # 특징
         1) 실시간 메세지가 적을 때 유용
         2) Node.js로 서버 런타임 환경을 구축하면 써도 됨
            (= 다른 서버 환경에서 응답 칼같이 안하면, ram 용량 초과로 인해 서버 다운될 위험이 존재할 수도 있음)


- 미들웨어(middleware)
   : 웹서버의 API가 클라이언트의 요청으로 호출될 시, 응답되기 전에 실행되는 함수를 큰 틀에서 통칭하여 의미
      ex) API를 실행하기 전에, 현재 요청한 유저가 login을 한 상태인지 API를 응답하기 전에 실행하는 코드 및 함수 내용

